<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猫宁i</title>
  
  <subtitle>趁着年轻，好好生活，用心折腾。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.maoning.pro/"/>
  <updated>2019-11-20T11:09:50.709Z</updated>
  <id>http://blog.maoning.pro/</id>
  
  <author>
    <name>猫宁i</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</title>
    <link href="http://blog.maoning.pro/archives/d63e1e23.html"/>
    <id>http://blog.maoning.pro/archives/d63e1e23.html</id>
    <published>2019-11-20T10:49:08.000Z</published>
    <updated>2019-11-20T11:09:50.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开始本章的讲解之前，我们首先从宏观角度回顾一下 Redis 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？</p><p>Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。</p><p>在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。</p><a id="more"></a><h2 id="Redis-HA-实践（Redis-Sentinel）"><a href="#Redis-HA-实践（Redis-Sentinel）" class="headerlink" title="Redis HA 实践（Redis Sentinel）"></a>Redis HA 实践（Redis Sentinel）</h2><h3 id="Redis-Sentinel-概述"><a href="#Redis-Sentinel-概述" class="headerlink" title="Redis Sentinel 概述"></a>Redis Sentinel 概述</h3><p>Sentinel（哨岗、哨兵）是 Redis 的高可用（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p><img src="/media/15729465186457/20191105190000.jpg" alt="20191105190000"></p><p><img src="/media/15729465186457/20191105190002.jpg" alt="20191105190002"></p><p>当 server1 的下线时长超过用户设定的下线时长上限时，Sentinel 系统就会对 server1 执行故障转移操作：</p><ul><li>首先，Sentinel 系统会挑选 server1 属下的其中一个从服务器，并将这个被选中的从服务升级为新的主服务器。</li><li>之后，Sentinel 系统会向 server1 属下的所有从服务器发送新的复制指令，让他们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>另外，Sentinel 还会继续监视已下线的 server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p>Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><h3 id="Redis-Sentinel-重点总结"><a href="#Redis-Sentinel-重点总结" class="headerlink" title="Redis Sentinel 重点总结"></a>Redis Sentinel 重点总结</h3><ul><li>Sentinel 只是一个运行在特殊模式下的 Redis 服务器，因此初始化服务器时将普通 Redis 服务器使用的代码替换成 Sentinel 专门代码，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。</li><li>Sentinel 会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。</li><li>Sentinel 通过主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。在一般情况下，Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令，当主服务器处于下线状态，或者 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</li><li>对于监视同一个主服务器和从服务器的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务器的 _sentinel_:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。每个 Sentinel 也会从 _sentinel_:hello 频道中接收其他 Sentinel 发来的消息，并根据这些消息为其他 Sentinel 创建相应的实例结构以及命令连接。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel 与 Sentinel 之间则只创建命令连接。</li><li>Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令，并根据实例对 PING 命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。</li><li>当 Sentinel 将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其它 Sentinel 进行询问，看它们是否同意这个主服务器已经进入主观下线状态。当 Sentinel 收集到足够多的的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。  </li><li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel<sup>[1]</sup>，并由领头 Sentinel 对下线主服务器进行故障转移操作。</li></ul><h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a>Redis Sentinel 搭建</h3><h4 id="Redis-Sentinel-部署技巧及其环境"><a href="#Redis-Sentinel-部署技巧及其环境" class="headerlink" title="Redis Sentinel 部署技巧及其环境"></a>Redis Sentinel 部署技巧及其环境</h4><ul><li>一个健壮的部署至少需要三个哨兵实例，并且使用奇数个 Sentinel。</li><li>三个哨兵实例应该放置在客户使用独立方式确认故障的计算机或虚拟机中，例如不同的物理机或不同可用区域的虚拟机。</li><li>哨兵配置文件中只需要配置主从复制中的主副本 ip 和端口即可，当主从进行切换时哨兵会自动修改哨兵配置文件中的主副本 ip 为新在主副本 ip。 </li></ul><p><img src="/media/15729465186457/20170405093045288.png" alt="20170405093045288"></p><p>由于本人没有这么多服务器，因此在一台机器上模拟一个 Redis Sentinel 集群。</p><table><thead><tr><th><strong>角色</strong></th><th><strong>IP 地址</strong></th><th><strong>端口号</strong></th></tr></thead><tbody><tr><td>Redis Master</td><td>127.0.0.1</td><td>6380</td></tr><tr><td>Redis Slave-01</td><td>127.0.0.1</td><td>6381</td></tr><tr><td>Redis Slave-02</td><td>127.0.0.1</td><td>6382</td></tr><tr><td>Redis Slave-03</td><td>127.0.0.1</td><td>6383</td></tr><tr><td>Redis Sentinel-01</td><td>127.0.0.1</td><td>26381</td></tr><tr><td>Redis Sentinel-02</td><td>127.0.0.1</td><td>26382</td></tr><tr><td>Redis Sentinel-03</td><td>127.0.0.1</td><td>26383</td></tr></tbody></table><h4 id="Redis-Sentinel-安装指南"><a href="#Redis-Sentinel-安装指南" class="headerlink" title="Redis Sentinel 安装指南"></a>Redis Sentinel 安装指南</h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># mkdir /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># wget http://download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># tar -zvxf redis-5.0.6.tar.gz -C /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># cd /usr/local/redis/redis-5.0.6/</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-5.0</span><span class="number">.6</span>]<span class="meta"># make PREFIX=/usr/local/redis install</span></span><br></pre></td></tr></table></figure><p>2、设置 Redis 主服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span></span><br><span class="line">[root@VM_24_98_centos redis-master]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/redis.conf /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span>/</span><br><span class="line">[root@VM_24_98_centos redis-master]# vim /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span>/redis.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Master 主服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启远程连接</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-master/redis-6380/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-master/redis-6380/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-master/redis-6380/</span><br><span class="line"><span class="comment"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="comment"># 开启 AOF 持久化</span></span><br><span class="line">appendonly <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Master 主服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6380</span>]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6380</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6380&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:master</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:5c1034ac4dec31d6a4ae883e1eaacca3a78bc3b6</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:0</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:0</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:0</span></span><br><span class="line"><span class="section">repl_backlog_histlen:0</span></span><br></pre></td></tr></table></figure><p>3、设置 Redis 从服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span></span><br><span class="line">[root@VM_24_98_centos redis-slave]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/redis.conf /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-slave]# vim /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span>/redis.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Slave 从服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启远程连接</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6381</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-slave/redis-6381/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-slave/redis-6381/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-slave/redis-6381/</span><br><span class="line"><span class="comment"># 主从复制 Master 节点地址 + 端口</span></span><br><span class="line">replicaof 127.0.0.1 6380</span><br><span class="line"><span class="comment"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="comment"># 开启 AOF 持久化</span></span><br><span class="line">appendonly <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Slave 从服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6381</span>]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-6381/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6381</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-6381/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6381 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6381&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:slave</span></span><br><span class="line"><span class="section">master_host:127.0.0.1</span></span><br><span class="line"><span class="section">master_port:6380</span></span><br><span class="line"><span class="section">master_link_status:up</span></span><br><span class="line"><span class="section">master_last_io_seconds_ago:5</span></span><br><span class="line"><span class="section">master_sync_in_progress:0</span></span><br><span class="line"><span class="section">slave_repl_offset:14</span></span><br><span class="line"><span class="section">slave_priority:100</span></span><br><span class="line"><span class="section">slave_read_only:1</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:14</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:1</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:1</span></span><br><span class="line"><span class="section">repl_backlog_histlen:14</span></span><br></pre></td></tr></table></figure><p>e. 同理，从服务器 redis-6382、redis-6383 按照上面的步骤部署。</p><p>4、Redis Sentinel 部署</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span></span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/sentinel.conf /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# vim /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span>/sentinel.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Sentinel 哨兵服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 26381</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-sentinel/redis-26381/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-sentinel/redis-26381/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-sentinel/redis-26381/</span><br><span class="line"><span class="comment"># 指定监控 master&#123;2 表示多少个 sentinel 同意&#125;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6380 2</span><br><span class="line"><span class="comment"># 安全信息</span></span><br><span class="line">sentinel auth-pass mymaster foobared</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Sentinel 哨兵服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-26381</span>]<span class="meta"># /usr/local/redis/bin/redis-sentinel /usr/local/redis/redis-sentinel/redis-26381/sentinel.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-26381</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 26381</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:26381&gt; INFO SENTINEL</span></span><br><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line"><span class="section">sentinel_masters:1</span></span><br><span class="line"><span class="section">sentinel_tilt:0</span></span><br><span class="line"><span class="section">sentinel_running_scripts:0</span></span><br><span class="line"><span class="section">sentinel_scripts_queue_length:0</span></span><br><span class="line"><span class="section">sentinel_simulate_failure_flags:0</span></span><br><span class="line"><span class="section">master0:name=mymaster,status=ok,address=127.0.0.1:6380,slaves=3,sentinels=1</span></span><br></pre></td></tr></table></figure><p>e. 同理，哨兵服务器 redis-26382、redis-26383 按照上面的步骤部署</p><p>f. 查看 Redis Master 主服务器连接状况</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6380</span>&gt; INFO REPLICATION</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">3</span></span><br><span class="line">slave0:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6383</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">slave1:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6381</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">slave2:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6382</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">master_replid:cc8ef3fe2e51a714f5b73b2fbe3bd697cacbc453</span><br><span class="line">master_replid2:<span class="number">8</span>ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line">master_repl_offset:<span class="number">20836</span></span><br><span class="line">second_repl_offset:<span class="number">1522</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">1</span></span><br><span class="line">repl_backlog_histlen:<span class="number">20836</span></span><br></pre></td></tr></table></figure><h3 id="Redis-Sentinel-场景测试"><a href="#Redis-Sentinel-场景测试" class="headerlink" title="Redis Sentinel 场景测试"></a>Redis Sentinel 场景测试</h3><p>模拟场景：Redis Master 节点挂掉，查看 Redis 集群状态。</p><p>Step1、关掉 Master 节点</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta">127.0.0.1:6380&gt;</span> SHUTDOWN</span><br></pre></td></tr></table></figure><p>Step2、通过哨兵查看集群状态</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 26381</span></span><br><span class="line"><span class="section">127.0.0.1:26381&gt; INFO SENTINEL</span></span><br><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line"><span class="section">sentinel_masters:1</span></span><br><span class="line"><span class="section">sentinel_tilt:0</span></span><br><span class="line"><span class="section">sentinel_running_scripts:0</span></span><br><span class="line"><span class="section">sentinel_scripts_queue_length:0</span></span><br><span class="line"><span class="section">sentinel_simulate_failure_flags:0</span></span><br><span class="line"><span class="section">master0:name=mymaster,status=ok,address=127.0.0.1:6381,slaves=3,sentinels=3</span></span><br></pre></td></tr></table></figure><p>通过 Sentinel 信息可以看到，Master 节点已经自动切换到 6381 端口了，说明主节点挂掉后，6381 Slave 节点自动升级成为了 Master 节点。</p><p>通过 Sentinel 日志文件显示了 failover 的过程：</p><p><img src="/media/15729465186457/20191119161856.png" alt="20191119161856"></p><p>Step3、启动 6380 Redis 服务，然后查看节点角色，此时 6380 变成了 Slave，6381 为 Master 节点</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6380&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:slave</span></span><br><span class="line"><span class="section">master_host:127.0.0.1</span></span><br><span class="line"><span class="section">master_port:6381</span></span><br><span class="line"><span class="section">master_link_status:up</span></span><br><span class="line"><span class="section">master_last_io_seconds_ago:1</span></span><br><span class="line"><span class="section">master_sync_in_progress:0</span></span><br><span class="line"><span class="section">slave_repl_offset:782228</span></span><br><span class="line"><span class="section">slave_priority:100</span></span><br><span class="line"><span class="section">slave_read_only:1</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:84aa69ee0b191bba31162c26c4ddb1c87a705f7e</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:782228</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:1</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:777789</span></span><br><span class="line"><span class="section">repl_backlog_histlen:4440</span></span><br></pre></td></tr></table></figure><h2 id="Redis-HA-实践（Redis-Cluster）"><a href="#Redis-HA-实践（Redis-Cluster）" class="headerlink" title="Redis HA 实践（Redis Cluster）"></a>Redis HA 实践（Redis Cluster）</h2><h3 id="Redis-Cluster-概述"><a href="#Redis-Cluster-概述" class="headerlink" title="Redis Cluster 概述"></a>Redis Cluster 概述</h3><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）而非一致性哈希（consistency hashing）来进行数据分享，并提供复制和故障转移功能。Redis Cluster，主要是针对海量数据 + 高并发 + 高可用的场景。Redis Cluster 支撑 N 个 Redis Master Node，每个 Master Node 都可以挂载多个 Slave Node。Redis Cluster 节点间采用 Gossip 协议<sup>[2]</sup>进行通信。</p><p><strong>节点</strong>：一个 Redis 集群通常由多个节点（node）组成，连接各个节点的工作可以使用 CLUSTER MEET \&lt;ip> \&lt;port> 命令来完成，将各个独立的节点连接起来，构成一个包含多个节点的集群。向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</p><p><img src="/media/15729465186457/20191120113607.png" alt="20191120113607"></p><p><strong>槽指派</strong>：Redis 集群通过分片的方式来保存数据库中的键值对，集群的整数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。Redis 集群有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><p><img src="/media/15729465186457/20191120114329.png" alt="20191120114329"></p><h3 id="Redis-Cluster-重点总结"><a href="#Redis-Cluster-重点总结" class="headerlink" title="Redis Cluster 重点总结"></a>Redis Cluster 重点总结</h3><ul><li>节点通过握手来将其他节点添加到自己所处的集群当中。</li><li>集群中的 16384（2的14次方）个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给其他节点。</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li><li>对 Redis 集群的重新分片工作是由 redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另外一个节点。重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</li><li>如果节点 A 正在迁移槽 i 至节点 B，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</li><li>MOVED 错误表示槽的负责权已经从一个节点转移到了另外一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</li><li>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li><li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 MEET、PING、PONG、PUBLISH、FAIL 五种。</li></ul><h3 id="Redis-Cluster-搭建"><a href="#Redis-Cluster-搭建" class="headerlink" title="Redis Cluster 搭建"></a>Redis Cluster 搭建</h3><h4 id="Redis-Cluster-部署技巧及其环境"><a href="#Redis-Cluster-部署技巧及其环境" class="headerlink" title="Redis Cluster 部署技巧及其环境"></a>Redis Cluster 部署技巧及其环境</h4><ul><li>Redis 集群至少需要 3 个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以 2 个节点无法构成集群。</li><li>要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，即三主三从，所以 Redis 集群至少需要 6 台服务器。</li><li>Redis 5.0 开始不再使用 Ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</li><li>不支持多数据库空间，集群模式下只能使用 db0 空间。</li></ul><p><img src="/media/15729465186457/20181225100026745.png" alt="20181225100026745"></p><p>由于资源有限，因此在一台机器上模拟一个 Redis Cluster。</p><table><thead><tr><th><strong>角色</strong></th><th><strong>IP 地址</strong></th><th><strong>端口号</strong></th></tr></thead><tbody><tr><td>Redis Cluster-Master-01-6391</td><td>127.0.0.1</td><td>6391</td></tr><tr><td>Redis Cluster-Master-02-6393</td><td>127.0.0.1</td><td>6393</td></tr><tr><td>Redis Cluster-Master-02-6395</td><td>127.0.0.1</td><td>6395</td></tr><tr><td>Redis Cluster-Slave-01-6394</td><td>127.0.0.1</td><td>6394</td></tr><tr><td>Redis Cluster-Slave-02-6396</td><td>127.0.0.1</td><td>6396</td></tr><tr><td>Redis Cluster-Slave-03-6392</td><td>127.0.0.1</td><td>6392</td></tr></tbody></table><h4 id="Redis-Cluster-安装指南"><a href="#Redis-Cluster-安装指南" class="headerlink" title="Redis Cluster 安装指南"></a>Redis Cluster 安装指南</h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># mkdir /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># wget http://download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># tar -zvxf redis-5.0.6.tar.gz -C /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># cd /usr/local/redis/redis-5.0.6/</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-5.0</span><span class="number">.6</span>]<span class="meta"># make PREFIX=/usr/local/redis install</span></span><br></pre></td></tr></table></figure><p>2、设置 Redis Cluster  服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# <span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391</span><br><span class="line">[root@VM_24_98_centos ~]# cp -r /usr/<span class="keyword">local</span>/redis/redis-5.0.6/redis.<span class="keyword">conf</span> /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391/</span><br><span class="line">[root@VM_24_98_centos ~]# vim /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391/redis.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>b. 设置 Redis Cluster 服务器配置环境</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 开启远程连接</span></span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="keyword">protected</span>-mode no</span><br><span class="line"><span class="meta"># 端口号</span></span><br><span class="line">port <span class="number">6391</span></span><br><span class="line"><span class="meta"># 守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/redis.pid</span><br><span class="line"><span class="meta"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/redis.log</span><br><span class="line"><span class="meta"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/</span><br><span class="line"><span class="meta"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="meta"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="meta"># 开启 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># 开启集群</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta"># 集群的配置文件，首次启动会自动创建</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"><span class="meta"># 集群节点连接超时时间，15秒</span></span><br><span class="line">cluster-node-timeout <span class="number">15000</span></span><br></pre></td></tr></table></figure><p>c. 启动 Redis Cluster 服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-6391/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-6391/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6391 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6391&gt; CLUSTER INFO</span></span><br><span class="line"><span class="section">cluster_state:fail</span></span><br><span class="line"><span class="section">cluster_slots_assigned:0</span></span><br><span class="line"><span class="section">cluster_slots_ok:0</span></span><br><span class="line"><span class="section">cluster_slots_pfail:0</span></span><br><span class="line"><span class="section">cluster_slots_fail:0</span></span><br><span class="line"><span class="section">cluster_known_nodes:1</span></span><br><span class="line"><span class="section">cluster_size:0</span></span><br><span class="line"><span class="section">cluster_current_epoch:0</span></span><br><span class="line"><span class="section">cluster_my_epoch:0</span></span><br><span class="line"><span class="section">cluster_stats_messages_sent:0</span></span><br><span class="line"><span class="section">cluster_stats_messages_received:0</span></span><br></pre></td></tr></table></figure><p>e. 同理，集群服务器 redis-6392、redis-6393 、redis-6394、redis-6395、redis-6396 按照上面的步骤部署</p><p>3、Redis 5.0 开始不再使用 ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</p><p>a. 创建顺序三主三从，前面三个是主后面三个是从。由于我们设置了redis集群的密码，所以要带上密码。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster create <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6393</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6395</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6392</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6394</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6396</span> --cluster-replicas <span class="number">1</span> -a foobared</span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120150814.png" alt="20191120150814"></p><p>b. 客户端测试连接</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:<span class="number">16384</span></span><br><span class="line">cluster_slots_ok:<span class="number">16384</span></span><br><span class="line">cluster_slots_pfail:<span class="number">0</span></span><br><span class="line">cluster_slots_fail:<span class="number">0</span></span><br><span class="line">cluster_known_nodes:<span class="number">6</span></span><br><span class="line">cluster_size:<span class="number">3</span></span><br><span class="line">cluster_current_epoch:<span class="number">6</span></span><br><span class="line">cluster_my_epoch:<span class="number">1</span></span><br><span class="line">cluster_stats_messages_ping_sent:<span class="number">1153</span></span><br><span class="line">cluster_stats_messages_pong_sent:<span class="number">1241</span></span><br><span class="line">cluster_stats_messages_sent:<span class="number">2394</span></span><br><span class="line">cluster_stats_messages_ping_received:<span class="number">1236</span></span><br><span class="line">cluster_stats_messages_pong_received:<span class="number">1153</span></span><br><span class="line">cluster_stats_messages_meet_received:<span class="number">5</span></span><br><span class="line">cluster_stats_messages_received:<span class="number">2394</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> slave c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">5</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574234725711</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574234724708</span> <span class="number">6</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,master - <span class="number">0</span> <span class="number">1574234725000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574234723000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br></pre></td></tr></table></figure><h3 id="Redis-Cluster-场景测试"><a href="#Redis-Cluster-场景测试" class="headerlink" title="Redis Cluster 场景测试"></a>Redis Cluster 场景测试</h3><p>（1）模拟场景：Redis Cluster 中 某个 Master 节点挂掉，查看 Redis Cluster 状态。</p><p>Step1、关掉 Cluster-Master-6391 节点</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6391 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta">127.0.0.1:6391&gt;</span> SHUTDOWN</span><br></pre></td></tr></table></figure><p>Step2、查看集群状态</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6393</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6393</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574236204772</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574236206778</span> <span class="number">6</span> connected</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> master - <span class="number">0</span> <span class="number">1574236201000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574236206000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> master,fail - <span class="number">1574236049092</span> <span class="number">1574236047289</span> <span class="number">1</span> disconnected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> myself,master - <span class="number">0</span> <span class="number">1574236204000</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br></pre></td></tr></table></figure><p>通过 CLUSTER NODES 信息可以看到，Cluster-Master-01-6391 主节点处于下线状态（fail），其 Cluster-Master-01-6391 节点的从节点 Cluster-Slave-01-6394 变为主节点；说明主节点挂掉后，6394 Slave 节点自动升级成为了 Master 节点。</p><p>Step3、启动 6391 Redis 服务，然后查看节点角色，此时 6391 变成了 Slave，6394 为 Master 节点</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.conf</span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574238264397</span> <span class="number">4</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,slave cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">0</span> <span class="number">1574238261000</span> <span class="number">1</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574238265400</span> <span class="number">6</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> master - <span class="number">0</span> <span class="number">1574238264000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br></pre></td></tr></table></figure><p>（2）模拟场景：为 Redis Cluster 添加一个新主（master）节点 </p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器  Cluster-Master-04-6397</p><p>Step2、将 Cluster-Master-04-6397 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6397</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span>  -a foobared</span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120164716.png" alt="20191120164716"></p><p>Step3、为节点  Cluster-Master-04-6397 分配 slots（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-cluster]# /usr/<span class="keyword">local</span>/redis/bin/redis-cli <span class="comment">--cluster reshard 127.0.0.1:6391 -a foobared</span></span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120173744.png" alt="20191120173744"></p><p>（3）模拟场景：为 Redis Cluster 某个 Master 节点添加 一个新从（slave）节点 </p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器  Cluster-Slave-04-6398</p><p>Step2、将 Cluster-Slave-04-6398 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这种方法随机为 <span class="number">6398</span> 指定一个 master</span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> --cluster-slave -a foobared</span><br><span class="line"></span><br><span class="line">// 这种方式将为 <span class="number">6398</span> 指定某个 master-id</span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> --cluster-slave --cluster-master-id 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c -a foobared</span><br></pre></td></tr></table></figure><p>Step3、查看集群状态</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">5</span>cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">127.0.0.1</span>:<span class="number">6397@16397</span> master - <span class="number">0</span> <span class="number">1574243297701</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">1364 5461</span>-<span class="number">6826 10923</span>-<span class="number">12287</span></span><br><span class="line"><span class="number">207628</span>f6fb8b3bb9a22db757507350fb<span class="number">880d4990</span> <span class="number">127.0.0.1</span>:<span class="number">6396@16396</span> slave <span class="number">94</span>af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">0</span> <span class="number">1574243294000</span> <span class="number">6</span> connected</span><br><span class="line"><span class="number">94</span>af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574243296700</span> <span class="number">2</span> connected <span class="number">6827-10922</span></span><br><span class="line"><span class="number">2</span>e0134b0a87a73903d4774b6b37dd<span class="number">43e78e93733</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,master - <span class="number">0</span> <span class="number">1574243292000</span> <span class="number">1</span> connected <span class="number">1365-5460</span></span><br><span class="line"><span class="number">21</span>a288afc7b6addebcd943ca606dd34f6b9c99db <span class="number">127.0.0.1</span>:<span class="number">6398@16398</span> slave <span class="number">5</span>cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">0</span> <span class="number">1574243295697</span> <span class="number">7</span> connected</span><br><span class="line"><span class="number">63</span>bc9da88066b475bd878a56a11dd<span class="number">18023b211b6</span> <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> slave <span class="number">2</span>e0134b0a87a73903d4774b6b37dd<span class="number">43e78e93733</span> <span class="number">0</span> <span class="number">1574243295000</span> <span class="number">5</span> connected</span><br><span class="line">c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574243296000</span> <span class="number">3</span> connected <span class="number">12288-16383</span></span><br><span class="line">f6a7c788d9e5d40bc62a3723ba02c25607cc<span class="number">2825 127.0</span>.<span class="number">0.1:6392</span>@<span class="number">16392</span> slave c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">0</span> <span class="number">1574243293694</span> <span class="number">4</span> connected</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.cnblogs.com/xybaby/p/10124083.html" target="_blank" rel="noopener">一文搞懂 Raft 算法</a><br>[2]. <a href="https://www.cnblogs.com/chenmh/p/5578376.html" target="_blank" rel="noopener">Redis 哨兵模式实现主从故障互切换</a><br>[3]. <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a><br>[4]. <a href="https://www.bangbangde.com/post/gossip.html" target="_blank" rel="noopener">redis cluster 的Gossip协议介绍</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 领头 Sentinel：Sentinel 系统选举领头 Sentinel 的方式是对 Raft 算法的领头选举方法的实现，Raft 算法是一个共识算法，是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。</small><br><small>[2]. Gossip 协议：Gossip protocol 也叫 Epidemic Protocol（流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法” 等。Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个“最终一致性协议”。</small></p><hr><h2 id="Redis-深度探险系列"><a href="#Redis-深度探险系列" class="headerlink" title="Redis 深度探险系列"></a>Redis 深度探险系列</h2><ul><li><a href="8fb486e9.html">Redis 深度探险（一）：那些绕不过去的 Redis 知识点</a></li><li><a href="e993c76c.html">Redis 深度探险（二）：Redis 深入之道</a></li><li><a href="14348371.html">Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</a></li><li><a href="d63e1e23.html">Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开始本章的讲解之前，我们首先从宏观角度回顾一下 Redis 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？&lt;/p&gt;
&lt;p&gt;Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。&lt;/p&gt;
&lt;p&gt;在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.maoning.pro/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.maoning.pro/tags/Redis/"/>
    
      <category term="高可用" scheme="http://blog.maoning.pro/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="集群" scheme="http://blog.maoning.pro/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="哨兵" scheme="http://blog.maoning.pro/tags/%E5%93%A8%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构（二）：大白话布隆过滤器 Bloom Filter</title>
    <link href="http://blog.maoning.pro/archives/6e0aae0d.html"/>
    <id>http://blog.maoning.pro/archives/6e0aae0d.html</id>
    <published>2019-10-11T10:12:18.000Z</published>
    <updated>2019-10-11T10:31:56.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“一个网站有 20 亿 url 存在一个黑名单中，这个黑名单要怎么存？若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？并且需在给定内存空间（比如：500M）内快速判断出。” 这是一道经常在面试中出现的算法题。</p><p>很多人脑海中首先想到的可能是 HashSet，因为 HashSet 的底层是采用 HashMap 实现的，理论上时间复杂度为：O(1)。达到了快速的目的，但是空间复杂度呢？URL 字符串通过 Hash 得到一个 Integer 的值，Integer 占 4 个字节，那 20 亿个 URL 理论上需要：4 字节 (byte) * 20 亿  =  80 亿 (byte)  ≈ 7.45G   的内存空间，不满足空间复杂度的要求。</p><p>还有一种方法就是位图法<sup>[1]</sup>，每个 URL 取整数哈希值，置于位图相应的位置上，看上去是可行的。但位图适合对海量的、取值分布很均匀的集合去重。位图法的所占空间随集合内最大元素的增大而增大，即空间复杂度随集合内最大元素增大而线性增大。要设计冲突率很低的哈希函数，势必要增加哈希值的取值范围，4G 的位图最大值是 320 亿左右，为 50 亿条 URL 设计冲突率很低、最大值为 320 亿的哈希函数比较困难。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。因此，出于性能和内存占用的考虑，在这里使用布隆过滤器才是最好的解决方案：布隆过滤器是对位图的一种改进。</p><p>这里就引出本文要介绍的 “布隆过滤器”。</p><a id="more"></a><h2 id="Bloom-Filter-概述"><a href="#Bloom-Filter-概述" class="headerlink" title="Bloom Filter 概述"></a>Bloom Filter 概述</h2><p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><h2 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>Bloom Filter 跟单哈希函数 Bit-Map 不同之处在于：Bloom Filter 使用了 k 个哈希函数，每个字符串跟 k 个 bit 对应，从而降低了冲突的概率。</p><p><img src="/media/15697553373443/740591-20180623183045586-692673875.jpg" alt="740591-20180623183045586-692673875"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主要是解决大规模数据下不需要精确过滤的场景。</p><ul><li>检查垃圾邮件地址：如果用哈希表，每存储一亿个 email 地址，就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。而 Bloom Filter 只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。布隆过滤器决不会漏掉任何一个在黑名单中的可疑地址。至于误判问题，常见的补救办法是在建立一个小的白名单，存储那些可能被误判的清白邮件地址。</li><li>解决缓存穿透：缓存穿透，是指查询一个数据库中不一定存在的数据。正常情况下，查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并将查询到的对象放进缓存。如果每次都查询一个数据库中不存在的 key，由于缓存中没有数据，每次都会去查询数据库，很可能会对数据库造成影响。缓存穿透的一种解决办法是为不存在的 key 缓存一个空值，直接在缓存层返回。这样做的弊端就是缓存太多空值占用了太多额外的空间，这点可以通过给缓存层空值设立一个较短的过期时间来解决。另一种解决办法就是使用布隆过滤器，查询一个 key 时，先使用布隆过滤器进行过滤，如果判断请求查询 key 值存在，则继续查询数据库；如果判断请求查询不存在，直接丢弃。</li><li>Key-Value 缓存系统的 Key 校验：在很多 Key-Value 系统中也使用了布隆过滤器来加快查询过程，如 Hbase，Accumulo，Leveldb，一般而言，Value 保存在磁盘中，访问磁盘需要花费大量时间，然而使用布隆过滤器可以快速判断某个 Key 对应的 Value 是否存在，因此可以避免很多不必要的磁盘 IO 操作，只是引入布隆过滤器会带来一定的内存消耗。</li><li>Google 的 BigTable：Google 的 BigTable 也使用了布隆过滤器，以减少不存在的行或列在磁盘上的 I/O。</li><li>新闻客户端推荐系统：推荐系统给用户推荐新闻，避免重复推送。</li><li>爬虫 URL 地址去重：爬虫时判断某个 URL 是否已经被爬取过。</li><li>单词拼写检查</li><li>黑名单过滤</li><li>…</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="HashSet-实现"><a href="#HashSet-实现" class="headerlink" title="HashSet 实现"></a>HashSet 实现</h3><p>利用 HashSet 实现黑名单过滤，写入和判断元素是否存在都有对应的 API，所以实现起来也比较简单。</p><p>通过单元测试演示 HashSet 实现黑名单过滤功能；同时为了前后的对比将堆内存写死（-Xms64m -Xmx64m），为了方便调试加入了 GC 日志的打印（-XX:+PrintHeapAtGC），以及内存溢出后 Dump 内存（-XX:+HeapDumpOnOutOfMemoryError）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-Xms64m</span> <span class="selector-tag">-Xmx64m</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+PrintHeapAtGC</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+HeapDumpOnOutOfMemoryError</span></span><br></pre></td></tr></table></figure><p>1、写入 100 条数据时：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> void testHashSet() &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="keyword">Integer</span>&gt; hashSet = new HashSet&lt;&gt;(<span class="number">10000000</span>);</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        hashSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    long <span class="keyword">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, <span class="keyword">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、写入 1000 W 条数据时：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> void testHashSet() &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="keyword">Integer</span>&gt; hashSet = new HashSet&lt;&gt;(<span class="number">10000000</span>);</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        hashSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    long <span class="keyword">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, <span class="keyword">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后马上就内存溢出，可见在内存有限的情况下我们不能使用这种方式。</p><p><img src="/media/15697553373443/20191008192956.png" alt="20191008192956"></p><h3 id="Guava-中的布隆过滤器"><a href="#Guava-中的布隆过滤器" class="headerlink" title="Guava 中的布隆过滤器"></a>Guava 中的布隆过滤器</h3><p>BloomFilter 实现的一个重点就是怎么利用 hash 函数把数据映射到 bit 数组中。Guava 的实现是对元素通过 MurmurHash3 计算 hash 值，将得到的 hash 值取高 8 个字节以及低 8 个字节进行计算，以得当前元素在 bit 数组中对应的多个位置。</p><p>Guava 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 numBits 以及需要计算几次 Hash 函数 numHashFunctions 。</p><p>1、组件依赖：通过 Maven 引入 Guava 开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现布隆过滤器</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGuava</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期数据量</span></span><br><span class="line">    <span class="keyword">long</span> expectedInsertions = <span class="number">10000000</span>;</span><br><span class="line">    <span class="comment">// 预期误判率</span></span><br><span class="line">    <span class="keyword">double</span> fpp = <span class="number">0.001</span>;</span><br><span class="line">    <span class="comment">// 创建存储 Integer 数据的布隆过滤器</span></span><br><span class="line">    BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), expectedInsertions, fpp);</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断过滤器中是否存在元素</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"预期数据量：%s，判断数量：%s，预期误判率：%s，存在比率：%s \n"</span>, <span class="number">10000000</span>, count, fpp, count * <span class="number">1.0</span> / expectedInsertions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断误判比例</span></span><br><span class="line">    <span class="keyword">int</span> fppCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000000</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">            fppCount++;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i + <span class="string">"误判了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"预期数据量：%s，误判数量：%s，预期误判率：%s，实际误判率：%s \n"</span>, <span class="number">10000000</span>, fppCount, fpp, fppCount * <span class="number">1.0</span> / expectedInsertions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：我们的定义了一个预期数据量为 1000 W、预期误判率为 0.001 的布隆过滤器，接下来向布隆过滤器中插入了 0-10000000 数据，然后用 0- 10000000 以及 10000000-20000000 数据来测试误判率。</p><p>（1）经过测试：“预期数据量：10000000，判断数量：10000000，预期误判率：0.001，存在比率：1.0 ”，可发现当过滤器判断 0-10000000 的数据时，存在比率为 1.0，即布隆过滤器对于已经见过的元素肯定不会误判，它只会误判那些没见过的元素。</p><p>（2）经过测试：“预期数据量：10000000，误判数量：10132，预期误判率：0.001，实际误判率：0.0010132” ，符合预期误判率：0.001。</p><h3 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h3><h4 id="安装-Rebloom-插件"><a href="#安装-Rebloom-插件" class="headerlink" title="安装 Rebloom 插件"></a>安装 Rebloom 插件</h4><p>1、安装 Rebloom 插件：Redis 安装在这里就不介绍了，这里讲一下 Rebloom 插件安装。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载 Rebloom 源文件</span></span><br><span class="line"><span class="symbol">$</span> git clone git:<span class="comment">//github.com/RedisLabsModules/rebloom</span></span><br><span class="line"><span class="comment">// 进入 Rebloom 目录</span></span><br><span class="line"><span class="symbol">$</span> cd rebloom</span><br><span class="line"><span class="comment">// 编译插件</span></span><br><span class="line"><span class="symbol">$</span> make</span><br></pre></td></tr></table></figure><p>2、加载 Rebloom 插件方法</p><p>（1）、在启动的 client 中使用 MODULE LOAD 命令去加载（重启 Redis 后失效）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE LOAD <span class="regexp">/usr/</span>lib64<span class="regexp">/redis/m</span>odules<span class="regexp">/rebloom/</span>redisbloom.so</span><br></pre></td></tr></table></figure><p>（2）、命令行加载 Rebloom 插件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/redis-server /</span>etc<span class="regexp">/redis.conf --loadmodule /u</span>sr<span class="regexp">/lib64/</span>redis<span class="regexp">/modules/</span>rebloom<span class="regexp">/redisbloom.so</span></span><br></pre></td></tr></table></figure><p>（3）、在 redis.conf 文件中加入配置信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule <span class="regexp">/usr/</span>lib64<span class="regexp">/redis/m</span>odules<span class="regexp">/rebloom/</span>redisbloom.so</span><br></pre></td></tr></table></figure><p>3、通过命令测试 Redis Bloom Filter</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的布隆过滤器，并设置一个期望的错误率和初始大小。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.RESERVE</span> userid <span class="number">0.01</span> <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往过滤器中添加元素。如果 key 不存在，过滤器会自动创建。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.ADD</span> userid <span class="string">'101310299'</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.MADD</span> userid <span class="string">'101310299'</span> <span class="string">'101310366'</span> <span class="string">'101310211'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断过滤器中是否存在该元素，不存在返回 0，存在返回 1。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.EXISTS</span> userid <span class="string">'101310299'</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.EXISTS</span> userid <span class="string">'101310299'</span> <span class="string">'10saa'</span> <span class="string">'101310211'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该 Bloom Filter 使用的内存大小</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; Memory Usage userid</span><br></pre></td></tr></table></figure><h4 id="通过-Java-代码实现布隆过滤器"><a href="#通过-Java-代码实现布隆过滤器" class="headerlink" title="通过 Java 代码实现布隆过滤器"></a>通过 Java 代码实现布隆过滤器</h4><p>1、组件依赖：通过 Maven 引入 Redisson <sup>[2]</sup>开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现布隆过滤器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testRedis() &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Redis 连接信息</span></span><br><span class="line">    Config <span class="built_in">config</span> = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="built_in">config</span>.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>)</span><br><span class="line">            .setPassword(<span class="string">"password"</span>)</span><br><span class="line">            .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Redisson 客户端</span></span><br><span class="line">    RedissonClient redissonClient = Redisson.create(<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redisson 利用 Redis 实现了 Java 分布式布隆过滤器（Bloom Filter）</span></span><br><span class="line">    RBloomFilter&lt;Integer&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">"userid"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期数据量</span></span><br><span class="line">    <span class="keyword">long</span> expectedInsertions = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 预期误判率</span></span><br><span class="line">    <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line">    <span class="comment">// 初始化布隆过滤器，预计统计元素数量为 10000，期望误差率为 0.001</span></span><br><span class="line">    bloomFilter.tryInit(expectedInsertions, fpp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expectedInsertions; i++) &#123;</span><br><span class="line">        bloomFilter.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断误判比例</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">if</span> (bloomFilter.contains(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(i + <span class="string">"误判了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">"预期数据量：%s，误判数量：%s，预期误判率：%s，实际误判率：%s \n"</span>, expectedInsertions, count, fpp, count * <span class="number">1.0</span> / <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.out.printf(<span class="string">"执行时间：%s \n"</span>, <span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：Redisson 利用 Redis 实现了 Java 分布式布隆过滤器（Bloom Filter），通过 RedissonClient 初始化布隆过滤器，预计统计元素数量为 10000，期望误差率为 0.001。“预期数据量：10000，误判数量：51，预期误判率：0.001，实际误判率：0.00255 ”。我们看到了误判率大约 0.255%，比预计的 0.1% 高，不过布隆的概率是有误差的，只要不比预计误判率高太多，都是正常现象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在使用 Bloom Filter 时，绕不过的两点是预估数据量 n 以及期望的误判率 fpp，在实现 Bloom Filter 时，绕不过的两点就是 hash 函数的选取以及 bit 数组的大小。</p><p>期望的误判率越低，需要的空间越大。预估数据量，当实际数量超出这个数值时，误判率会上升。因此用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多导致误判率升高。</p><p>布隆过滤器的空间占用有一个简单的计算公式，但是推导比较繁琐，这里就省去推导过程了，感兴趣的读者可以点击「延伸阅读」深入理解公式的推导过程。虽然存在布隆过滤器的空间占用的计算公司，但是有很多现成的网站已经支持计算空间占用的功能了，我们只要把参数输进去，就可以直接看到结果，比如 <a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">布隆计算器</a>。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="noopener">布隆过滤器 (Bloom Filter) 详解</a>：详解布隆过滤器的相关算法和参数设计。</li><li><a href="https://zh.wikipedia.org/zh-hans/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">Murmur 哈希</a>：Murmur 哈希，于 2008 年被发明。这个算法 hbase、redis、kafka 都在使用。</li><li><a href="https://zh.wikipedia.org/zh-hans/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">Counting Bloom Filter</a>：要实现删除元素，可以采用 Counting Bloom Filter。它将标准布隆过滤器位图的每一位扩展为一个小的计数器 (Counter)，插入元素时将对应的 k 个 Counter 的值分别加 1，删除元素时则分别减 1。</li><li><a href="https://juejin.im/post/5cfb9c74e51d455d6d5357db" target="_blank" rel="noopener">布谷鸟过滤器</a>：为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://crossoverjie.top/2018/11/26/guava/guava-bloom-filter/" target="_blank" rel="noopener">如何判断一个元素在亿级数据中是否存在？</a><br>[2]. <a href="https://www.cnblogs.com/z941030/p/9218356.html" target="_blank" rel="noopener">大数据量下的集合过滤—Bloom Filter</a><br>[3]. <a href="https://my.oschina.net/LucasZhu/blog/1813110" target="_blank" rel="noopener">布隆过滤器 (Bloom Filter) 的原理、实现和探究</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 位图法：位图法就是 BitMap 的缩写，所谓 BitMap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</small><br><small>[2]. Redisson：<br>Redisson 在基于 NIO 的 Netty 框架上，充分的利用了 Redis 键值数据库提供的一系列优势，在 Java 实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</small></p><hr><h2 id="大话数据结构系列"><a href="#大话数据结构系列" class="headerlink" title="大话数据结构系列"></a>大话数据结构系列</h2><ul><li><a href="9c51d4e.html">大话数据结构（一）：那些年面试常见的 Java 排序算法</a></li><li><a href="6e0aae0d.html">大话数据结构（二）：大白话布隆过滤器 Bloom Filter</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;“一个网站有 20 亿 url 存在一个黑名单中，这个黑名单要怎么存？若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？并且需在给定内存空间（比如：500M）内快速判断出。” 这是一道经常在面试中出现的算法题。&lt;/p&gt;
&lt;p&gt;很多人脑海中首先想到的可能是 HashSet，因为 HashSet 的底层是采用 HashMap 实现的，理论上时间复杂度为：O(1)。达到了快速的目的，但是空间复杂度呢？URL 字符串通过 Hash 得到一个 Integer 的值，Integer 占 4 个字节，那 20 亿个 URL 理论上需要：4 字节 (byte) * 20 亿  =  80 亿 (byte)  ≈ 7.45G   的内存空间，不满足空间复杂度的要求。&lt;/p&gt;
&lt;p&gt;还有一种方法就是位图法&lt;sup&gt;[1]&lt;/sup&gt;，每个 URL 取整数哈希值，置于位图相应的位置上，看上去是可行的。但位图适合对海量的、取值分布很均匀的集合去重。位图法的所占空间随集合内最大元素的增大而增大，即空间复杂度随集合内最大元素增大而线性增大。要设计冲突率很低的哈希函数，势必要增加哈希值的取值范围，4G 的位图最大值是 320 亿左右，为 50 亿条 URL 设计冲突率很低、最大值为 320 亿的哈希函数比较困难。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。因此，出于性能和内存占用的考虑，在这里使用布隆过滤器才是最好的解决方案：布隆过滤器是对位图的一种改进。&lt;/p&gt;
&lt;p&gt;这里就引出本文要介绍的 “布隆过滤器”。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.maoning.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://blog.maoning.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序算法" scheme="http://blog.maoning.pro/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出集合框架（二）：为并发而生的 ConcurrentHashMap</title>
    <link href="http://blog.maoning.pro/archives/91027543.html"/>
    <id>http://blog.maoning.pro/archives/91027543.html</id>
    <published>2019-09-27T08:26:53.000Z</published>
    <updated>2019-11-20T11:16:39.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ConcurrentHashMap 从 JDK 1.5 开始随 java.util.concurrent 包一起引入 JDK 中，主要为了解决 HashMap 线程不安全和 Hashtable 效率不高的问题。</p><p>HashMap 是我们日常开发中最常见的一种容器，根据键值对键的哈希值来确定值对键在集合中的存储位置，因此具有良好的存取和查找功能。但众所周知，它在高并发的情境下是线程不安全的。尤其是在 JDK 1.8 之前，rehash 的过程中采用头插法转移结点，高并发下，多个线程同时操作一条链表将直接导致闭链，易出现逆序且环形链表死循环问题，导致死循环并占满 CPU。JDK 1.8 以来，对 HashMap 的内部进行了很大的改进，采用数组 + 链表 + 红黑树的形式来进行数据的存储。rehash 的过程也进行了改动，基于复制的算法思想，不直接操作原链，而是定义了两条链表分别完成对原链的结点分离操作，在多线程的环境下，采用了尾插法，扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致，所有即使是多线程的情况下也是安全的。JDK 1.8 中的 HashMap 虽然不会导致死循环，但是因为 HashMap 多线程下内存不共享的问题，两个线程同时指向一个 hash 桶数组时，会导致数据覆盖的问题，所以 HashMap 是依旧是线程不安全的。</p><p>HashTable 是线程安全的容器，它在所有涉及到多线程的操作都加上了 synchronized 关键字来锁住整个 table，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的，因此 Hashtable 已经是 Java 中的遗留容器，已经不推荐使用。</p><p>因此在多线程条件下，需要满足线程安全，我们可使用 Collections.synchronizedMap 方法构造出一个同步的 Map，使 HashMap 具有线程安全的能力；或者直接使用线程安全的 ConcurrentHashMap。本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 HashMap 很多。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>线程不安全的 HashMap</li></ul><p>由于 HashMap 是非线程安全的容器，遇到多线程操作同一容器的场景，可能会导致数据不一致： JDK 1.7 中 HashMap 采用了数组 + 链表的数据结构，有线程安全问题（统计不准确，丢失数据，环形链表死循环导致 Cpu 100%），JDK 1.8 中 HashMap 采用了数组 + 链表 + 红黑树的结构，有线程安全问题（统计不准确，丢失数据）。</p><ul><li>效率低下的 HashTable 容器</li></ul><p>HashTable 容器使用 synchronized 关键字来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下。因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><h2 id="JDK-1-7-基于分段锁的-ConcurrentHashMap"><a href="#JDK-1-7-基于分段锁的-ConcurrentHashMap" class="headerlink" title="JDK 1.7 基于分段锁的 ConcurrentHashMap"></a>JDK 1.7 基于分段锁的 ConcurrentHashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问 HashTable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的锁分段技术。JDK1.7 中的 ConcurrentHashMap 的底层数据结构是数组 + 链表。与 HashMap 不同的是，ConcurrentHashMap 最外层不是一个大的数组，而是一个 Segment 的数组。每个 Segment 包含一个与 HashMap 数据结构差不多的链表数组。</p><p>JDK 1.7 中 ConcurrentHashMap 采用 Segment 分段锁的数据结构，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如 size() 和 containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这种做法，就称之为“分离锁”（lock striping）<sup>[1]</sup> 。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素, 当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p><p><img src="/media/15640353314189/926638-20170809132445011-2033999443.png" alt="926638-20170809132445011-2033999443"></p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对不属于同一个片段的节点可以并发操作，大大提高了性能</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Segment</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互拆锁使用</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// count 用来统计该段数据的个数，它是 volatile，它用来协调修改和读取操作，以保证读取操作能够读取到几乎最新的修改。协调方式是这样的，每次修改操作做了结构上的改变，如增加 / 删除节点(修改节点的值不算结构上的改变)，都要写 count 值，每次读取操作开始都要读取 count 的值。这利用了 Java 5 中对 volatile 语义的增强，对同一个 volatile 变量的写和读存在 happens-before 关系。</span></span><br><span class="line">transient volatileint count;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// modCount 统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变</span></span><br><span class="line">        transient int modCount;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// threashold 用来表示需要进行 rehash 的界限值</span></span><br><span class="line">        transient int threshold;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// table 数组存储段中节点，每个数组元素是个 hash 链，用 HashEntry 表示。table 也是 volatile，这使得能够读取到最新的 table 值而不需要同步</span></span><br><span class="line">        transient volatile <span class="type">HashEntry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] table;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// loadFactor 表示负载因子。</span></span><br><span class="line">        <span class="keyword">final</span> float loadFactor;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本节点，存储 Key，value 值，可以看到除了 value 不是 final 的，其它值都是 final 的，这意味着不能从 hash 链的中间或尾部添加或删除节点，因为这需要修改 next 引用值，所有的节点的修改只能从头部开始。对于 put 操作，可以一律添加到 Hash 链的头部。但是对于 remove 操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。为了确保读操作能够看到最新的值，将 value 设置成 volatile，这避免了加锁。</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> value;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">HashEntry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>它把区间按照并发级别（concurrentLevel），分成了若干个 segment。默认情况下内部按并发级别为 16 来创建。对于每个 segment 的容量，默认情况也是 16。concurrentLevel，segment 可以通过构造函数设定的。通过按位与的哈希算法来定位 segments 数组的索引，必须保证 segments 数组的长度是 2 的 N 次方（power-of-two size），所以必须计算出一个是大于或等于 concurrencyLevel 的最小的 2 的 N 次方值来作为 segments 数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 并发级别数大于最大Segment数量</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K, V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K, V&gt;(loadFactor, (<span class="keyword">int</span>) (cap * loadFactor),</span><br><span class="line">                    (HashEntry&lt;K, V&gt;[]) <span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K, V&gt;[] ss = (Segment&lt;K, V&gt;[]) <span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/15640353314189/f7e40dd35ad859e5cafbfd091341e14e061.jpg" alt="f7e40dd35ad859e5cafbfd091341e14e061"></p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>对于读操作，通过 Key 哈希值的高 N 位对 Segment 个数取模从而得到该 Key 应该属于哪个 Segment，接着如同操作 HashMap 一样操作这个 Segment。Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该键值对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该 Segment 的安全性。为了保证不同的值均匀分布到不同的 Segment，需要通过如下方法计算哈希值。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">private</span> int hash(Object k) &#123;</span><br><span class="line">  <span class="attribute">int</span> h = hashSeed;</span><br><span class="line">  <span class="attribute">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k instanceof String)) &#123;</span><br><span class="line">    <span class="attribute">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> k.hashCode();</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;  <span class="number">15</span>)<span class="regexp"> ^</span> 0xffffcd7d;</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">  <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。</p><p>对于读操作，获取 Key 所在的 Segment 时，需要保证可见性。具体实现上可以使用 volatile 关键字，也可使用锁。但使用锁开销太大，而使用 volatile 时每次写操作都会让所有 CPU 内缓存无效，也有一定开销。ConcurrentHashMap 使用如下方法保证可见性，取得最新的 Segment。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K, V&gt; <span class="title">segmentForHash</span>(<span class="params"><span class="keyword">int</span> h</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">return</span> (Segment&lt;K, V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该 Key-Value 对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该 Segment 的安全性。<br>同时由于其它 Segment 的锁并未被获取，因此理论上可支持 concurrencyLevel（等于 Segment 的个数）个线程安全的并发读写。</p><p>获取锁时，并不直接使用 lock 来获取，因为该方法获取锁失败时会挂起（参考可重入锁）。事实上，它使用了自旋锁，如果 tryLock 获取锁失败，说明锁被其它线程占用，此时通过循环再次以 tryLock 的方式申请锁。如果在循环过程中该 Key 所对应的链表头被修改，则重置 retry 次数。如果 retry 次数超过一定值，则使用 lock 方法申请锁。</p><p>这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗 CPU 资源比较多，因此在自旋次数超过阈值时切换为互斥锁。</p><h3 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h3><p>put、remove 和 get 操作只需要关心一个 Segment，而 size 操作需要遍历所有的 Segment 才能算出整个 Map 的大小。一个简单的方案是，先锁住所有 Sgment，计算完后再解锁。但这样做，在做 size 操作时，不仅无法对 Map 进行写操作，同时也无法进行读操作，不利于对 Map 的并行操作。</p><p>为更好支持并发操作，ConcurrentHashMap 会在不上锁的前提逐个 Segment 计算 3 次 size，如果某相邻两次计算获取的所有 Segment 的更新次数（每个 Segment 都与 HashMap 一样通过 modCount 跟踪自己的修改次数，Segment 每修改一次其 modCount 加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总 size 相等，可直接作为最终结果返回。如果这三次计算过程中 Map 有更新，则对所有 Segment 加锁重新计算 Size。该计算方法代码如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size() &#123;</span><br><span class="line">  <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">sum</span>;         <span class="comment">// sum of modCounts</span></span><br><span class="line">  <span class="keyword">long</span> last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">  <span class="keyword">int</span> retries = <span class="number">-1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">          ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">sum</span> = <span class="number">0</span>L;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      overflow = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">sum</span> += seg.modCount;</span><br><span class="line">          <span class="keyword">int</span> c = seg.<span class="keyword">count</span>;</span><br><span class="line">          <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sum</span> == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      last = <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">        segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-8-基于-CAS-的-ConcurrentHashMap"><a href="#Java-8-基于-CAS-的-ConcurrentHashMap" class="headerlink" title="Java 8 基于 CAS 的 ConcurrentHashMap"></a>Java 8 基于 CAS 的 ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>JDK 1.7 中 ConcurrentHashMap 为实现并行访问，引入了 Segment 这一结构，实现了分段锁，理论上最大并发度与 Segment 个数相等。JDK 1.8 中 ConcurrentHashMap 为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。</p><p>JDK 1.8 中 ConcurrentHashMap 参考了 JDK 1.8  HashMap 的实现，采用了数组 + 链表 + 红黑树的实现方式进行数据存储，提高哈希碰撞下的寻址性能，在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）；进一步提高并发性，取消了基于 Segment 的分段锁思想，改用 CAS<sup>[2]</sup> + synchronized 控制并发操作，在某些方面提升了性能。对于读操作，通过 Key 的哈希值与数组长度取模确定该 Key 在数组中的索引。对于写操作，如果 Key 对应的数组元素为 null，则通过 CAS 操作将其设置为当前值。如果 Key 对应的数组元素不为 null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。</p><p><img src="/media/15640353314189/926638-20170809132741792-1171090777.png" alt="926638-20170809132741792-1171090777"></p><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p><strong><u>Node</u></strong> ：Node 是最核心的内部类，它包装了 key-value 键值对，所有插入 ConcurrentHashMap 的数据都包装在这里面。它与 HashMap 中的定义很相似，但是但是有一些差别它对 value 和 next 属性设置了 volatile 同步锁，它不允许调用 setValue 方法直接改变 Node 的 value 域，它增加了 find 方法辅助 map.get() 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">K,V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="type">K,V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> int hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 带有同步锁的 value[value 和 next 都会在扩容时发生变化，所以加上 volatile 来保持可见性和禁止重排序]</span></span><br><span class="line">    <span class="keyword">volatile</span> V <span class="keyword">val</span>;</span><br><span class="line">    <span class="comment">// 带有同步锁的 next 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> ConcurrentHashMap.Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V <span class="keyword">val</span>, ConcurrentHashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey()       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue()     &#123; <span class="keyword">return</span> <span class="keyword">val</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int hashCode()   &#123; <span class="keyword">return</span> key.hashCode() ^ <span class="keyword">val</span>.hashCode(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String toString()&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + <span class="keyword">val</span>; &#125;</span><br><span class="line">    <span class="comment">// 不允许直接改变 value 的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> boolean equals(Object o) &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = <span class="keyword">val</span>) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConcurrentHashMap.Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><u>TreeNode</u></strong>：树节点类，当链表长度过长的时候，会转换为 TreeNode。但是与 HashMap 不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成 TreeNode 放在 TreeBin 对象中，由 TreeBin 完成对红黑树的包装。而且 TreeNode 在 ConcurrentHashMap 集成自 Node 类，而并非 HashMap 中的集成自 LinkedHashMap.Entry&lt;K,V&gt; 类，也就是说 TreeNode 带有 next 指针，这样做的目的是方便基于 TreeBin 的访问。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">ConcurrentHashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line"><span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 存储当前节点的左孩子</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="comment">// 存储当前节点的右孩子</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="comment">// 存储当前节点的前一个节点</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">ConcurrentHashMap</span>.<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; find(int h, <span class="type">Object</span> k) &#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">     * starting at given root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; findTreeNode(int h, <span class="type">Object</span> k, <span class="type">Class</span>&lt;?&gt; kc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            do  &#123;</span><br><span class="line">                int ph, dir; <span class="type">K</span> pk; <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; q;</span><br><span class="line">                <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                        (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p>concurrencyLevel，能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数，在 JDK 1.8  之前实际上就是 ConcurrentHashMap 中的分段锁个数，即 Segment[] 的数组长度。在 JDK 1.8 里，仅仅是为了兼容旧版本而保留，唯一的作用就是保证构造 map 时初始容量不小于 concurrencyLevel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node 数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是 2 的幕数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 数组可能最大值，需要与 toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值 &gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 树转链表阀值，小于等于 6（tranfer 时，lc、hc=0 两个计数器分别 ++ 记录原 bin、新 binTreeNode 数量，&lt;=UNTREEIFY_THRESHOLD 则 untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize 的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl 中记录 size 大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes 的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 树根节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// ReservationNode 的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = <span class="keyword">Runtime</span>.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 存放 node 的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"><span class="comment">/* 控制标识符，用来控制 table 的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> * 当为负数时：-1 代表正在初始化，-N 代表有 N-1 个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> * 当为 0 时：代表当时的 table 还没有被初始化</span></span><br><span class="line"><span class="comment"> * 当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>JDK 1.8 的 ConcurrentHashMap 同样是通过 Key 的哈希值与数组长度取模确定该 Key 在数组中的索引。同样为了避免不太好的 Key 的 hashCode 设计，它通过如下方法计算得到 Key 的最终哈希值。不同的是，JDK 1.8 的 ConcurrentHashMap 作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将 Key 的 hashCode 值与其高 16 位作异或并保证最高位为 0（从而保证最终结果为正整数）。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步方式-1"><a href="#同步方式-1" class="headerlink" title="同步方式"></a>同步方式</h3><p>对于写操作，如果 Key 对应的数组元素为 null，则通过 CAS 操作将其设置为当前值。如果 Key 对应的数组元素（也即链表表头或者树的根元素）不为 null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p><p>对于读操作，由于数组被 volatile 关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个 Node 实例（Java 7 中每个元素是一个 HashEntry），它的 Key 值和 hash 值都由 final 修饰，不可变更，无须关心它们被修改后的可见性问题。而其 Value 及对下一个元素的引用由 volatile 修饰，可见性也有保障。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Key 对应的数组元素的可见性，由 Unsafe 的 getObjectVolatile 方法保证。它是对 tab[i] 进行原子性的读取，因为我们知道 putVal 等对 table 的桶操作是有加锁的，那么一般情况下我们对桶的读也是要加锁的，但是我们这边为什么不需要加锁呢？因为我们用了 Unsafe<sup>[3]</sup> 的 getObjectVolatile，因为 table 是 volatile 类型，所以对 tab[i] 的原子请求也是可见的。因为如果同步正确的情况下，根据 happens-before 原则，对 volatile 域的写入操作 happens-before 于每一个后续对同一域的读操作。所以不管其他线程对 table 链表或树的修改，都对 get 读取可见。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组中位置i上的节点</span><br><span class="line">static final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</span><br><span class="line">  return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="size-操作-1"><a href="#size-操作-1" class="headerlink" title="size 操作"></a>size 操作</h3><p>put 方法和 remove 方法都会通过 addCount 方法维护 Map 的 size。size 方法通过 sumCount 获取由 addCount 方法维护的 Map 的 size。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 变化的数量</span></span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析-ConcurrentHashMap"><a href="#源码分析-ConcurrentHashMap" class="headerlink" title="源码分析 ConcurrentHashMap"></a>源码分析 ConcurrentHashMap</h2><h3 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable()方法"></a>initTable()方法</h3><p>该方法的核心思想就是，只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度。这样，保证了表同时只会被一个线程初始化。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="comment">// 如果表为空才进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl 小于零说明已经有线程正在进行初始化操作，当前线程应该放弃 CPU 的使用</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 否则说明还未有线程对表进行初始化，那么本线程就来做这个工作，CAS 方法把 sizectl 置为-1，表示本线程正在进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            <span class="comment">// 保险起见，再次判断下表是否为空</span></span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    <span class="comment">// sc 大于零说明容量已经初始化了，否则使用默认容量 16</span></span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 根据容量构建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="comment">// 计算阈值，等效于 n*0.75</span></span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="comment">// 设置阈值</span></span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h3><p>get 方法比较简单，给定一个 key 来确定 value 的时候，必须满足两个条件 key 相同 、hash 值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V <span class="built_in">get</span>(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="built_in">tab</span>; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    int h = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    <span class="comment">// 根据 hash 值确定节点位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, (n - <span class="number">1</span>) &amp; h)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果搜索到的节点 key 与传入的 key 相同且不为 null, 直接返回这个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 eh&lt;0 说明这个节点在树上，调用树的 find 方法寻找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="built_in">null</span> ? p.val : <span class="built_in">null</span>;</span><br><span class="line">        <span class="comment">// 否则遍历链表 找到对应的值并返回</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的 get 操作的流程很简单，可以分为三个步骤来描述：</p><ul><li>计算 hash 值，定位到该 table 索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点 ForwardingNode 的 find 方法，查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回 null</li></ul><h3 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value)方法"></a>put(K key, V value)方法</h3><p>假设 table 已经初始化完成，put 操作采用 CAS+synchronized 实现并发插入或更新操作，具体实现如下。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public V <span class="built_in">put</span>(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">putVal</span>(<span class="built_in">key</span>, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation for put and putIfAbsent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">final V <span class="built_in">putVal</span>(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">// 不允许 key 或 value 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> <span class="built_in">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算 hash 值，两次 hash，减少 hash 冲突，可以均匀分布</span></span><br><span class="line">    int hash = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环 何时插入成功 何时跳出；因为如果其他线程正在修改 tab，那么尝试就会失败，所以这边要加一个 for 循环，不断的尝试</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] <span class="built_in">tab</span> = table; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        int n, i, fh;</span><br><span class="line">        <span class="comment">// 如果 table 为空的话，初始化 table，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="built_in">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = <span class="built_in">initTable</span>();</span><br><span class="line">        <span class="comment">// 根据 hash 值计算出在 table 里面的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个位置没有值，通过 CAS 操作将其设置为当前值，不需要加锁</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">casTabAt</span>(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                    new Node&lt;K, V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">        <span class="comment">// 由于检测到当前哈希表正在扩容，于是让当前线程去协助扩容</span></span><br><span class="line">            tab = <span class="built_in">helpTransfer</span>(<span class="built_in">tab</span>, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">// 这个地方设计非常的巧妙，内置锁 synchronized 锁住了 f,因为 f 是指定特定的tab[i]的；结点上锁，这里的结点可以理解为 hash 值相同组成的链表的头结点</span></span><br><span class="line">            <span class="built_in">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// fh &gt;= 0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 在这里遍历链表所有的结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果 hash 值和 key 值相同  则修改对应结点的 value 值[put 操作和 putIfAbsent 操作业务实现]</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == <span class="built_in">key</span> ||</span><br><span class="line">                                            (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 如果遍历到了最后一个结点，那么就证明新的节点需要插入，使用尾插法把它插入在链表尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                        value, <span class="built_in">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).<span class="built_in">putTreeVal</span>(hash, <span class="built_in">key</span>,</span><br><span class="line">                                value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度已经达到临界值 8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                <span class="comment">// 转化为红黑树</span></span><br><span class="line">                    <span class="built_in">treeifyBin</span>(<span class="built_in">tab</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前 ConcurrentHashMap 的元素数量 + 1，CAS 式更新 baseCount，并判断是否需要扩容</span></span><br><span class="line">    <span class="built_in">addCount</span>(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的 put 操作的流程就是对当前的 table 进行无条件自循环直到 put 成功，可以分成以下七步流程来概述：</p><ul><li>如果为 null 直接抛空指针异常</li><li>如果没有初始化就先调用 initTable() 方法来进行初始化过程</li><li>如果没有 hash 冲突就直接 casTabAt() 无锁插入</li><li>如果还在进行扩容操作就 helpTransfer() 帮助其扩容</li><li>如果存在 hash 冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li><li>如果该链表的数量大于阈值 8，就要先treeifyBin()转换成黑红树的结构[若table length &lt; 64，直接 tryPresize，两倍table.length，不转树]，break 跳出循环</li><li>如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ConcurrentHashMap-与-HashMap-的区别"><a href="#ConcurrentHashMap-与-HashMap-的区别" class="headerlink" title="ConcurrentHashMap 与 HashMap 的区别"></a>ConcurrentHashMap 与 HashMap 的区别</h3><ul><li><strong>线程安全性不同</strong>：ConcurrentHashMap 线程安全，而 HashMap 非线程安全</li><li><strong>key 和 value 是否允许 null 值</strong>：HashMap 允许 Key 和 Value 为 null，而 ConcurrentHashMap 不允许 Key 和 Value 为 null</li><li><strong>是否允许遍历时修改集合</strong>：HashMap 不允许通过 Iterator 遍历的同时通过 HashMap 修改，而 ConcurrentHashMap 允许该行为，并且该更新对后续的遍历可见。</li></ul><h3 id="JDK-1-7-中-ConcurrentHashMap-和-JDK-1-8-中-ConcurrentHashMap-的实现区別？"><a href="#JDK-1-7-中-ConcurrentHashMap-和-JDK-1-8-中-ConcurrentHashMap-的实现区別？" class="headerlink" title="JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別？"></a>JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別？</h3><p>其实可以看出 JDK 1.8 版本的 ConcurrentHashMap 的数据结构已经接近 HashMap，相对而言，ConcurrentHashMap 只是增加了同步的操作来控制并发，从 JDK 1.7 版本的 ReentrantLock + Segment + HashEntry，到 JDK 1.8 版本中 synchronized + CAS + HashEntry + 红黑树，相对而言，JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別总结如下：</p><ul><li><strong>底层数据结构不同</strong>：JDK 1.7 中 ConcurrentHashMap 采用 Segment 分段锁的数据结构，JDK 1.8 中 ConcurrentHashMap 采用数组 + 链表 + 红黑树的数据结构。</li><li><strong>保证线程安全机制不同</strong>：JDK 1.7 中 ConcurrentHashMap 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK 1.8 中 ConcurrentHashMap 采用 CAS+Synchronized 机制实现线程安全。</li><li><strong>锁的粒度不同</strong>：JDK 1.7 中 ConcurrentHashMap 是对需要进行数据操作的 Segment 加锁，JDK 1.8 中 ConcurrentHashMap 是对每个数组元素加锁（Node）。</li><li><strong>查询的时间复杂度不同</strong>：定位结点的 hash 算法简化会带来弊端，Hash 冲突加剧，因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。查询元素的时间复杂度从原来的遍历链表 O(n)，变成遍历红黑树 O(logN)。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener">Java 进阶（六）从 ConcurrentHashMap 的演进看 Java 多线程核心技术</a><br>[2]. <a href="https://www.cnblogs.com/study-everyday/p/6430462.html" target="_blank" rel="noopener">ConcurrentHashMap 原理分析（1.7 与 1.8）</a><br>[3]. <a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a>    </p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 分离锁（lock striping）：分拆锁 (lock spliting) 就是若原先的程序中多处逻辑都采用同一个锁，但各个逻辑之间又相互独立，就可以拆 (Spliting) 为使用多个锁，每个锁守护不同的逻辑。分拆锁有时候可以被扩展，分成可大可小加锁块的集合，并且它们归属于相互独立的对象，这样的情况就是分离锁(lock striping)。（摘自《Java 并发编程实践》）</small></p><p><small>[2]. CAS：CAS 是 compare and swap 的缩写，即我们所说的比较并替换，是用于实现多线程同步的原子指令。CAS 是一种基于锁的操作，是乐观锁。<br>在 Java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，线程一旦得到锁，会导致其它所有需要锁的线程挂起，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。CAS 操作包含三个基本操作数 —— 内存位置（V）、预期原值（A）和新值 (B)。更新一个变量的时候，只有当变量的预期原值（A）和内存位置（V）当中的实际值相同时，才会将内存位置（V）对应的值修改为新值 (B)。CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。CAS 可以有效的提升并发的效率，但同时也会引入 ABA 问题。如线程 1 从内存位置（V）中取出预期原值（A），这时候另一个线程 2 也从内存位置（V）中取出预期原值（A），并且线程 2 进行了一些操作将内存位置（V）中的值变成了新值 (B)，然后线程 2 又将内存位置（V）中的数据变成预期原值（A），这时候线程 1 进行 CAS 操作发现内存位置（V）中仍然是预期原值（A），然后线程 1 操作成功。虽然线程 1 的 CAS 操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。解决方式，在对象中额外再增加一个标记来标识对象是否有过变更【AtomicMarkableReference(通过引入一个 boolean 来反映中间有没有变过)、AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）】。</small></p><p><small>[3]. Unsafe：Unsafe 是 Java 留给开发者的后门，用于直接操作系统内存且不受 Jvm 管辖，实现类似 C++ 风格的操作。Java 不能直接访问操作系统底层，而是通过本地方法来访问，Unsafe 类提供了硬件级别的原子操作。Oracle 官方一般不建议开发者使用 Unsafe 类，因为正如这个类的类名一样，它并不安全，使用不当会造成内存泄露。Unsafe 类在 sun.misc 包下，不属于 Java 标准。很多 Java 的基础类库，包括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发，比如 Netty、Hadoop、Kafka 等。</small></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ConcurrentHashMap 从 JDK 1.5 开始随 java.util.concurrent 包一起引入 JDK 中，主要为了解决 HashMap 线程不安全和 Hashtable 效率不高的问题。&lt;/p&gt;
&lt;p&gt;HashMap 是我们日常开发中最常见的一种容器，根据键值对键的哈希值来确定值对键在集合中的存储位置，因此具有良好的存取和查找功能。但众所周知，它在高并发的情境下是线程不安全的。尤其是在 JDK 1.8 之前，rehash 的过程中采用头插法转移结点，高并发下，多个线程同时操作一条链表将直接导致闭链，易出现逆序且环形链表死循环问题，导致死循环并占满 CPU。JDK 1.8 以来，对 HashMap 的内部进行了很大的改进，采用数组 + 链表 + 红黑树的形式来进行数据的存储。rehash 的过程也进行了改动，基于复制的算法思想，不直接操作原链，而是定义了两条链表分别完成对原链的结点分离操作，在多线程的环境下，采用了尾插法，扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致，所有即使是多线程的情况下也是安全的。JDK 1.8 中的 HashMap 虽然不会导致死循环，但是因为 HashMap 多线程下内存不共享的问题，两个线程同时指向一个 hash 桶数组时，会导致数据覆盖的问题，所以 HashMap 是依旧是线程不安全的。&lt;/p&gt;
&lt;p&gt;HashTable 是线程安全的容器，它在所有涉及到多线程的操作都加上了 synchronized 关键字来锁住整个 table，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的，因此 Hashtable 已经是 Java 中的遗留容器，已经不推荐使用。&lt;/p&gt;
&lt;p&gt;因此在多线程条件下，需要满足线程安全，我们可使用 Collections.synchronizedMap 方法构造出一个同步的 Map，使 HashMap 具有线程安全的能力；或者直接使用线程安全的 ConcurrentHashMap。本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 HashMap 很多。&lt;/p&gt;
    
    </summary>
    
      <category term="集合" scheme="http://blog.maoning.pro/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java8" scheme="http://blog.maoning.pro/tags/Java8/"/>
    
      <category term="集合" scheme="http://blog.maoning.pro/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="Java7" scheme="http://blog.maoning.pro/tags/Java7/"/>
    
      <category term="ConcurrentHashMap" scheme="http://blog.maoning.pro/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java8 那些事儿（五）：函数式接口</title>
    <link href="http://blog.maoning.pro/archives/43810ae.html"/>
    <id>http://blog.maoning.pro/archives/43810ae.html</id>
    <published>2019-09-10T10:50:05.000Z</published>
    <updated>2019-10-15T03:13:03.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式接口 (Functional Interface) 就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Java 允许利用 Lambda 表达式创建这些接口的实例。java.util.function 包是 Java 8 增加的一个新技术点 “函数式接口”，此包共有 43 个接口。别指望能够全部记住他们，但是如果能记住其中 6 个基础接口，必要时就可以推断出其余接口了。这些接口是为了使 Lamdba 函数表达式使用的更加简便，当然你也可以自己自定义接口来应用于 Lambda 函数表达式。</p><p>JDK 1.8 API 包含了很多内建的函数式接口，比如 Comparator 或者 Runnable 接口，这些接口都增加了 @FunctionalInterface 注解以便能用在 Lamdba 上。现如今，我们则从 Function 常用函数入口，真正了解一下函数式接口。</p><a id="more"></a><h2 id="Java-8-中函数式接口"><a href="#Java-8-中函数式接口" class="headerlink" title="Java 8 中函数式接口"></a>Java 8 中函数式接口</h2><table><thead><tr><th>接口</th><th>描述</th><th>函数签名</th><th>范例</th></tr></thead><tbody><tr><td>UnaryOperator&lt;T></td><td>接收 T 对象，返回 T 对象</td><td>T apply(T t)</td><td>String::toLowerCase</td></tr><tr><td>BinaryOprator&lt;T></td><td>接收两个 T 对象，返回 T 对象</td><td>T apply(T t1, T t2)</td><td>BigInteger::add</td></tr><tr><td>Predicate&lt;T></td><td>接收 T 对象，返回 boolean</td><td>boolean test(T t)</td><td>Collection::isEmpty</td></tr><tr><td>Function&lt;T, R&gt;</td><td>接收 T 对象，返回 R 对象</td><td>R apply(T t)</td><td>Arrays::asList</td></tr><tr><td>Supplier&lt;T></td><td>提供 T 对象（例如工厂），不接收值</td><td>T get()</td><td>Instant::new</td></tr><tr><td>Consumer&lt;T></td><td>接收 T 对象，不返回值</td><td>void accept(T t)</td><td>System.out::println</td></tr></tbody></table><p>标注为 @FunctionalInterface 的接口被称为函数式接口，该接口有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。是否是一个函数式接口，需要注意的有以下几点：</p><ul><li>该注解只能标记在“有且仅有一个抽象方法”的接口上。</li><li>Java 8 接口中的静态方法和默认方法，都不算是抽象方法。</li><li>接口默认继承 java.lang.Object，所以如果接口显示声明覆盖了 Object 中方法，那么也不算抽象方法。</li><li>该注解不是必须的，如果一个接口符合 “函数式接口” 定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错。</li><li>在一个接口中定义两个自定义的方法，就会产生 Invalid ‘@FunctionalInterface’ annotation; FunctionalInterfaceTest is not a functional interface 错误。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer：消费型接口（void-accept-T-t-）"><a href="#Consumer：消费型接口（void-accept-T-t-）" class="headerlink" title="Consumer：消费型接口（void accept(T t)）"></a>Consumer：消费型接口（void accept(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Consumer&lt;T></td><td>提供一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>BiConsumer&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，不返回执行结果</td></tr><tr><td>DoubleConsumer</td><td>提供一个 double 类型的输入参数，不返回执行结果</td></tr><tr><td>IntConsumer</td><td>提供一个 int 类型的输入参数，不返回执行结果</td></tr><tr><td>LongConsumer</td><td>提供一个 long 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjDoubleConsumer&lt;T></td><td>提供一个 double 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjIntConsumer&lt;T></td><td>提供一个 int 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjLongConsumer&lt;T></td><td>提供一个 long 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr></tbody></table><p>（1）作用：消费某个对象</p><p>（2）使用场景：Iterable 接口的 forEach 方法需要传入 Consumer，大部分集合类都实现了该接口，用于返回 Iterator 对象进行迭代。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void  accept(T t)</td><td>对给定的参数执行操作</td></tr><tr><td>default  Consumer&lt;T>  andThen(Consumer&lt; ? super T&gt; after)</td><td>返回一个组合函数，after 将会在该函数执行之后应用</td></tr></tbody></table><p>（4）代码示例</p><p>Consumer&lt;T>：提供一个 T 类型的输入参数，不返回执行结果</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testConsumer() &#123;</span><br><span class="line">    <span class="comment">// Consumer&lt;T&gt;:accept(T t)</span></span><br><span class="line">    Consumer&lt;<span class="keyword">String</span>&gt; consumer = System.out::<span class="built_in">println</span>;</span><br><span class="line">    consumer.accept(<span class="string">"hello world!"</span>);    <span class="comment">// hello world!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consumer&lt;T&gt;:andThen(Consumer&lt;? super T&gt; after) -&gt; 返回一个组合函数，after将会在该函数执行之后应用</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello "</span>);</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer_accept = (<span class="built_in">str</span>) -&gt; <span class="built_in">str</span>.<span class="built_in">append</span>(<span class="string">"Jack! "</span>);</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer_andThen = (<span class="built_in">str</span>) -&gt; <span class="built_in">str</span>.<span class="built_in">append</span>(<span class="string">"Bob!"</span>);</span><br><span class="line">    consumer_accept.andThen(consumer_andThen).accept(sb);</span><br><span class="line">    System.out.<span class="built_in">println</span>(sb.toString());  <span class="comment">// Hello Jack! Bob!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BiConsumer&lt;T, U&gt; ：提供两个自定义类型的输入参数，不返回执行结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> testBiConsumer() &#123;</span><br><span class="line">    <span class="comment">// BiConsumer&lt;T, U&gt;:accept(T t, U u)</span></span><br><span class="line">    BiConsumer&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; biConsumer = (a, b) -&gt; System.out.printf(<span class="string">"%s %s!"</span>, a, b);</span><br><span class="line">    biConsumer.accept(<span class="string">"hello"</span>, <span class="string">"world"</span>);    <span class="comment">// hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DoubleConsumer ：提供一个 double 类型的输入参数，不返回执行结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testDoubleConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DoubleConsumer:accept(double value)</span></span><br><span class="line">    DoubleConsumer doubleConsumer = System.out::println;</span><br><span class="line">    doubleConsumer.accept(<span class="number">9.12</span>D);   <span class="comment">// 9.12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjDoubleConsumer&lt;T> ： 提供一个 double 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjDoubleConsumer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ObjDoubleConsumer&lt;T&gt;:accept(T t, double value)</span></span><br><span class="line">    ObjDoubleConsumer&lt;String&gt; stringObjDoubleConsumer = (s, <span class="keyword">value</span>) -&gt; System.<span class="keyword">out</span>.println(s + <span class="keyword">value</span>);</span><br><span class="line">    stringObjDoubleConsumer.accept(<span class="string">"金额："</span>, <span class="number">9.12</span>D);   <span class="comment">// 金额：9.12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate：断言型接口（boolean-test-T-t-）"><a href="#Predicate：断言型接口（boolean-test-T-t-）" class="headerlink" title="Predicate：断言型接口（boolean test(T t)）"></a>Predicate：断言型接口（boolean test(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Predicate&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>DoublePredicate</td><td>提供一个 double 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>IntPredicate</td><td>提供一个 int 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>LongPredicate</td><td>提供一个 long 类型的输入参数，返回一个 boolean 类型的结果</td></tr></tbody></table><p>（1）作用：判断对象是否符合某个条件</p><p>（2）使用场景：ArrayList 的 removeIf(Predicate)：删除符合条件的元素。如果条件硬编码在 ArrayList 中，它将提供无数的实现，但是如果让调用者传入条件，这样 ArrayList 就可以从复杂和无法猜测的业务中解放出来。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean  test(T t)</td><td>根据给定的参数进行判断</td></tr><tr><td>Predicate&lt;T>  and(Predicate&lt; ? super T&gt; other)</td><td>返回一个组合判断，将 other 以短路并且的方式加入到函数的判断中</td></tr><tr><td>Predicate&lt;T>  or(Predicate&lt; ? super T&gt; other)</td><td>返回一个组合判断，将 other 以短路或的方式加入到函数的判断中</td></tr><tr><td>Predicate&lt;T>  negate()</td><td>将函数的判断取反</td></tr></tbody></table><p>（4）代码示例</p><p>Predicate&lt;T> ： 提供一个 T 类型的输入参数，返回一个 boolean 类型的结果</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPredicate() &#123;</span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:boolean test(T t)</span></span><br><span class="line">    Predicate&lt;List&lt;String&gt;&gt; listPredicate = Collection::isEmpty;</span><br><span class="line">    <span class="keyword">System</span>.out.println(listPredicate.test(Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"World"</span>))); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:boolean test(T t)</span></span><br><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; predicate = <span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)</span></span><br><span class="line">    predicate = predicate.<span class="keyword">and</span>(<span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> &gt;= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)</span></span><br><span class="line">    predicate = predicate.<span class="keyword">or</span>(<span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> != <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; negate()</span></span><br><span class="line">    predicate = predicate.negate();</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function：函数型接口（R-apply-T-t-）"><a href="#Function：函数型接口（R-apply-T-t-）" class="headerlink" title="Function：函数型接口（R apply(T t)）"></a>Function：函数型接口（R apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Function&lt;T, R&gt;</td><td>提供一个 T 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>提供两个自定义类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>DoubleFunction&lt;R></td><td>提供一个 double 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>DoubleToIntFunction</td><td>提供一个 double 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>DoubleToLongFunction</td><td>提供一个 double 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>IntFunction&lt;R></td><td>提供一个 int 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>IntToDoubleFunction</td><td>提供一个 int 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntToLongFunction</td><td>提供一个 int 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>LongFunction&lt;R></td><td>提供一个 long 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>LongToDoubleFunction</td><td>提供一个 long 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>LongToIntFunction</td><td>提供一个 long 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToDoubleBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>ToDoubleFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>ToIntBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToIntFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToLongBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>ToLongFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：实现一个”一元函数“，即传入一个值经过函数的计算返回另一个值。</p><p>（2）使用场景：V HashMap.computeIfAbsent(K , Function&lt;K, V&gt;)：如果指定的 key 不存在或相关的 value 为 null 时，设置 key 与关联一个计算出的非 null 值，计算出的值为 null 的话什么也不做(不会去删除相应的 key)。如果 key 存在并且对应 value 不为 null 的话什么也不做。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>R  apply(T t)</td><td>将此参数应用到函数中</td></tr><tr><td>Function&lt;T, V&gt; andThen(Function&lt; ? super R, ? extends V&gt; after)</td><td>返回一个组合函数，该函数结果应用到 after 函数中</td></tr><tr><td>Function&lt;V, R&gt; compose(Function&lt; ? super V, ? extends T&gt; before)</td><td>返回一个组合函数，首先将入参应用到 before 函数，再将 before 函数结果应用到该函数中</td></tr></tbody></table><p>（4）代码示例</p><p>Function&lt;T, R&gt; ： 提供一个 T 类型的输入参数，返回一个 R 类型的结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> testFunction() &#123;</span><br><span class="line">    <span class="comment">// Function&lt;T, R&gt;:R apply(T t)</span></span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>[], List&lt;<span class="built_in">String</span>&gt;&gt; asList = Arrays::asList;</span><br><span class="line">    System.out.println(asList.apply(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"Hello"</span>, <span class="string">"World"</span>&#125;));   <span class="comment">// [Hello, World]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="function"><span class="keyword">function</span> = <span class="title">s</span> -&gt; <span class="title">String</span>.<span class="title">format</span>(<span class="params">"%s, Jack!", s</span>)</span>;</span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; compose = s -&gt; StringUtils.isEmpty(s) ? <span class="string">"Hello"</span> : s;</span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; andThen = <span class="built_in">String</span>::toUpperCase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> s = <span class="function"><span class="keyword">function</span>.<span class="title">compose</span>(<span class="params">compose</span>).<span class="title">andThen</span>(<span class="params">andThen</span>).<span class="title">apply</span>(<span class="params">""</span>)</span>;</span><br><span class="line">    System.out.println(s);  <span class="comment">// HELLO, JACK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Supplier：供给型接口（R-apply-T-t-）"><a href="#Supplier：供给型接口（R-apply-T-t-）" class="headerlink" title="Supplier：供给型接口（R apply(T t)）"></a>Supplier：供给型接口（R apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Supplier&lt;T></td><td>不提供输入参数，返回一个 T 类型的结果</td></tr><tr><td>BooleanSupplier</td><td>不提供输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>DoubleSupplier</td><td>不提供输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntSupplier</td><td>不提供输入参数，返回一个 int 类型的结果</td></tr><tr><td>LongSupplier</td><td>不提供输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：创建一个对象（工厂类）</p><p>（2）使用场景：Optional.orElseGet(Supplier&lt; ? extends T&gt;)：当 this 对象为 null，就通过传入 supplier 创建一个 T 返回。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>T  get()</td><td>获取结果值</td></tr></tbody></table><p>（4）代码示例</p><p>Supplier&lt;T> ： 不提供输入参数，返回一个 T 类型的结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testSupplier() &#123;</span><br><span class="line">    <span class="comment">// Supplier&lt;T&gt;:T get();</span></span><br><span class="line">    Supplier&lt;<span class="keyword">String</span>&gt; supplier = () -&gt; <span class="string">"Hello Jack!"</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(supplier.<span class="built_in">get</span>()); <span class="comment">// Hello Jack!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Operator：操作型接口（T-apply-T-t-）"><a href="#Operator：操作型接口（T-apply-T-t-）" class="headerlink" title="Operator：操作型接口（T apply(T t)）"></a>Operator：操作型接口（T apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>UnaryOperator&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 T 类型的结果</td></tr><tr><td>BinaryOperator&lt;T></td><td>提供两个 T 类型的输入参数，返回一个 T 类型的结果</td></tr><tr><td>DoubleBinaryOperator</td><td>提供两个 double 类型的输入参数，返回两个 double 类型的结果</td></tr><tr><td>DoubleUnaryOperator</td><td>提供一个 double 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntBinaryOperator</td><td>提供两个 int 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>IntUnaryOperator</td><td>提供一个 int 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>LongBinaryOperator</td><td>提供两个 long 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>LongUnaryOperator</td><td>提供一个 long 类型的输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：实现一个”一元函数“，即传入一个值经过函数的计算返回另一个同类型的值。</p><p>（2）使用场景：UnaryOperator 继承了 Function，与 Function 作用相同，不过 UnaryOperator，限定了传入类型和返回类型必需相同。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>T apply(T t)</td><td>将给定参数应用到函数中</td></tr><tr><td>Function&lt;T, V&gt; andThen(Function&lt; ? super T, ? extends V&gt; after)</td><td>返回一个组合函数，该函数结果应用到 after 函数中</td></tr><tr><td>Function&lt;V, T&gt; compose(Function&lt; ? super V, ? extends T&gt; before)</td><td>返回一个组合函数，首先将入参应用到 before 函数，再将 before 函数结果应用到该函数中</td></tr></tbody></table><p>（4）代码示例</p><p>UnaryOperator&lt;T> ： 提供一个 T 类型的输入参数，返回一个 T 类型的结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testOperator() &#123;</span><br><span class="line">    <span class="comment">// UnaryOperator&lt;T&gt;:T apply(T t)</span></span><br><span class="line">    UnaryOperator&lt;<span class="keyword">String</span>&gt; unaryOperator = <span class="keyword">String</span>::toUpperCase;</span><br><span class="line">    System.out.<span class="built_in">println</span>(unaryOperator.apply(<span class="string">"Hello World!"</span>));    <span class="comment">// HELLO WORLD!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryOperator&lt;T> ：提供两个 T 类型的输入参数，返回一个 T 类型的结果</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@Test</span></span><br><span class="line"><span class="symbol">public</span> void testBinaryOperator() &#123;</span><br><span class="line">    // <span class="keyword">BinaryOperator&lt;T&gt;:T </span>apply(T t1, T T2)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BinaryOperator&lt;BigInteger&gt; </span><span class="keyword">binaryOperator </span>= <span class="keyword">BigInteger::add;</span></span><br><span class="line"><span class="keyword"> </span>   System.out.println(<span class="keyword">binaryOperator.apply(BigInteger.ONE, </span><span class="keyword">BigInteger.TEN));</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java.util.function 包已经为大家提供了大量标注的函数接口。只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口。这样会使 API 更加容易学习，通过减少它的概念内容，显著提升互操作性优势，因为许多标准的函数接口都提供了有用的默认方法。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.cnblogs.com/huohuoL/p/10545437.html" target="_blank" rel="noopener">JDK8 新特性 - java.util.function-Function 接口</a><br>[2]. <a href="https://www.cnblogs.com/linzhanfly/p/9686941.html" target="_blank" rel="noopener">JAVA8 的 java.util.function 包</a></p><hr><h2 id="Java8-那些事儿系列"><a href="#Java8-那些事儿系列" class="headerlink" title="Java8 那些事儿系列"></a>Java8 那些事儿系列</h2><ul><li><a href="8cef11db.html">Java8 那些事儿（一）：Stream 函数式编程</a></li><li><a href="8eb6feba.html">Java8 那些事儿（二）：Optional 类解决空指针异常</a></li><li><a href="d66032e3.html">Java8 那些事儿（三）：Date/Time API(JSR 310)</a></li><li><a href="139a123e.html">Java8 那些事儿（四）：增强的 Map 集合</a></li><li><a href="43810ae.html">Java8 那些事儿（五）：函数式接口</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;函数式接口 (Functional Interface) 就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Java 允许利用 Lambda 表达式创建这些接口的实例。java.util.function 包是 Java 8 增加的一个新技术点 “函数式接口”，此包共有 43 个接口。别指望能够全部记住他们，但是如果能记住其中 6 个基础接口，必要时就可以推断出其余接口了。这些接口是为了使 Lamdba 函数表达式使用的更加简便，当然你也可以自己自定义接口来应用于 Lambda 函数表达式。&lt;/p&gt;
&lt;p&gt;JDK 1.8 API 包含了很多内建的函数式接口，比如 Comparator 或者 Runnable 接口，这些接口都增加了 @FunctionalInterface 注解以便能用在 Lamdba 上。现如今，我们则从 Function 常用函数入口，真正了解一下函数式接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java8" scheme="http://blog.maoning.pro/categories/Java8/"/>
    
    
      <category term="Function" scheme="http://blog.maoning.pro/tags/Function/"/>
    
      <category term="Lambda" scheme="http://blog.maoning.pro/tags/Lambda/"/>
    
      <category term="函数式接口" scheme="http://blog.maoning.pro/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>了不起的消息队列（一）：浅谈消息队列及常见的分布式消息队列中间件</title>
    <link href="http://blog.maoning.pro/archives/1c55560e.html"/>
    <id>http://blog.maoning.pro/archives/1c55560e.html</id>
    <published>2019-08-30T06:33:22.000Z</published>
    <updated>2019-08-30T06:49:41.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式消息队列中间件是是大型分布式系统不可缺少的中间件，通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。所以消息队列主要解决应用耦合、异步消息、流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性架构。消息队列已经逐渐成为企业应用系统内部通信的核心手段，当前使用较多的消息队列有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分数据库如 Redis、MySQL 以及 PhxSQL 也可实现消息队列的功能。</p><p>在日常学习与开发过程中，消息队列作为系统不可缺少的中间件，显得十分的重要。在现代云架构中，应用程序被分解为多个规模较小且更易于开发、部署和维护的独立构建块。消息队列可为这些分布式应用程序提供通信和协调。而本人也在工作的过程中，前前后后后接触到了 Kafka、RabbitMQ 两款消息队列。所以，本系列文章也主要以 RabbitMQ 和 Kafka 两款典型的消息中间件来做分析。本文是该系列的开篇，主要讲解消息队列的概述、特点等，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。</p><a id="more"></a><h2 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h2><p>消息队列（Message Queue，简称 MQ）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。消息队列是构建分布式互联网应用的基础设施，通过 MQ 实现的松耦合架构设计可以提高系统可用性以及可扩展性，是适用于现代应用的最佳设计方案。</p><p><img src="/media/15662836853167/16479c8e7c77109d.jpg" alt="16479c8e7c77109d"></p><h2 id="消息队列特点"><a href="#消息队列特点" class="headerlink" title="消息队列特点"></a>消息队列特点</h2><h3 id="为什么要用消息队列？"><a href="#为什么要用消息队列？" class="headerlink" title="为什么要用消息队列？"></a>为什么要用消息队列？</h3><h4 id="通过异步处理提高系统性能"><a href="#通过异步处理提高系统性能" class="headerlink" title="通过异步处理提高系统性能"></a>通过异步处理提高系统性能</h4><p>讲解该特点之前，我们先了解一下同步架构和异步架构的区别：</p><ul><li>同步调用：是指从请求的发起一直到最终的处理完成期间，请求的调用方一直在同步阻塞等待调用的处理完成。</li><li>异步调用：是指在请求发起的处理过程中，客户端的代码已经返回了，它可以继续进行自己的后续操作，而不需要等待调用处理完成，这就叫做异步调用。</li></ul><p><img src="/media/15662836853167/656726733d3239313233.jpg" alt="656726733d3239313233"></p><p>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p><p>通过以上分析我们可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示： </p><p><img src="/media/15662836853167/6726733d3133353530.jpg" alt="6726733d3133353530"></p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h4 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h4><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p><p><img src="/media/15662836853167/56726733d3134393436.jpg" alt="56726733d3134393436"></p><p>消息队列使利用发布 - 订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><h3 id="使用消息队列带来的一些问题？"><a href="#使用消息队列带来的一些问题？" class="headerlink" title="使用消息队列带来的一些问题？"></a>使用消息队列带来的一些问题？</h3><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等情况，但是，引入 MQ 之后你就需要如何保证消息队列的高可用。</li><li>系统复杂性提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题，系统复发性提高。</li><li>一致性问题： 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况。</li></ul><h2 id="JMS-VS-AMQP"><a href="#JMS-VS-AMQP" class="headerlink" title="JMS VS AMQP"></a>JMS VS AMQP</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java 消息服务（Java Message Service，JMS）应用程序接口是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS PI 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。点对点与发布订阅最初是由 JMS 定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费。</p><p>JMS 规范目前支持两种消息模型：点对点（point to point，queue）和发布 / 订阅（publish/subscribe，topic）。</p><p><img src="/media/15662836853167/20140410230348859.png" alt="20140410230348859"></p><h4 id="点对点（P2P）模型"><a href="#点对点（P2P）模型" class="headerlink" title="点对点（P2P）模型"></a>点对点（P2P）模型</h4><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。点对点（P2P）使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</p><p>Queue 实现了负载均衡，一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，一个 queue 可以有很多消费者，他们之间实现了负载均衡， 所以 Queue 实现了一个可靠的负载均衡。</p><p><img src="/media/15662836853167/20150817113531436.jpg" alt="20150817113531436"></p><p>特点：</p><ul><li>每个消息只用一个消费者；</li><li>发送者和接受者没有时间依赖；</li><li>接受者确认消息接受和处理成功。</li></ul><h4 id="发布-订阅（Pub-Sub）模型"><a href="#发布-订阅（Pub-Sub）模型" class="headerlink" title="发布 / 订阅（Pub/Sub）模型"></a>发布 / 订阅（Pub/Sub）模型</h4><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</p><p>Topic 实现了发布和订阅，当你发布一个消息，所有订阅这个 Topic 的服务都能得到这个消息，所以从 1 到 N 个订阅者都能得到一个消息的拷贝， 只有在消息代理收到消息时有一个有效订阅时的订阅者才能得到这个消息的拷贝。</p><p><img src="/media/15662836853167/20150817113626248.jpg" alt="20150817113626248"></p><p>特点：</p><ul><li>每个消息可以有多个订阅者；</li><li>客户端只有订阅后才能接收到消息；</li><li>持久订阅和非持久订阅。</li></ul><blockquote><p>注意：</p><ol><li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li><li>非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时约等于点对点模。</li></ol></blockquote><h4 id="点对点（P2P）模型与发布-订阅（Pub-Sub）模型应用"><a href="#点对点（P2P）模型与发布-订阅（Pub-Sub）模型应用" class="headerlink" title="点对点（P2P）模型与发布 / 订阅（Pub/Sub）模型应用"></a>点对点（P2P）模型与发布 / 订阅（Pub/Sub）模型应用</h4><ul><li>点对点模型：主要用于一些耗时较长的、逻辑相对独立的业务。</li></ul><p>比如说发送邮件这样一个操作。因为发送邮件比较耗时，而且应用程序其实也并不太关心邮件发送是否成功，发送邮件的逻辑也相对比较独立，所以它只需要把邮件消息丢到消息队列中就可以返回了，而消费者也不需要关心是哪个生产者去发送的邮件，它只需要把邮件消息内容取出来以后进行消费，通过远程服务器将邮件发送出去就可以了。而且每个邮件只需要被发送一次。所以消息只被一个消费者消费就可以了。</p><ul><li>发布订阅模型：如新用户注册这样一个消息，需要使用按主题发布的方式。</li></ul><p>比如新用户注册，一个新用户注册成功以后，需要给用户发送一封激活邮件，发送一条欢迎短信，还需要将用户注册数据写入数据库，甚至需要将新用户信息发送给关联企业的系统，比如淘宝新用户信息发送给支付宝，这样允许用户可以一次注册就能登录使用多个关联产品。一个新用户注册，会把注册消息发送给一个主题，多种消费者可以订阅这个主题。比如发送邮件的消费者、发送短信的消费者、将注册信息写入数据库的消费者，跨系统同步消息的消费者等。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP（advanced message queuing protocol）在 2003 年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP 是一种协议，更准确的说是一种 binary wire-level protocol（链接协议）。这是其和 JMS 的本质差别，AMQP 不从 API 层进行限定，而是直接定义网络交换的数据格式。这使得实现了 AMQP 的 provider 天然性就是跨平台的。意味着我们可以使用 Java 的 AMQP provider，同时使用一个 python 的 producer 加一个 rubby 的 consumer。</p><p>在 AMQP 中，消息路由（message routing）和 JMS 存在一些差别，在 AMQP 中增加了 Exchange 和 binding 的角色。producer 将消息发送给 Exchange，binding 决定 Exchange 的消息应该发送到那个 queue，而 consumer 直接从 queue 中消费消息。</p><p><img src="/media/15662836853167/20140410230404281.png" alt="20140410230404281"></p><p>AMQP 提供五种消息模型：①Direct Exchange；②Fanout Exchange；③Topic Exchange；④Headers Exchange；⑤System Exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分。</p><h3 id="JMS-与-AMQP-对比"><a href="#JMS-与-AMQP-对比" class="headerlink" title="JMS 与 AMQP 对比"></a>JMS 与 AMQP 对比</h3><p><img src="/media/15662836853167/20190823155319.png" alt="20190823155319"></p><p>总结：</p><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题 / 订阅 方式两种。</li></ul><h2 id="消息队列推拉模型"><a href="#消息队列推拉模型" class="headerlink" title="消息队列推拉模型"></a>消息队列推拉模型</h2><p>Push 推消息模型：消息生产者将消息发送给消息队列，消息队列又将消息推给消息消费者。</p><p>Pull 拉消息模型：消费者请求消息队列接受消息，消息生产者从消息队列中拉该消息。</p><p><img src="/media/15662836853167/16479c8ea4b19ea9.jpg" alt="16479c8ea4b19ea9"></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 实现了 AQMP 协议，AQMP 协议定义了消息路由规则和方式。生产端通过路由规则发送消息到不同 queue，消费端根据 queue 名称消费消息。此外 RabbitMQ 是向消费端推送消息，订阅关系和消费状态保存在服务端。</p><p><img src="/media/15662836853167/20150817114804971.jpg" alt="20150817114804971"></p><p><img src="/media/15662836853167/20150817114828518.jpg" alt="20150817114828518"></p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka 只支持消息持久化，消费端为拉模型，消费状态和订阅关系由客户端端负责维护，消息消费完后不会立即删除，会保留历史消息。因此支持多订阅时，消息只会存储一份就可以了。同一个订阅组会消费 topic 所有消息，每条消息只会被同一个订阅组的一个消费节点消费，同一个订阅组内不同消费节点会消费不同消息。</p><p><img src="/media/15662836853167/20150817114859626.jpg" alt="20150817114859626"></p><h2 id="消息队列使用场景"><a href="#消息队列使用场景" class="headerlink" title="消息队列使用场景"></a>消息队列使用场景</h2><h3 id="异步处理：实现异步处理，提升处理性能"><a href="#异步处理：实现异步处理，提升处理性能" class="headerlink" title="异步处理：实现异步处理，提升处理性能"></a>异步处理：实现异步处理，提升处理性能</h3><p>对一些比较耗时的操作，可以把处理过程通过消息队列进行异步处理。这样做可以推迟耗时操作的处理，使耗时操作异步化，而不必阻塞客户端的程序，客户端的程序在得到处理结果之前就可以继续执行，从而提高客户端程序的处理性能。非核心流程异步化，减少系统响应时间，提高吞吐量。</p><p>例如：短信通知、终端状态推送、App 推送、用户注册等。</p><h3 id="解耦：可以使生产者和消费者的代码实现解耦合"><a href="#解耦：可以使生产者和消费者的代码实现解耦合" class="headerlink" title="解耦：可以使生产者和消费者的代码实现解耦合"></a>解耦：可以使生产者和消费者的代码实现解耦合</h3><p>可以多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们的不需要直接的交互调用，没有代码的依赖耦合。在传统的同步调用中，调用者代码必须要依赖被调用者的代码，也就是生产者代码必须要依赖消费者的处理逻辑代码，代码需要直接的耦合，而使用消息队列，这两部分的代码不需要进行任何的耦合。因为耦合程度越低的代码越容易维护，也越容易进行扩展。</p><p>比如新用户注册，如果用传统同步调用的方式，那么发邮件、发短信、写数据库、通知关联系统这些代码会和用户注册代码直接耦合起来，整个代码看起来就是完成用户注册逻辑后，后面必然跟着发邮件、发短信这些代码。如果要新增一个功能，比如将监控用户注册情况，将注册信息发送到业务监控系统，就必须要修改前面的代码，至少增加一行代码，发送注册信息到监控系统，我们知道，任何代码的修改都可能会引起 bug。</p><p>而使用分布式消息队列实现生产者和消费者解耦合以后，用户注册以后，不需要调用任何后续处理代码，只需要将注册消息发送到分布式消息队列就可以了。如果要增加新功能，只需要写个新功能的消费者程序，在分布式消息队列中，订阅用户注册主题就可以了，不需要修改原来任何一行代码。</p><h3 id="流量削峰和流控：可以平衡流量峰值，削峰填谷"><a href="#流量削峰和流控：可以平衡流量峰值，削峰填谷" class="headerlink" title="流量削峰和流控：可以平衡流量峰值，削峰填谷"></a>流量削峰和流控：可以平衡流量峰值，削峰填谷</h3><p>当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的 “漏斗”，进行限流控制。在下游有能力处理的时候，再进行分发。</p><p>使用消息队列，即便是访问流量持续的增长，系统依然可以持续地接收请求。这种情况下，虽然生产者发布消息的速度比消费者消费消息的速度快，但是可以持续的将消息纳入到消息队列中，用消息队列作为消息的缓冲，因此短时间内，发布者不会受到消费处理能力的影响。</p><p>在访问高峰，用户的并发访问数可能超过了系统的处理能力，所以在高峰期就可能会导致系统负载过大，响应速度变慢，更严重的可能会导致系统崩溃。这种情况下，通过消息队列将用户请求的消息纳入到消息队列中，通过消息队列缓冲消费者处理消息的速度。</p><p>消息的生产者它有高峰有低谷，但是到了消费者这里，只会按照自己的最佳处理能力去消费消息。高峰期它会把消息缓冲在消息队列中，而在低谷期它也还是使用自己最大的处理能力去获取消息，将前面缓冲起来、来不及及时处理的消息处理掉。那么，通过这种手段可以实现系统负载消峰填谷，也就是说将访问的高峰消掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击。</p><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。短信系统可能由于短板效应，速度卡在网关上（每秒几百次请求），跟前端的并发量不是一个数量级。于是，就造成支付系统和短信系统的处理能力出现差异化。</p><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过协商、滑动窗口等复杂的方案也不是说不能实现。但系统复杂性指数级增长，势必在上游或者下游做存储，并且要处理定时、拥塞等一系列问题。而且每当有处理能力有差距的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><h3 id="易伸缩：可以让系统获得更好的伸缩性"><a href="#易伸缩：可以让系统获得更好的伸缩性" class="headerlink" title="易伸缩：可以让系统获得更好的伸缩性"></a>易伸缩：可以让系统获得更好的伸缩性</h3><p>耗时的任务可以通过分布式消息队列，向多台消费者服务器并行发送消息，然后在很多台消费者服务器上并行处理消息，也就是说可以在多台物理服务器上运行消费者。那么当负载上升的时候，可以很容易地添加更多的机器成为消费者。</p><p>例如：用户上传文件后，通过发布消息的方式，通知后端的消费者获取数据、读取文件，进行异步的文件处理操作。那么当前端发布更多文件的时候，或者处理逻辑比较复杂的时候，就可以通过添加后端的消费者服务器，提供更强大的处理能力。</p><h3 id="隔离失效机器以及自我修复：失败隔离和自我修复"><a href="#隔离失效机器以及自我修复：失败隔离和自我修复" class="headerlink" title="隔离失效机器以及自我修复：失败隔离和自我修复"></a>隔离失效机器以及自我修复：失败隔离和自我修复</h3><p>因为发布者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响。当在消息消费过程中出现处理逻辑失败的时候，这个错误只会影响到消费者自身，而不会传递给消息的生产者，也就是应用程序可以按照原来的处理逻辑继续执行。</p><p>所以，这也就意味着在任何时候都可以对后端的服务器执行维护和发布操作。可以重启、添加或删除服务器，而不影响生产者的可用性，这样简化了部署和服务器管理的难度。</p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输和缓冲的问题。日志采集客户端，负责日志数据采集，定时写受写入 Kafka 队列；Kafka 消息队列，负责日志数据的接收，存储和转发；日志处理应用，订阅并消费 kafka 队列中的日志数据。</p><h2 id="消息队列技术对比"><a href="#消息队列技术对比" class="headerlink" title="消息队列技术对比"></a>消息队列技术对比</h2><ul><li><p><strong>ActiveMQ</strong> 是 Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可行了解。</p></li><li><p><strong>RabbitMQ</strong> 是采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。主要特点是性能好，社区活跃，但是 RabbitMQ 用 Erlang 开发，我们的应用很少用 Erlang，所以不便于二次开发和维护。</p></li><li><p><strong>Kafka</strong> 是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p></li><li><p><strong>RocketMQ</strong> 是阿里开源的消息中间件，目前在 Apache 孵化，使用纯 Java 开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ 思路起源于 Kafka，但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog 分发等场景，支撑了阿里多次双十一活动。</p></li><li><p><strong>ZeroMQ</strong> 是基于 C 语言开发，号称史上最快的消息队列。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</p></li></ul><p>总结：</p><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</li><li>kafka 最初设计时就是针对互联网的分布式、高可用应用场景而设计，所以其特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p><img src="/media/15662836853167/20190826102530.png" alt="20190826102530"></p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://juejin.im/post/5b41fe36e51d45191252e79e#heading-21" target="_blank" rel="noopener">浅谈消息队列及常见的消息中间件</a><br>[2]. <a href="https://mp.weixin.qq.com/s/ad7jibTb5nTzh3nDQYKFeg" target="_blank" rel="noopener">消息中间件选型分析</a><br>[3]. <a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">新手也能看懂，消息队列其实很简单</a><br>[4]. <a href="https://mp.weixin.qq.com/s/MbM3xc5egIEaklRKfr7nzg" target="_blank" rel="noopener">10 分钟搞懂：95% 的程序员都拎不清的分布式消息队列中间件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;分布式消息队列中间件是是大型分布式系统不可缺少的中间件，通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。所以消息队列主要解决应用耦合、异步消息、流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性架构。消息队列已经逐渐成为企业应用系统内部通信的核心手段，当前使用较多的消息队列有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分数据库如 Redis、MySQL 以及 PhxSQL 也可实现消息队列的功能。&lt;/p&gt;
&lt;p&gt;在日常学习与开发过程中，消息队列作为系统不可缺少的中间件，显得十分的重要。在现代云架构中，应用程序被分解为多个规模较小且更易于开发、部署和维护的独立构建块。消息队列可为这些分布式应用程序提供通信和协调。而本人也在工作的过程中，前前后后后接触到了 Kafka、RabbitMQ 两款消息队列。所以，本系列文章也主要以 RabbitMQ 和 Kafka 两款典型的消息中间件来做分析。本文是该系列的开篇，主要讲解消息队列的概述、特点等，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列" scheme="http://blog.maoning.pro/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.maoning.pro/tags/RabbitMQ/"/>
    
      <category term="Kafka" scheme="http://blog.maoning.pro/tags/Kafka/"/>
    
      <category term="JMS" scheme="http://blog.maoning.pro/tags/JMS/"/>
    
      <category term="AMQP" scheme="http://blog.maoning.pro/tags/AMQP/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</title>
    <link href="http://blog.maoning.pro/archives/f4f43ede.html"/>
    <id>http://blog.maoning.pro/archives/f4f43ede.html</id>
    <published>2019-08-07T09:14:45.000Z</published>
    <updated>2019-08-13T11:44:42.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 并发编程是整个 Java 开发体系中最难以理解但也是最重要的知识点，也是各类开源分布式框架（如 ZooKeeper、Kafka、Spring Cloud、Netty 等）中各个并发组件实现的基础。J.U.C 并发包，即 java.util.concurrent 包，大大提高了并发性能，是 JDK 的核心工具包，是 JDK 1.5 之后，由 Doug Lea 实现并引入。而 AQS 被认为是 J.U.C 的核心。</p><p>AQS 是一个抽象类，并没有对并发类提供了一个统一的接口定义，而是由子类根据自身的情况实现相应的方法，AQS 中一般包含两个方法 acquire(int)、release(int)，获取同步状态和释放同步状态，AQS 根据其状态是否独占分为独占模式和共享模式。</p><ul><li>独占模式：同一时刻最多只有一个线程获取同步状态，处于该模式下，其他线程试图获取该锁将无法获取成功。</li><li>共享模式：同一时刻会有多个线程获取共享同步状态，处于该模式下，其他线程试图获取该锁可能会获取成功。</li></ul><p>同步器根据同步状态分为独占模式和共享模式，独占模式包括类：ReentrantLock、ReentrantReadWriteLock.WriteLock，共享模式包括：Semaphore、CountDownLatch、ReentrantReadWriteLock.ReadLock，本文将着重介绍一下 java.util.concurrent 包下一些辅助同步器类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、Phaser。</p><a id="more"></a><h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch - 闭锁"></a>CountDownLatch - 闭锁</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 是一个同步辅助工具类，通过它可以完成类似于阻塞当前线程的功能，也就是一个或多个线程一直等待直到其他线程执行完成。即允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p><p>CountDownLatch 用了一个给定的计数器 cnt 来进行初始化，该计数器的操作是原子操作，即同时只能有一个线程操作该计数器，调用该类 await 方法的线程会一直处于阻塞状态，直到其他线程调用 countDown 方法时计数器的值变成 0，每次调用 countDown 时计数器的值会减 1，当计数器的值为 0 时所有因 await 方法而处于等待状态的线程就会继续执行。计数器 cnt 是闭锁需要等待的线程数量，只能被设置一次，且 CountDownLatch 没有提供任何机制去重新设置计数器 count，如果需要重置，可以考虑使用 CyclicBarrier。</p><p><img src="/media/15651639608949/CountdownLatch_example.png" alt="CountdownLatch_example"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>（1）开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</p><p>（2）应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><p>（3）确保一个计算不会执行，直到所需要的资源被初始化。</p><p>（4）并行计算，处理量很大时可以将运算任务拆分成多个子任务，当所有子任务都完成之后，父任务再将所有子任务都结果进行汇总。</p><h3 id="主要接口分析"><a href="#主要接口分析" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>CountDownLatch 内部依赖 Sync 实现，而 Sync 继承 AQS。CountDownLatch 关键接口如下：</p><ul><li>countDown() 如果当前计数器的值大于 1，则将其减 1；若当前值为 1，则将其置为 0 并唤醒所有通过 await 等待的线程；若当前值为 0，则什么也不做直接返回。</li><li>await() 等待计数器的值为 0，若计数器的值为 0 则该方法返回；若等待期间该线程被中断，则抛出 InterruptedException 并清除该线程的中断状态。</li><li>await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为 0，若在指定时间内计数器的值变为 0，则该方法返回 true；若指定时间内计数器的值仍未变为 0，则返回 false；若指定时间内计数器的值变为 0 之前当前线程被中断，则抛出 InterruptedException 并清除该线程的中断状态。</li><li>getCount() 读取当前计数器的值，一般用于调试或者测试。</li></ul><h3 id="Coding-演示"><a href="#Coding-演示" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）作为一个开关 / 入口</p><p>将初始计数值为 1 的 CountDownLatch 作为一个的开关或入口，在调用 countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(countDownLatch));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="comment">// 主线程开启开关</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"start.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch countDownLatch) &#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 所有执行线程在此处等待开关开启 [多个子线程同时执行]</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 子线程执行</span></span><br><span class="line">            doWork();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// start..run..run..run..run..run..run..run..run..run..run..</span></span><br></pre></td></tr></table></figure><p>（2）作为一个完成信号</p><p>将初始计数值为 N 的 CountDownLatch 作为一个完成信号点，使某个线程在其它 N 个线程完成某项操作之前一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(WORK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(countDownLatch));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待其它 N 个线程完成</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch countDownLatch) &#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子线程执行</span></span><br><span class="line">        doWork();</span><br><span class="line">        <span class="comment">// 每个线程做完自己的事情后, 就将计数器减去 1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// run..run..run..run..run..run..run..run..run..run..end</span></span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier - 循环栅栏"></a>CyclicBarrier - 循环栅栏</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CyclicBarrier 和 CountDownLatch 是非常类似的，CyclicBarrier 核心的概念是在于设置一个等待线程的数量边界，到达了此边界之后进行执行。CyclicBarrier 也是一个同步辅助工具类，它允许一组线程相互等待直到到达某个公共的屏障点（Common Barrier Point），通过它可以完成多个线程之间相互等待时，只有当每个线程都准备就绪后才能各自继续执行后面的操作。</p><p>CyclicBarrier 也是通过计数器来实现，当某个线程调用 await 方法后就进入等待状态，计数器执行加一操作。当计数器的值达到了设置的初始值时等待状态的线程会被唤醒继续执行。通过调用 CyclicBarrier 对象的 await() 方法，两个线程可以实现互相等待。一旦 N 个线程在等待 CyclicBarrier 达成，所有线程将被释放掉去继续执行。由于 CyclicBarrier 在释放等待线程后可以重用，所以可以称之为循环栅栏。</p><p><img src="/media/15651639608949/759814-20181031152238027-1792385756.png" alt="759814-20181031152238027-1792385756"></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>CyclicBarrier 特别适用于并行迭代计算，每个线程负责一部分计算，然后在栅栏处等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。</p><h3 id="主要接口分析-1"><a href="#主要接口分析-1" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>CyclicBarrier 并没有自己去实现 AQS 框架的 API，而是利用了 ReentrantLock 和 Condition。</p><p>CyclicBarrier 提供的关键方法如下：</p><ul><li>await() 等待其它参与方的到来（调用 await()）。如果当前调用是最后一个调用，则唤醒所有其它的线程的等待并且如果在构造 CyclicBarrier 时指定了 action，当前线程会去执行该 action，然后该方法返回该线程调用 await 的次序（getParties()-1 说明该线程是第一个调用 await 的，0 说明该线程是最后一个执行 await 的），接着该线程继续执行 await 后的代码；如果该调用不是最后一个调用，则阻塞等待；如果等待过程中，当前线程被中断，则抛出 InterruptedException；如果等待过程中，其它等待的线程被中断，或者其它线程等待超时，或者该 barrier 被 reset，或者当前线程在执行 barrier 构造时注册的 action 时因为抛出异常而失败，则抛出 BrokenBarrierException。</li><li>await(long timeout, TimeUnit unit) 与 await() 唯一的不同点在于设置了等待超时时间，等待超时时会抛出 TimeoutException。</li><li>reset() 该方法会将该 barrier 重置为它的初始状态，并使得所有对该 barrier 的 await 调用抛出 BrokenBarrierException。</li></ul><p>CyclicBarrier 提供的两个构造函数：</p><ul><li>CyclicBarrier(int parties)：parties 表示拦截线程的数量。创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li><li>CyclicBarrier(int parties, Runnable barrierAction) ：barrierAction 为 CyclicBarrier 接收的 Runnable 命令，用于在线程到达屏障时，优先执行 barrierAction ，用于处理更加复杂的业务场景。创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</li></ul><h3 id="Coding-演示-1"><a href="#Coding-演示-1" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）简单例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(WORK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    Worker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 多个线程之间相互等待时，只有当每个线程都准备就绪后才能各自继续执行后面的操作</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程执行</span></span><br><span class="line">        doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span></span><br></pre></td></tr></table></figure><p>（2）执行 barrierAction</p><p>在 ready 状态时日志是每秒输出一条，当有 5 条 ready 时会一次性输出 5 条 continue。这就是前面讲的全部线程准备就绪后同时开始执行。在初始化 CyclicBarrier 时还可以在等待线程数后指定一个 runnable，含义是当线程到达这个屏障时优先执行这里的 runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 5 的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; System.out.println(String.format(<span class="string">"%s call back is ready."</span>, Thread.currentThread().getName())));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    Worker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s is ready"</span>, Thread.currentThread().getName()));</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s continue"</span>, Thread.currentThread().getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 call back is ready.</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 call back is ready.</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 continue</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h3><p>CyclicBarrier 与 CountDownLatch 可能容易混淆，我们强调下其区别：</p><ul><li><p>CountDownLatch 的参与线程是有不同角色的，有的负责倒计时，有的在等待倒计时变为 0，负责倒计时和等待倒计时的线程都可以有多个，它用于不同角色线程间的同步。</p></li><li><p>CyclicBarrier 的参与线程角色是一样的，用于同一角色线程间的协调一致。</p></li><li><p>CountDownLatch 是一次性的，而 CyclicBarrier 是可以重复利用的。</p></li></ul><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore - 信号量"></a>Semaphore - 信号量</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Semaphore，又名信号量，这个类的作用有点类似于 “许可证”。信号量 Semaphore 是一个控制访问多个共享资源的计数器，和 CountDownLatch 一样，其本质上是一个 “共享锁”。从源码角度来看，Semaphore 的实现方式和 CountDownLatch 非常相似，基于 AQS 做了一些定制。通过维持 AQS 的锁全局计数 state 字段来实现定量锁的加锁和解锁操作。Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目。</p><p>有时，我们因为一些原因需要控制同时访问共享资源的最大线程数量，比如出于系统性能的考虑需要限流，或者共享资源是稀缺资源，我们需要有一种办法能够协调各个线程，以保证合理的使用公共资源。当有线程想要访问共享资源时，需要先获取 (acquire) 的许可；如果许可不够了，线程需要一直等待，直到许可可用。当线程使用完共享资源后，可以归还 (release) 许可，以供其它需要的线程使用；然而，实际上并没有真实的许可证对象供线程使用，Semaphore 只是对可用的数量进行管理维护。</p><p><img src="/media/15651639608949/759814-20181031152255999-607973962.png" alt="759814-20181031152255999-607973962"></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>Semaphore 可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p><h3 id="主要接口分析-2"><a href="#主要接口分析-2" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Semaphore 内部包含公平锁（FairSync）和非公平锁（NonfairSync），继承内部类 Sync，其中 Sync 继承 AQS，作为 Semaphore 的公平锁和非公平锁的基类。</p><p>CyclicBarrier 提供的关键方法如下：</p><ul><li>isFair()：是否公平模式 FIFO</li><li>availablePermits()：获取当前可用的许可证数量</li><li>acquire()：当前线程尝试去阻塞的获取 1 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 1 个可用的许可证，则会停止等待，继续执行；当前线程被中断，则会抛出 InterruptedException 异常，并停止等待，继续执行。</li><li>acquire(permits)：当前线程尝试去阻塞的获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 n 个可用的许可证，则会停止等待，继续执行；当前线程被中断，则会抛出 InterruptedException 异常，并停止等待，继续执行。</li><li>acquierUninterruptibly()：当前线程尝试去阻塞的获取 1 个许可证 (不可中断的)。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 1 个可用的许可证，则会停止等待，继续执行。</li><li>acquireUninterruptibly(permits)：当前线程尝试去阻塞的获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 n 个可用的许可证，则会停止等待，继续执行。</li><li>tryAcquire()：当前线程尝试去获取 1 个许可证。此过程是非阻塞的，它只是在方法调用时进行一次尝试。如果当前线程获取了 1 个可用的许可证，则会停止等待，继续执行，并返回 true。如果当前线程没有获得这个许可证，也会停止等待，继续执行，并返回 false。</li><li>tryAcquire(permits)：当前线程尝试去获取 permits 个许可证。此过程是非阻塞的，它只是在方法调用时进行一次尝试。如果当前线程获取了 permits 个可用的许可证，则会停止等待，继续执行，并返回 true。如果当前线程没有获得 permits 个许可证，也会停止等待，继续执行，并返回 false。</li><li>tryAcquire(timeout, TimeUnit)：当前线程在限定时间内，阻塞的尝试去获取 1 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了可用的许可证，则会停止等待，继续执行，并返回 true；当前线程等待时间 timeout 超时，则会停止等待，继续执行，并返回 false；当前线程在 timeout 时间内被中断，则会抛出 InterruptedException 一次，并停止等待，继续执行。</li><li>tryAcquire(permits, timeout, TimeUnit)：当前线程在限定时间内，阻塞的尝试去获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了可用的 permits 个许可证，则会停止等待，继续执行，并返回 true；当前线程等待时间 timeout 超时，则会停止等待，继续执行，并返回 false；当前线程在 timeout 时间内被中断，则会抛出 InterruptedException 一次，并停止等待，继续执行。</li><li>release()：当前线程释放 1 个可用的许可证。</li><li>release(permits)：当前线程释放 permits 个可用的许可证。</li><li>drainPermits()：当前线程获得剩余的所有可用许可证。</li><li>hasQueuedThreads()：判断当前 Semaphore 对象上是否存在正在等待许可证的线程。</li><li>getQueueLength()：获取当前 Semaphore 对象上是正在等待许可证的线程数量。</li></ul><p>Semaphore 提供了两个构造函数：</p><ul><li>Semaphore(int permits)：创建具有给定的许可数和非公平的公平设置的 Semaphore，Semaphore 默认选择非公平锁。</li><li>Semaphore(int permits, boolean fair)：创建具有给定的许可数和给定的公平设置的 Semaphore。Semaphore 有两种模式，公平模式和非公平模式。公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程，简单的说就是随机选取新线程来运行。</li></ul><h3 id="Coding-演示-2"><a href="#Coding-演示-2" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        final int clientCount = <span class="number">3</span>;</span><br><span class="line">        final int totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.<span class="built_in">print</span>(semaphore.availablePermits() + <span class="string">" "</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">finally</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.release();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Output</span></span></span><br><span class="line"><span class="function">// 2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></table></figure><h2 id="Exchanger-交换器"><a href="#Exchanger-交换器" class="headerlink" title="Exchanger - 交换器"></a>Exchanger - 交换器</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Exchanger（交换器）是一个用于线程间协作的工具类，是 JDK 1.5 开始提供的一个用于两个工作线程之间交换数据的封装工具类。Exchanger 有点类似于 CyclicBarrier，我们知道 CyclicBarrier 是一个栅栏，到达栅栏的线程需要等待其它一定数量的线程到达后，才能通过栅栏，Exchanger 可以看成是一个双向栅栏。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p><p>可简单地将 Exchanger 对象理解为一个包含两个格子的容器，通过 exchanger 方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p><img src="/media/15651639608949/3655810457-5b7034f01b70a_articlex.png" alt="3655810457-5b7034f01b70a_articlex"></p><h3 id="主要接口分析-3"><a href="#主要接口分析-3" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Exchanger 是最简单的也是最复杂的，简单在于 API 非常简单，就一个构造方法和两个 exchange() 方法，最复杂在于它的实现是最复杂的。</p><p>Exchanger 提供的关键方法如下：</p><ul><li>exchange(V x) ：当前线程跟另外一个线程交换数据 x，如果另外一个线程的数据准备好，那么当前线程会立刻返回，并获得另外一个线程的数据；否则当前线程会进入等待状态。</li><li>V exchange(V x, long timeout, TimeUnit unit)：当前线程跟另外一个线程交换数据 x，有一个指定的超时时间，如果在等待时间超时了，而且还没有收到对方的数据的话，则会抛出 TimeoutException 异常。</li></ul><p>可以看出，当一个线程到达 exchange 调用点时，如果其他线程此前已经调用了此方法，则其他线程会被调度唤醒并与之进行对象交换，然后各自返回；如果其他线程还没到达交换点，则当前线程会被挂起，直至其他线程到达才会完成交换并正常返回，或者当前线程被中断或超时返回。</p><h3 id="Coding-演示-3"><a href="#Coding-演示-3" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExchangerExample</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static final Integer WORK_COUNT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                String beforeObj = Thread.currentThread().getName();</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    String afterObj = exchanger.exchange(Thread.currentThread().getName());</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.println(String.format(<span class="string">"currentThread %s , before exchange %s , after exchange %s"</span>, Thread.currentThread().getName(), beforeObj, afterObj));</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Output</span></span></span><br><span class="line"><span class="function">// <span class="title">currentThread</span> <span class="title">pool-1-thread-1</span> , <span class="title">before</span> <span class="title">exchange</span> <span class="title">pool-1-thread-1</span> , <span class="title">after</span> <span class="title">exchange</span> <span class="title">pool-1-thread-2</span> </span></span><br><span class="line"><span class="function">// <span class="title">currentThread</span> <span class="title">pool-1-thread-2</span> , <span class="title">before</span> <span class="title">exchange</span> <span class="title">pool-1-thread-2</span> , <span class="title">after</span> <span class="title">exchange</span> <span class="title">pool-1-thread-1</span></span></span><br></pre></td></tr></table></figure><h2 id="Phaser-多阶段栅栏"><a href="#Phaser-多阶段栅栏" class="headerlink" title="Phaser - 多阶段栅栏"></a>Phaser - 多阶段栅栏</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 和 CyclicBarrier 都是 JDK 1.5 引入的，而 Phaser 是 JDK 1.7 引入的。Phaser 的功能与 CountDownLatch 和 CyclicBarrier 有部分重叠，它几乎可以取代 CountDownLatch 和 CyclicBarrier， 其功能更灵活，更强大，支持动态调整需要控制的线程数。</p><p>CountDownLatch，闭锁，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待，它提供了 await()、countDown() 两个方法来进行操作；CyclicBarrier，循环栅栏，允许一组线程互相等待，直到到达某个公共屏障点，它提供的 await() 可以实现让所有参与者在临界点到来之前一直处于等待状态；Phaser，多阶段栅栏，它把多个线程协作执行的任务划分为多个阶段，编程时需要明确各个阶段的任务，每个阶段都可以有任意个参与者，线程都可以随时注册并参与到某个阶段，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）。</p><p>Phaser 顾名思义，与阶段相关。Phaser 比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个 CyclicBarrier 来实现，每个 CyclicBarrier 负责等待一个阶段的任务全部完成。但是使用 CyclicBarrier 的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而 Phaser 可同时解决这两个问题。</p><p><img src="/media/15651639608949/878416911-5b72af098eb7b.png" alt="878416911-5b72af098eb7b"></p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>Phaser 主要接口如下：</p><h3 id="主要接口分析-4"><a href="#主要接口分析-4" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Phaser 提供的关键方法如下：</p><ul><li>arriveAndAwaitAdvance()：当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从 0 开始），同时其它线程的该方法也返回下一个阶段的序号。arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法。</li><li>arriveAndDeregister()：该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该 Phaser 是另外一个 Phaser 的子 Phaser，并且该操作导致当前 Phaser 的成员数为 0，则该操作也会将当前 Phaser 从其父 Phaser 中移除。</li><li>arrive()：该方法不作任何等待，直接返回下一阶段的序号。</li><li>awaitAdvance(int phase)：该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该 Phaser 已经被终止，则立即返回。该阶段数一般由 arrive() 方法或者 arriveAndDeregister() 方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前 Phaser 已经被终止）。</li><li>awaitAdvanceInterruptibly(int phase)：效果与 awaitAdvance(int phase) 相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出 InterruptedException。</li><li>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)：效果与 awaitAdvanceInterruptibly(int phase) 相当，区别在于如果超时则抛出 TimeoutException。</li><li>bulkRegister(int parties)：注册多个 party。如果当前 phaser 已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance 方法正在执行，则该方法等待其执行完毕。如果该 Phaser 有父 Phaser 则指定的 party 数大于 0，且之前该 Phaser 的 party 数为 0，那么该 Phaser 会被注册到其父 Phaser 中。</li><li>forceTermination()：强制让该 Phaser 进入终止状态。已经注册的 party 数不受影响。如果该 Phaser 有子 Phaser，则其所有的子 Phaser 均进入终止状态。如果该 Phaser 已经处于终止状态，该方法调用不造成任何影响。</li></ul><h3 id="Coding-演示-4"><a href="#Coding-演示-4" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）通过 Phaser 实现 CyclicBarrier 控制多个线程的执行时机的功能</p><p>通过 Phaser 控制多个线程的执行时机：有时候我们希望所有线程到达指定点后再同时开始执行，我们可以利用 CyclicBarrier 来实现，这里给出使用 Phaser 的版本。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-10, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（2）通过 Phaser 实现 CyclicBarrier 执行 barrierAction</p><p>CyclicBarrier 支持 barrier action, Phaser 同样也支持。不同之处是 Phaser 的 barrier action 需要改写 onAdvance 方法来进行定制。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">boolean</span> onAdvance(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"%s call back is ready."</span>, Thread.currentThread().getName()));</span><br><span class="line">                <span class="built_in">return</span> super.onAdvance(phase, registeredParties);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// pool-1-thread-10 call back is ready.</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-10, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（3）通过 Phaser 实现 CountDownLatch 作为一个开关 / 入口功能</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 注册主线程, 当外部条件满足时, 由主线程打开开关</span></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开开关 [parties 共 11 个, 主线程从之后需要等待的成员中移除, 即 parties 还剩 10]</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"主线程打开了开关"</span>);</span><br><span class="line"></span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// 主线程打开了开关</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（4）通过 Phaser 实现分层</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parties = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> phases = <span class="number">4</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"====== Phase :"</span> + phase + <span class="string">"======"</span>);</span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onAdvance</span><span class="params">(phase, registeredParties)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;</span><br><span class="line">                    <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                    <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    <span class="comment">// do something</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// ====== Phase : 0 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// ====== Phase : 1 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// ====== Phase : 2 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// ====== Phase : 3 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:4</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:4</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:4</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://juejin.im/post/5d32f2c6f265da1b897b0b68#heading-3" target="_blank" rel="noopener">【并发编程】J.U.C 之 AQS 介绍、实现及其子类使用演示</a><br>[2]. <a href="http://www.jasongj.com/java/thread_communication/" target="_blank" rel="noopener">Java 进阶（四）线程间通信剖析</a><br>[3]. <a href="https://segmentfault.com/blog/ressmix_multithread" target="_blank" rel="noopener">透彻理解 Java 并发编程</a><br>[4]. <a href="http://cmsblogs.com/?cat=151" target="_blank" rel="noopener">死磕 Java 并发</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 并发编程是整个 Java 开发体系中最难以理解但也是最重要的知识点，也是各类开源分布式框架（如 ZooKeeper、Kafka、Spring Cloud、Netty 等）中各个并发组件实现的基础。J.U.C 并发包，即 java.util.concurrent 包，大大提高了并发性能，是 JDK 的核心工具包，是 JDK 1.5 之后，由 Doug Lea 实现并引入。而 AQS 被认为是 J.U.C 的核心。&lt;/p&gt;
&lt;p&gt;AQS 是一个抽象类，并没有对并发类提供了一个统一的接口定义，而是由子类根据自身的情况实现相应的方法，AQS 中一般包含两个方法 acquire(int)、release(int)，获取同步状态和释放同步状态，AQS 根据其状态是否独占分为独占模式和共享模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占模式：同一时刻最多只有一个线程获取同步状态，处于该模式下，其他线程试图获取该锁将无法获取成功。&lt;/li&gt;
&lt;li&gt;共享模式：同一时刻会有多个线程获取共享同步状态，处于该模式下，其他线程试图获取该锁可能会获取成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步器根据同步状态分为独占模式和共享模式，独占模式包括类：ReentrantLock、ReentrantReadWriteLock.WriteLock，共享模式包括：Semaphore、CountDownLatch、ReentrantReadWriteLock.ReadLock，本文将着重介绍一下 java.util.concurrent 包下一些辅助同步器类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、Phaser。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://blog.maoning.pro/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Semaphore" scheme="http://blog.maoning.pro/tags/Semaphore/"/>
    
      <category term="CountDownLatch" scheme="http://blog.maoning.pro/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="http://blog.maoning.pro/tags/CyclicBarrier/"/>
    
      <category term="Phaser" scheme="http://blog.maoning.pro/tags/Phaser/"/>
    
      <category term="Exchanger" scheme="http://blog.maoning.pro/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 进阶讲解（二）：快速生成测试数据以及 EXPLAIN 详解</title>
    <link href="http://blog.maoning.pro/archives/46faebc7.html"/>
    <id>http://blog.maoning.pro/archives/46faebc7.html</id>
    <published>2019-07-28T01:57:54.000Z</published>
    <updated>2019-08-30T06:54:44.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的 IO 成本。MySQL 在 300w 条记录左右性能开始逐渐下降，虽然官方文档说 500~800w 记录，所以大数据量建立索引是非常有必要的。MySQL 提供了 EXPLAIN，用于显示 SQL 执行的详细信息，可以进行索引的优化。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的查询语句或是表结构的性能瓶颈。 可以帮助选择更好的索引和写出更优化的查询语句。</p><p>本章首先介绍如何通过存储过程随机生成大量随机数据作为 EXPLIAN 的测试数据，然后通过例子详解 EXPLIAN 用法以及各字段含义，最后对 EXPLIAN 用途进行总结。</p><a id="more"></a><h2 id="EXPLAIN-概述"><a href="#EXPLAIN-概述" class="headerlink" title="EXPLAIN 概述"></a>EXPLAIN 概述</h2><p>EXPLAIN 命令是查看查询优化器如何决定执行查询的主要方法，使用 EXPLAIN，只需要在查询中的 SELECT 关键字之前增加 EXPLAIN 这个词即可，MYSQL 会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，而不是执行它，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序，从而可以从分析结果中找到查询语句或是表结构的性能瓶颈。</p><p>通过 EXPLAIN，我们可以分析出以下结果：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h2 id="随机生成大量测试数据"><a href="#随机生成大量测试数据" class="headerlink" title="随机生成大量测试数据"></a>随机生成大量测试数据</h2><p>利用 MySQL 内存表插入速度快的特点，先利用函数和存储过程在内存表中生成数据，然后再从内存表插入普通表中。</p><p>（1）登录 MySQL</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 连接到远程主机上的 MySQL</span></span><br><span class="line">$ mysql -h [host] -u [username] -p [password]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看所有的数据库</span></span><br><span class="line">mysql&gt; <span class="keyword">show </span>databases<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 选择数据库</span></span><br><span class="line">mysql&gt; use [table_name]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看数据库中的表 </span></span><br><span class="line">mysql&gt; <span class="keyword">show </span>tables<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（2）创建内存表</p><p>如果一条一条插入普通表的话，效率太低下，但内存表插入速度是很快的，可以先建立一张内存表，插入数据后，在导入到普通表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`big_data_user_memory`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_user_memory`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别 [0: 男性; 1: 女性]'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组ID'</span>,</span><br><span class="line">  <span class="string">`join_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'加入时间'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> <span class="keyword">HASH</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">MEMORY</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>（3）创建普通表</p><p>创建普通表，参数设置和内存表相同，否则从内存表往普通标导入数据会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`big_data_user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别 [0: 男性; 1: 女性]'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组ID'</span>,</span><br><span class="line">  <span class="string">`join_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'加入时间'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>（4）创建存储函数</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 生成随机 UserId</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=`root`@`localhost` <span class="function"><span class="keyword">FUNCTION</span> `<span class="title">generateCode</span>`<span class="params">( n int )</span> <span class="title">RETURNS</span> <span class="title">varchar</span><span class="params">(20)</span> <span class="title">CHARSET</span> <span class="title">utf8</span></span></span><br><span class="line"><span class="function">    <span class="title">DETERMINISTIC</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function"><span class="title">DECLARE</span> <span class="title">chars_str</span> <span class="title">VARCHAR</span> <span class="params">( 100 )</span> <span class="title">DEFAULT</span> '<span class="title">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span>';</span></span><br><span class="line">DECLARE return_str VARCHAR ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">DECLARE i INT <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">WHILE</span></span><br><span class="line">i &lt; n <span class="keyword">DO</span></span><br><span class="line"><span class="keyword">SET</span> return_str = <span class="keyword">concat</span>(return_str, SUBSTRING(chars_str, FLOOR( <span class="number">1</span> + RAND() * <span class="number">62</span> ), <span class="number">1</span> ));</span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">RETURN return_str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 生成随机中文名</span></span><br><span class="line">CREATE DEFINER=`root`@`localhost` <span class="keyword">FUNCTION</span> `generateUserName`() RETURNS varchar(<span class="number">255</span>) CHARSET utf8</span><br><span class="line">    DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line"><span class="meta">#Routine body goes here...</span></span><br><span class="line"><span class="keyword">DECLARE</span> last_name varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'赵钱孙李周郑王冯陈楮卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闽席季麻强贾路娄危江童颜郭梅盛林刁锺徐丘骆高夏蔡田樊胡凌霍虞万支柯昝管卢莫经裘缪干解应宗丁宣贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁';</span></span><br><span class="line"><span class="keyword">DECLARE</span> first_name varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'嘉懿煜城懿轩烨伟苑博伟泽熠彤鸿煊博涛烨霖烨华煜祺智宸正豪昊然明杰诚立轩立辉峻熙弘文熠彤鸿煊烨霖哲瀚鑫鹏致远俊驰雨泽烨磊晟睿天佑文昊修洁黎昕远航旭尧鸿涛伟祺轩越泽浩宇瑾瑜皓轩擎苍擎宇志泽睿渊楷瑞轩弘文哲瀚雨泽鑫磊梦琪忆之桃慕青问兰尔岚元香初夏沛菡傲珊曼文乐菱痴珊恨玉惜文香寒新柔语蓉海安夜蓉涵柏水桃醉蓝春儿语琴从彤傲晴语兰又菱碧彤元霜怜梦紫寒妙彤曼易南莲紫翠雨寒易烟如萱若南寻真晓亦向珊慕灵以蕊寻雁映易雪柳孤岚笑霜海云凝天沛珊寒云冰旋宛儿绿真盼儿晓霜碧凡夏菡曼香若烟半梦雅绿冰蓝灵槐平安书翠翠风香巧代云梦曼幼翠友巧听寒梦柏醉易访旋亦玉凌萱访卉怀亦笑蓝春翠靖柏夜蕾冰夏梦松书雪乐枫念薇靖雁寻春恨山从寒忆香觅波静曼凡旋以亦念露芷蕾千兰新波代真新蕾雁玉冷卉紫山千琴恨天傲芙盼山怀蝶冰兰山柏翠萱乐丹翠柔谷山之瑶冰露尔珍谷雪乐萱涵菡海莲傲蕾青槐冬儿易梦惜雪宛海之柔夏青亦瑶妙菡春竹修杰伟诚建辉晋鹏天磊绍辉泽洋明轩健柏煊昊强伟宸博超君浩子骞明辉鹏涛炎彬鹤轩越彬风华靖琪明诚高格光华国源宇晗昱涵润翰飞翰海昊乾浩博和安弘博鸿朗华奥华灿嘉慕坚秉建明金鑫锦程瑾瑜鹏经赋景同靖琪君昊俊明季同开济凯安康成乐语力勤良哲理群茂彦敏博明达朋义彭泽鹏举濮存溥心璞瑜浦泽奇邃祥荣轩';</span></span><br><span class="line"><span class="keyword">DECLARE</span> return_str varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'';</span></span><br><span class="line"><span class="meta"># 一个中文的长度是 3 位</span></span><br><span class="line"><span class="keyword">DECLARE</span> first_name_length int <span class="keyword">DEFAULT</span> LENGTH(first_name) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> last_name_length int <span class="keyword">DEFAULT</span> LENGTH(last_name) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(last_name, FLOOR(<span class="number">1</span> + RAND() * last_name_length), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(first_name, FLOOR(<span class="number">1</span> + RAND() * first_name_length), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span> RAND() &gt; <span class="number">0.400</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(first_name, FLOOR(<span class="number">1</span> + RAND() * first_name_length), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机手机号</span><br><span class="line">CREATE DEFINER=`root`@`localhost` FUNCTION `generatePhone`() RETURNS char(<span class="number">11</span>) CHARSET utf8</span><br><span class="line">    DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">#Routine body goes here...</span><br><span class="line">DECLARE head VARCHAR(<span class="number">256</span>) DEFAULT '<span class="number">133</span>、<span class="number">153</span>、<span class="number">180</span>、<span class="number">181</span>、<span class="number">189</span>、<span class="number">177</span>、<span class="number">173</span>、<span class="number">149</span>、<span class="number">130</span>、<span class="number">131</span>、<span class="number">132</span>、<span class="number">155</span>、<span class="number">156</span>、<span class="number">145</span>、<span class="number">185</span>、<span class="number">186</span>、<span class="number">176</span>、<span class="number">175</span>、<span class="number">134</span>、<span class="number">135</span>、<span class="number">136</span>、<span class="number">137</span>、<span class="number">138</span>、<span class="number">139</span>、<span class="number">150</span>、<span class="number">151</span>、<span class="number">152</span>、<span class="number">157</span>、<span class="number">158</span>、<span class="number">159</span>、<span class="number">182</span>、<span class="number">183</span>、<span class="number">184</span>、<span class="number">187</span>、<span class="number">188</span>、<span class="number">147</span>、<span class="number">178</span>';</span><br><span class="line">DECLARE content CHAR(<span class="number">10</span>) DEFAULT '<span class="number">0123456789</span>';</span><br><span class="line">DECLARE phone CHAR(<span class="number">11</span>) DEFAULT substring( head, <span class="number">1</span> + ( FLOOR(( RAND() * <span class="number">37</span> ))* <span class="number">4</span> ), <span class="number">3</span> );</span><br><span class="line">DECLARE i int DEFAULT <span class="number">1</span>;</span><br><span class="line">  DECLARE len int DEFAULT LENGTH(content);</span><br><span class="line"></span><br><span class="line">WHILE i &lt;= <span class="number">8</span> DO</span><br><span class="line">SET i = i + <span class="number">1</span>;</span><br><span class="line">SET phone = CONCAT(phone, substring( content, floor( <span class="number">1</span> + RAND() * len ), <span class="number">1</span> ));</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">RETURN phone;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成随机'yyyy-MM-dd'至'yyyy-MM-dd'时间</span></span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`localhost`</span> <span class="keyword">FUNCTION</span> <span class="string">`generateDateTime`</span>(begin_time <span class="built_in">char</span>(<span class="number">10</span>), end_time <span class="built_in">char</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> datetime</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">#Routine body goes here...</span></span><br><span class="line"><span class="keyword">DECLARE</span> date_time <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> local_date <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> local_time <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> local_date = <span class="built_in">DATE</span>(FROM_UNIXTIME( <span class="keyword">UNIX_TIMESTAMP</span>( begin_time ) + <span class="keyword">FLOOR</span>( <span class="keyword">RAND</span>() * ( <span class="keyword">UNIX_TIMESTAMP</span>( end_time ) - <span class="keyword">UNIX_TIMESTAMP</span>( begin_time ) + <span class="number">1</span> ) )));</span><br><span class="line"><span class="keyword">SET</span> local_time = <span class="keyword">CONCAT</span>(local_time, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">24</span>), <span class="string">':'</span>, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">60</span>), <span class="string">':'</span>, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">60</span>));</span><br><span class="line"><span class="keyword">SET</span> date_time = <span class="keyword">CONCAT</span>(local_date, <span class="string">' '</span>, local_time);</span><br><span class="line"></span><br><span class="line">RETURN date_time;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>（5）创建存储过程</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="symbol">`root`</span>@<span class="symbol">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="symbol">`generateBigDataUser`</span>(<span class="keyword">IN</span> num INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">#Routine body goes here...</span><br><span class="line"></span><br><span class="line">#申明变量i,默认为<span class="number">1</span></span><br><span class="line"><span class="keyword">DECLARE</span> i INT DEFAULT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#当i小于传入的参数时执行循环插入</span><br><span class="line">WHILE  i &lt;= num  DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`big_data_user_memory`</span>(<span class="symbol">`user_id`</span>, <span class="symbol">`user_name`</span>, <span class="symbol">`age`</span>, <span class="symbol">`gender`</span>, <span class="symbol">`phone`</span>, <span class="symbol">`group_id`</span>, <span class="symbol">`join_time`</span>, <span class="symbol">`gmt_create`</span>, <span class="symbol">`gmt_modified`</span>) <span class="keyword">VALUES</span> (generateCode(<span class="number">20</span>), generateUserName(), <span class="number">18</span> + <span class="built_in">FLOOR</span>(RAND() * <span class="number">50</span>), <span class="built_in">FLOOR</span>(RAND() * <span class="number">2</span>), generatePhone(), <span class="built_in">FLOOR</span>(RAND() * <span class="number">100</span>), generateDateTime(<span class="string">'1990-01-01'</span>, <span class="string">'2019-08-15'</span>), DATE(NOW() - INTERVAL (<span class="built_in">FLOOR</span>(rand() * <span class="number">1000</span> )) DAY), NOW());</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>（6）调用存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> generateBigDataUser(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>在调用存储过程的过程中内存表大小的问题抛出 “The table ‘big_data_memory’ is full”，这是就需要我们修改一下 MySQL 的配置信息。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看 tmp_table_size 大小, tmp_table_size: 控制内存临时表的最大值, 超过限值后就往硬盘写, 写的位置由变量 tmpdir 决定 </span><br><span class="line">mysql&gt; SHOW <span class="keyword">variables</span> like <span class="comment">'%tmp_table_size%'</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 查看 max_heap_table_size 大小, max_heap_table_size: 用户可以创建的内存表 (memory <span class="keyword">table</span>) 的大小. 这个值用来计算内存表的最大行数值</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">'%max_heap_table_size%'</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 修改 tmp_table_size 大小</span><br><span class="line">mysql&gt; <span class="keyword">SET</span> SESSION <span class="comment">tmp_table_size = 1024 * 1024 * 1024</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 修改 max_heap_table_size 大小</span><br><span class="line">mysql&gt; <span class="keyword">SET</span> SESSION <span class="comment">max_heap_table_size = 1024 * 1024 * 1024</span>;</span><br></pre></td></tr></table></figure><p>（7）将内存表中的数据导入普通表</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> big_data_user <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user_memory;</span><br></pre></td></tr></table></figure><p>以上，我们通过存储过程快速产生百万条随机测试数据的工作就大功告成了。接下来，我们将用我们产生的数据为基础详解 EXPLIAN 用法以及各字段含义。</p><p>（8）准备关联查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_group`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`group_code`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组编码'</span>,</span><br><span class="line">  <span class="string">`number_of_people`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'人数'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="symbol">`root`</span>@<span class="symbol">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="symbol">`generateBigDataGroup`</span>(<span class="keyword">IN</span> num INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">#Routine body goes here...</span><br><span class="line"><span class="keyword">DECLARE</span> i INT DEFAULT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#当i小于传入的参数时执行循环插入</span><br><span class="line">WHILE  i &lt;= num  DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`big_data_group`</span>(<span class="symbol">`group_code`</span>, <span class="symbol">`number_of_people`</span>, <span class="symbol">`gmt_create`</span>, <span class="symbol">`gmt_modified`</span>) <span class="keyword">VALUES</span> (generateCode(<span class="number">15</span>), <span class="built_in">FLOOR</span>(RAND() * <span class="number">10000</span>), DATE(NOW() - INTERVAL (<span class="built_in">FLOOR</span>(rand() * <span class="number">1000</span> )) DAY), NOW());</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">CALL</span> generateBigDataGroup(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="EXPLIAN-用法以及各字段含义"><a href="#EXPLIAN-用法以及各字段含义" class="headerlink" title="EXPLIAN 用法以及各字段含义"></a>EXPLIAN 用法以及各字段含义</h2><p>EXPLIAN 模拟优化器执行 SQL 语句，在 5.6 以及以后的版本中，除过 SELECT，其他比如 INSERT，UPDATE 和 DELETE 均可以使用 EXPLIAN 查看执行计划，从而知道 MySQL 是如何处理 SQL 语句，分析查询语句或者表结构的性能瓶颈。 </p><p>本次 EXPLIAN 以根据手机号码过滤测试数据中手机号码重复的、保留 ID 最小数据的滤重 SQL 语句为例子。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">DELETE <span class="keyword">FROM</span> big_data_user WHERE phone <span class="keyword">IN</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> big_data_user bdu1<span class="built_in"> GROUP </span>BY bdu1.phone HAVING count(*)&gt; 1) p) <span class="keyword">AND</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">SELECT id <span class="keyword">FROM</span> (</span><br><span class="line">SELECT min(bdu2.id) <span class="keyword">FROM</span> big_data_user bdu2<span class="built_in"> GROUP </span>BY bdu2.phone HAVING count(*)&gt; 1) b);</span><br></pre></td></tr></table></figure><p><img src="/media/15657628227946/20190815153622.png" alt="20190815153622"></p><p>EXPLIAN 出来的信息有 12 列，分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra</p><h3 id="id-查询标识"><a href="#id-查询标识" class="headerlink" title="id - 查询标识"></a>id - 查询标识</h3><p>查询标识，表示 SQL 语句中执行 SELECT 子句或者是操作的顺序。</p><ol><li>id 相同时执行顺序从上至下。</li><li>id 不同时，如果是子查询，id 的序号会递增，序号越大的越先执行。</li><li>id 相同，不同都存在时，id 相同的可以认为是一组查询按从上至下的顺序执行，id 值越大越优先执行。</li><li>id 为 NULL，如果行引用其他行的联合结果，则值可以为 NULL。在这种情况下，表列显示像 &lt;unionM,N&gt; 这样的值，以指示该行引用 id 值为 M 和 N 的行的并。</li></ol><h3 id="select-type-查询类型"><a href="#select-type-查询类型" class="headerlink" title="select_type - 查询类型"></a>select_type - 查询类型</h3><p>查询类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询。</p><ul><li>SIMPLE：简单的 select 查询，查询中不包含子查询或者 UNION</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为 PRIMARY</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> *, (<span class="keyword">SELECT</span> group_code <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">group_id</span>) <span class="keyword">AS</span> group_code <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>SUBQUERY：在 SELECT 或 WHERE 列表中包含了子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">group_id</span> = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> group_code=<span class="string">'cqlhc1nBKNAlOTQ'</span>);</span><br></pre></td></tr></table></figure><ul><li>DEPENDENT SUBQUERY：在 SELECT 或 WHERE 列表中包含了子查询，该子查询依赖外层查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> *, (<span class="keyword">SELECT</span> group_code <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">group_id</span>) <span class="keyword">AS</span> group_code <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>DERIVED：在 FROM 列表中包含的子查询被标记为 DERIVED（衍生），MySQL 会递归执行这些子查询，把结果放在临时表中</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">LIMIT</span> <span class="number">5</span>) <span class="keyword">AS</span> bdu</span><br></pre></td></tr></table></figure><ul><li>UNION：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为DERIVED</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id = <span class="string">'Jt2BHyxQqsPBoZAO9adp'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> phone = <span class="string">'13982711661'</span>;</span><br></pre></td></tr></table></figure><ul><li>UNION RESULT：从 UNION 表获取结果的 SELECT</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id = <span class="string">'Jt2BHyxQqsPBoZAO9adp'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> phone = <span class="string">'13982711661'</span>;</span><br></pre></td></tr></table></figure><h3 id="table-查询涉及表"><a href="#table-查询涉及表" class="headerlink" title="table - 查询涉及表"></a>table - 查询涉及表</h3><p>查询涉及表，显示这一行的数据是关于哪张表的。这也可以是下列值之一：</p><ul><li>&lt;unionM,N&gt;：输出行引用了 id 值为 M 和 N 的行的 UNION 结果。 </li><li>&lt; derivedN &gt;：该行引用了一个 id 值为 n 的行的派生表结果。 </li><li>&lt; subqueryN &gt;：输出行引用了 id 值为 N 的行的物化子查询的结果。</li></ul><h3 id="partitions-匹配到的分区信息"><a href="#partitions-匹配到的分区信息" class="headerlink" title="partitions - 匹配到的分区信息"></a>partitions - 匹配到的分区信息</h3><p>匹配到的分区信息，由查询匹配记录的分区。对于非分区表，值为 NULL。</p><h3 id="type-连接类型"><a href="#type-连接类型" class="headerlink" title="type - 连接类型"></a>type - 连接类型</h3><p>连接类型，对表访问方式，表示 MySQL 在表中找到所需行的方式，又称 “访问类型”。常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）。SQL 性能优化的目标：至少要达到  range 级别，要求是 ref 级别，如果可以是 consts<br>最好。</p><ul><li>system: 表中只有一条数据， 这个类型是特殊的 const 类型。</li><li>const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>eq_ref: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，查询效率较高。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user bdu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> big_data_group bdg <span class="keyword">ON</span> bdu.group_id = bdg.id;</span><br></pre></td></tr></table></figure><ul><li>ref: 此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了最左前缀规则索引的查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>index: 表示全索引扫描 (full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引，而不扫描数据。index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。例如下面这个例子：EXPLAIN SELECT id FROM big_data_user;</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> big_data_user;</span><br></pre></td></tr></table></figure><ul><li>ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user;</span><br></pre></td></tr></table></figure><h3 id="possible-keys-可能选择的索引"><a href="#possible-keys-可能选择的索引" class="headerlink" title="possible_keys - 可能选择的索引"></a>possible_keys - 可能选择的索引</h3><p>可能选择的索引，它表示 MySQL 在查询时，可能使用到的索引。 注意，即使有些索引在 possible_keys 中出现，但是并不表示此索引会真正地被 MySQL 使用到。 MySQL 在查询时具体使用了哪些索引，由 key 字段决定。</p><h3 id="key-实际使用的索引"><a href="#key-实际使用的索引" class="headerlink" title="key - 实际使用的索引"></a>key - 实际使用的索引</h3><p>实际使用的索引，实际使用的索引，如果为null，则没有使用索引，因此会出现possible_keys列有可能被用到的索引，但是key列为null，表示实际没用索引。</p><h3 id="key-len-实际使用的索引的长度"><a href="#key-len-实际使用的索引的长度" class="headerlink" title="key_len - 实际使用的索引的长度"></a>key_len - 实际使用的索引的长度</h3><p>实际使用的索引的长度，表示索引中使用的字节数，而通过该列计算查询中使用的索引长度，在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得而不是通过表内检索出的。</p><h3 id="ref-和索引进行比较的列"><a href="#ref-和索引进行比较的列" class="headerlink" title="ref - 和索引进行比较的列"></a>ref - 和索引进行比较的列</h3><p>和索引进行比较的列，表示哪些列或常量与键列中命名的索引相比较，以从表中选择行。 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user bdu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> big_data_group bdg <span class="keyword">ON</span> bdu.group_id = bdg.id;</span><br></pre></td></tr></table></figure><h3 id="rows-需要被检索的大致行数"><a href="#rows-需要被检索的大致行数" class="headerlink" title="rows - 需要被检索的大致行数"></a>rows - 需要被检索的大致行数</h3><p>需要被检索的大致行数，根据表统计信息及索引选用情况，大只估算出找到所需的记录所需要读取的行数。</p><h3 id="filtered-按表条件过滤的行百分比"><a href="#filtered-按表条件过滤的行百分比" class="headerlink" title="filtered - 按表条件过滤的行百分比"></a>filtered - 按表条件过滤的行百分比</h3><p>按表条件过滤的行百分比，该列表示将被表条件过滤的表行的估计百分比。 最大值为100，这意味着没有发生行过滤。值从100下降表明过滤量增加。</p><h3 id="Extra-额外信息"><a href="#Extra-额外信息" class="headerlink" title="Extra - 额外信息"></a>Extra - 额外信息</h3><p>额外信息，不适合在其他字段中显示，但是十分重要的额外信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">DELETE <span class="keyword">FROM</span> big_data_user WHERE phone <span class="keyword">IN</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> big_data_user bdu1<span class="built_in"> GROUP </span>BY bdu1.phone HAVING count(*)&gt; 1) p) <span class="keyword">AND</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">SELECT id <span class="keyword">FROM</span> (</span><br><span class="line">SELECT min(bdu2.id) <span class="keyword">FROM</span> big_data_user bdu2<span class="built_in"> GROUP </span>BY bdu2.phone HAVING count(*)&gt; 1) b);</span><br></pre></td></tr></table></figure><ul><li>Using filesort : 表示 MySQL 需额外的排序操作，不能通过索引顺序达到排序效果，MySQL Query Optimizer 不得不选择相应的排序算法来实现。一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大。</li><li>Using temporary :  使用了临时表保存中间结果，MySQL 在对查询结果排序时使用了临时表。常见于 order by， group by， join 操作，查询效率不高，建议优化。</li><li>Using index : 发生了索引覆盖 ， 查询时在索引树上取到了需要查询的数据，不需要再进行回行操作。</li><li>Using join buffer : 使用了连接缓存，Block Nested Loop，连接算法是块嵌套循环连接；Batched Key Access，连接算法是批量索引连接。</li><li>Using where : 表示 MySQL 服务器从存储引擎收到查询数据，再进行 “后过滤”（Post-filter）。所谓 “后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为 “后过滤”。注意：Extra 列出现 Using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤。</li><li>Impossible WHERE : where 子句的值总是 false，不能用来获取任何数据。</li><li>distinct : 查找 distinct 值，当 MySQL 找到了第一条匹配的结果时，将停止该值的查询，转为后面其他值查询。</li></ul><h2 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h2><p>想要优化 SQL，必须清楚知道 SQL 的执行顺序，这样再配合 explain 才能事半功倍！</p><p>完整 SQL 语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> </span><br><span class="line">    &lt;select_list&gt;</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">join</span> &lt;right_table&gt; <span class="keyword">on</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">    &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">limit</span> &lt;<span class="keyword">limit</span> <span class="keyword">number</span>&gt;</span><br></pre></td></tr></table></figure><p>SQL 执行顺序：</p><p>1、from &lt;left_table&gt;&lt;join_type&gt;<br>2、on &lt;join_condition&gt;<br>3、&lt;join_type&gt; join &lt;right_table&gt;<br>4、where &lt;where_condition&gt;<br>5、group by &lt;group_by_list&gt;<br>6、having &lt;having_condition&gt;<br>7、select<br>8、distinct &lt;select_list&gt;<br>9、order by &lt;order_by_condition&gt;<br>10、limit &lt;limit_number&gt;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用 EXPLAIN 解析 SQL 执行计划时，如果有下面几种情况，就需要特别关注下了：</p><ul><li>首先看下 type 这列的结果，如果有类型是 ALL 时，表示预计会进行全表扫描（full table scan）。通常全表扫描的代价是比较大的，建议创建适当的索引，通过索引检索避免全表扫描。</li><li>再来看下 Extra 列的结果，如果有出现 Using temporary 或者 Using filesort 则要多加关注：Using temporary，表示需要创建临时表以满足需求，通常是因为 GROUP BY 的列没有索引，或者 GROUP BY 和 ORDER BY 的列不一样，也需要创建临时表，建议添加适当的索引；Using filesort，表示无法利用索引完成排序，也有可能是因为多表连接时，排序字段不是驱动表中的字段，因此也没办法利用索引完成排序，建议添加适当的索引；Using where，通常是因为全表扫描或全索引扫描时（type 列显示为 ALL 或 index），又加上了 WHERE 条件，建议添加适当的索引；其他状态例如：Using index、Using index condition、Using index for group-by 则都还好，不用紧张。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://cmsblogs.com/?p=2818" target="_blank" rel="noopener">MySQL 的索引是什么？怎么优化？</a><br>[2]. <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a><br>[3]. <a href="https://blog.csdn.net/qq_16946803/article/details/81870174" target="_blank" rel="noopener">MySQL 快速生成 100W 条测试数据</a><br>[4]. <a href="https://www.cnblogs.com/wangfengming/articles/8275448.html" target="_blank" rel="noopener">MySQL EXPLAIN 详解</a><br>[5]. <a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">MySQL 高级 之 explain 执行计划详解</a></p><hr><h2 id="MySQL-进阶讲解系列"><a href="#MySQL-进阶讲解系列" class="headerlink" title="MySQL 进阶讲解系列"></a>MySQL 进阶讲解系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="46faebc7.html">MySQL 进阶讲解（二）：快速生成测试数据以及 EXPLAIN 详解</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的 IO 成本。MySQL 在 300w 条记录左右性能开始逐渐下降，虽然官方文档说 500~800w 记录，所以大数据量建立索引是非常有必要的。MySQL 提供了 EXPLAIN，用于显示 SQL 执行的详细信息，可以进行索引的优化。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的查询语句或是表结构的性能瓶颈。 可以帮助选择更好的索引和写出更优化的查询语句。&lt;/p&gt;
&lt;p&gt;本章首先介绍如何通过存储过程随机生成大量随机数据作为 EXPLIAN 的测试数据，然后通过例子详解 EXPLIAN 用法以及各字段含义，最后对 EXPLIAN 用途进行总结。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.maoning.pro/categories/MySQL/"/>
    
    
      <category term="索引" scheme="http://blog.maoning.pro/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="EXPLAIN" scheme="http://blog.maoning.pro/tags/EXPLAIN/"/>
    
  </entry>
  
  <entry>
    <title>Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</title>
    <link href="http://blog.maoning.pro/archives/14348371.html"/>
    <id>http://blog.maoning.pro/archives/14348371.html</id>
    <published>2019-07-13T06:39:44.000Z</published>
    <updated>2019-11-20T11:09:41.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过 Redis 深度探险系列的学习相信大家对 Redis 的数据结构、对象、持久化机制、过期键删除策略等知识有了大致的了解，本篇博文主要讲述 Redis 的安装步骤，然后介绍一下 Redis 配置说明，最后对 Redis 集群搭建进行详细的讲解。</p><a id="more"></a><h2 id="单机环境搭建"><a href="#单机环境搭建" class="headerlink" title="单机环境搭建"></a>单机环境搭建</h2><h3 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h3><p>Mac 中使用 brew 安装 Redis 的方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>redis</span><br></pre></td></tr></table></figure><h3 id="Linux-安装-Redis"><a href="#Linux-安装-Redis" class="headerlink" title="Linux 安装 Redis"></a>Linux 安装 Redis</h3><p><strong>Ubuntu 中使用 apt-get 安装 Redis 的方法</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install redis-server</span><br></pre></td></tr></table></figure><p><strong>CentOS7 中使用 yum 安装 Redis 的方法</strong></p><ol><li>检查 Redis 版本</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 yum <span class="meta">info</span> redis 可知 Centos7 中 Redis 源的版本为<span class="number">3</span>.<span class="number">2</span>.<span class="number">12</span></span><br><span class="line">$ yum <span class="meta">info</span> redis</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 Redis 数据库</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum <span class="keyword">install</span> -y redis</span><br></pre></td></tr></table></figure><ol start="3"><li>启动 Redis 数据库</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="literal">start</span> redis</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 Redis 运行状况</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>systemctl status redis</span><br></pre></td></tr></table></figure><ol start="5"><li>检测 Redis 服务器是否开启</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -ef | <span class="keyword">grep</span> redis</span><br></pre></td></tr></table></figure><ol start="6"><li>通过上述方法安装的 Redis 版本较低，如果想安装最新的 Redis 请执行如下命令</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装 Remi 的软件源</span></span><br><span class="line"><span class="symbol">$</span> yum install -y http:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></span><br><span class="line"><span class="comment">// 更换 yum 源，通过 remi 源安装 Redis</span></span><br><span class="line"><span class="symbol">$</span> yum --enablerepo=remi install -y redis</span><br></pre></td></tr></table></figure><h2 id="Redis-简单配置以及配置说明"><a href="#Redis-简单配置以及配置说明" class="headerlink" title="Redis 简单配置以及配置说明"></a>Redis 简单配置以及配置说明</h2><h3 id="Rdis设置为开启启动"><a href="#Rdis设置为开启启动" class="headerlink" title="Rdis设置为开启启动"></a>Rdis设置为开启启动</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="builtin-name">enable</span> redis.service</span><br></pre></td></tr></table></figure><h3 id="开启远程连接，Redis-默认只能-localhost-访问"><a href="#开启远程连接，Redis-默认只能-localhost-访问" class="headerlink" title="开启远程连接，Redis 默认只能 localhost 访问"></a>开启远程连接，Redis 默认只能 localhost 访问</h3><p>修改 /etc/redis.conf 配置文件，执行 systemctl restart redis 重启 Redis 即生效。</p><ol><li>输入命令 vim /etc/redis.conf 进入编辑模式</li><li>bind 127.0.0.1 修改为 bind 0.0.0.0</li><li>protected-mode yes 修改为 protected-mode no（保护模式，是否只允许本地访问）</li></ol><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>修改 /etc/redis.conf 配置文件，在 requirepass foobared 前面去掉注释，将 foobared 改为自己的密码，我在这里改为 requirepass foobared，执行 systemctl restart redis 重启 Redis 即生效。</p><h3 id="在线变更配置"><a href="#在线变更配置" class="headerlink" title="在线变更配置"></a>在线变更配置</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过 redis-<span class="keyword">cli</span> 连接 redis 客户端，使用 AUTH 进行认证</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; auth foobared</span><br><span class="line">// 获取当前配置</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG GET *</span><br><span class="line">// 修改密码为 root</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG SET requirepass root</span><br><span class="line">// 将修改后的配置写入配置文件</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG REWRITE</span><br></pre></td></tr></table></figure><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><p> <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf </a> 以及Redis 配置文件 redis.conf 中文详解：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Redis 配置文件例子.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 注意: 为了能读取到配置文件, Redis 服务必须以配置文件的路径作为第一个参数启动:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># ./redis-server /path/to/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 单位说明: 当需要指定内存大小时, 可能会使用到不同的单位, 如 1k、5GB、4M 等, 这里给出其单位含义:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="meta"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 单位是大小写不敏感的 所以 1GB 1Gb 1gB 是一样的.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果你拥有一个标准的配置模板, 并且希望在该模板之上做一些个性化的修改, 你可以使用 include 指令来引入其他的配置文件.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 注意:"include" 不会被 admin 或者 Redis Sentinel "CONFIG REWRITE" 命令覆盖.</span></span><br><span class="line"><span class="meta"># 由于 redis 以最终的配置作为实际配置, 因此我们希望你将 include 命令放置在配置文件的最前面以防配置被覆盖.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果你打算使用另外的 conf 文件来覆盖当前文件的配置, 那么最好将 include 指令放置到该文件的末尾. </span></span><br><span class="line"><span class="meta"># 即最后生效原则, 最后被解析的配置将作为最后的配置.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># include /path/to/local.conf</span></span><br><span class="line"><span class="meta"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## MODULES #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动时加载模块. 如果服务器无法加载模块, 它将中止. 可以使用多个 loadmodule 指令.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># loadmodule /path/to/my_module.so</span></span><br><span class="line"><span class="meta"># loadmodule /path/to/other_module.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## NETWORK #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下 redis 会在所有的可用网络接口中进行监听, 如果你想让 redis 在指定的网络接口中</span></span><br><span class="line"><span class="meta"># 监听, 那么可以使用 bind 命令来指定 redis 的监听接口.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 例如:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="meta"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># ~~~ 警告 ~~~ 如果允许所有的网络接口访问 Redis, 这样做是很危险的, 如果你只是需要本机访问 </span></span><br><span class="line"><span class="meta"># 可以指定特定的 127.0.0.1, 如果需要外网访问, 请配置防火墙策略.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="meta"># JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="meta"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否开启保护模式, 默认开启. 要是配置里没有指定 bind 和密码.</span></span><br><span class="line"><span class="meta"># 开启该参数后, redis 只会本地进行访问, 拒绝外部访问.</span></span><br><span class="line"><span class="meta"># 要是开启了密码和 bind, 可以开启. 否则最好关闭, 设置为 no.</span></span><br><span class="line"><span class="keyword">protected</span>-mode yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在指定的端口上进行监听, 默认是 6379.</span></span><br><span class="line"><span class="meta"># 如果端口设置为 0, 那么 redis 就不会在 TCP socket 上进行监听.</span></span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># TCP listen() backlog.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在一个并发量高的环境中, 你需要指定一个比较大的 backlog 值来避免慢连接的情况.</span></span><br><span class="line"><span class="meta"># 注意, linux 内核会默认 使用 / proc/sys/net/core/somaxconn 的值来削减 backlog 的实际值,</span></span><br><span class="line"><span class="meta"># 因此你需要确保提升 somaxconn 和 tcp_max_syn_backlog 这两个值来确保此处的 backlog 生效.</span></span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Unix socket.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 指定 unix sock 的路径来进行连接监听, 默认是不指定, 因此 redis 不会在 unix socket 上进行监听.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># unixsocket /tmp/redis.sock</span></span><br><span class="line"><span class="meta"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭掉空闲 N 秒的连接 (0 则是不处理空闲连接)</span></span><br><span class="line">timeout <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># TCP keepalive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 如果该值不为 0, 将使用 SO_KEEPALIVE 这一默认的做法来向客户端连接发送 TCP ACKs </span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 这样的好处有以下两个原因:</span></span><br><span class="line"><span class="meta"># 1) 检测已经死亡的对端 (译者注: TCP 的关闭会存在无法完成 4 次握手的情况, 如断电, 断网, 数据丢失等等)</span></span><br><span class="line"><span class="meta"># 2) 保持连接在网络环境中的存活</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在 Linux 中, 该指定时间是一次发送 ACKs 的时间片.</span></span><br><span class="line"><span class="meta"># 对于其他内核系统, 其时间片大小与内核配置有关.</span></span><br><span class="line"><span class="meta"># 一个比较合理的值是 300 seconds.Redis 3.2.1 版本之后默认指定该值为 300 seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">tcp-keepalive <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################# GENERAL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># redis 默认不是以一个守护进程来运行的, 使用 yes, 可以让 redis 作为守护进程来运行.</span></span><br><span class="line"><span class="meta"># 注意: 当 redis 作为守护进程的时候 /var/run/redis.pid 作为 pid 文件.</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果需要在机器启动 (upstart 模式 或 systemd 模式) 时就启动 Redis 服务器, 可以通过该选项来配置 Redis.</span></span><br><span class="line"><span class="meta"># 支持的模式:</span></span><br><span class="line"><span class="meta">#supervised no      – 无, 不会与 supervised tree 进行交互</span></span><br><span class="line"><span class="meta"># supervised upstart – 将 Redis 服务器添加到 SIGSTOP 模式中</span></span><br><span class="line"><span class="meta"># supervised systemd – 将 READY=1 写入 $NOTIFY_SOCKET</span></span><br><span class="line"><span class="meta"># supervised auto    - 根据环境变量 UPSTART_JOB 或 NOTIFY_SOCKET 检测 upstart 还是 systemd</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 上述 supervision 方法 (upstart 或 systemd) 仅发出 “程序已就绪” 信号, 不会继续给 supervisor 返回 ping 回复.</span></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果指定了 pid 文件, Redis 会在启动时写该 pid 文件, 在退出时删除该文件.</span></span><br><span class="line"><span class="meta"># 当 Redis 服务器已守护进程启动时, 如果指定了配置文件, 则直接使用, 如果没有指定, 则创建 / var/run/redis.pid 作为配置文件.</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定日志的记录级别的.</span></span><br><span class="line"><span class="meta"># 可以是如下的几个值之一:</span></span><br><span class="line"><span class="meta"># debug (尽可能多的日志信息, 用于开发和测试之中)</span></span><br><span class="line"><span class="meta"># verbose (少但是有用的信息, 没有 debug 级别那么混乱)</span></span><br><span class="line"><span class="meta"># notice (适量的信息, 用于生产环境)</span></span><br><span class="line"><span class="meta"># warning (只有非常重要和关键的信息会被记录)</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定日志文件的位置. 为空时将输出到标准输出设备.</span></span><br><span class="line"><span class="meta"># 如果你在 demo 模式下使用标准输出的日志, 日志将会输出到 /dev/null .</span></span><br><span class="line">logfile /<span class="keyword">var</span>/log/redis/redis.log</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当设置'syslog-enabled'为 yes 时, 允许记录日志到系统日志中.</span></span><br><span class="line"><span class="meta"># 以及你可以使用更多的日志参数来满足你的要求.</span></span><br><span class="line"><span class="meta"># syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定在系统日志中的身份.</span></span><br><span class="line"><span class="meta"># syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定系统日志的能力. 必须是 LOCAL0 到 LOCAL7 之间 (闭区间).</span></span><br><span class="line"><span class="meta"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置数据库的数量. 默认的数据库是 DB 0 使得你可以在每一个连接的基础之上使用 </span></span><br><span class="line"><span class="meta"># SELECT &lt;dbid&gt; 来指定另外的数据库, 但是这个值必须在 0 到'database'-1 之间.</span></span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, Redis 只会在交互模式才显示 ASCII 版本的 logo, 可以通过设置此选项为 yes,</span></span><br><span class="line"><span class="meta"># 来使 Redis 在任何情况下都显示 logo, 使得 Redis 的此行为和 4.0 之前的版本行为保持一致.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line"><span class="meta">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 将 DB 数据保存到磁盘:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 将会在 &lt; seconds&gt; 和 &lt;changes &gt; 两个值同时满足时, 将 DB 数据保存到硬盘中</span></span><br><span class="line"><span class="meta"># 其中 &lt; seconds&gt; 每多少秒,&lt;changes &gt; 是改变的 key 的数量</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在以下的例子中, 将会存在如下的行为:</span></span><br><span class="line"><span class="meta"># 当存在最少一个 key 变更时, 900 秒 (15 分钟) 后保存到硬盘</span></span><br><span class="line"><span class="meta"># 当存在最少 10 个 key 变更时, 300 秒后保存到硬盘</span></span><br><span class="line"><span class="meta"># 当存在最少 1000 个 key 变更时, 60 秒后保存到硬盘</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 提示: 你可以禁用如下的所有 save 行.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 你可以删除所有的 save 然后设置成如下这样的情况.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># save ""</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, 在发生 RDB 快照或 BGSAVE 执行失败的那一刻, Redis 执行接收写请求.</span></span><br><span class="line"><span class="meta"># 这会使用户察觉 (通常比较困难) 到数据没有正确的持久化到磁盘. 否则有可能出现不被察觉的灾难性后果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当后台 BGSAVE 程序可以再次开始工作时, Reidis 会再次自动允许写入.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果已经对 Server 和服务器持久化建立了正确的监控, 那么当你禁用该功能后, 即使磁盘、持久化等出现问题, Redis 也能继续提供服务.</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否在 dump 到 rdb 数据库的时候使用 LZF(一种高效的压缩算法) 来压缩字符串.</span></span><br><span class="line"><span class="meta"># 默认是 yes, 因为这是一个优良的做法.</span></span><br><span class="line"><span class="meta"># 如果你不想耗费你的 CPU 处理能力, 你可以设置为 no, 但是这会导致你的数据会很大.</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 从 RDB 的版本 5 开始, CRC64 校验值会写入到文件的末尾.</span></span><br><span class="line"><span class="meta"># 这会使得格式化过程中, 使得文件的完整性更有保障,</span></span><br><span class="line"><span class="meta"># 但是这会在保存和加载的时候损失不少的性能 (大概在 10%).</span></span><br><span class="line"><span class="meta"># 你可以关闭这个功能来获得最高的性能.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># RDB 文件会在校验功能关闭的时候, 使用 0 来作为校验值, 这将告诉加载代码来跳过校验步骤.</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># DB 的文件名称.</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 工作目录.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DB 将会使用上述'dbfilename'指定的文件名写入到该目录中.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 追加的文件也会在该目录中创建.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 你应该在这里输入的是一个目录而不是一个文件名.</span></span><br><span class="line">dir /<span class="keyword">var</span>/lib/redis</span><br><span class="line"></span><br><span class="line"><span class="meta">################################# REPLICATION #################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 主从复制. 单机模式下, Redis 支持使用 slaveof 命令从另一个 Redis 服务器的拷贝中来创建一个实例.</span></span><br><span class="line"><span class="meta"># 集群模式下则使用 cluster replicate &lt;master-id &gt; 命令. Redis 复制使用前须知:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="meta">#   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="meta">#   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="meta">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1)Redis 复制是异步复制, 但是可以配置连接的从节点数量.</span></span><br><span class="line"><span class="meta"># 2)当连接断开, Redis 从节点支持部分重同步 (psync) 功能来保证主从节点数据同步.</span></span><br><span class="line"><span class="meta"># 3)复制过程是一个自动化过程, 无需人工干预. 当出现网络分区后, 从节点会自动尝试建立与主节点的连接, 并尝试同步.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果主服务器开启了密码保护 (使用下面的 "requirepass" 配置).</span></span><br><span class="line"><span class="meta"># 这个配置就是告诉从服务在发起向主服务器的异步复制的请求之前使用如下的密码进行认证,</span></span><br><span class="line"><span class="meta"># 否则主服务器会拒绝这个请求.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果从服务器失去了和主服务器之间的连接, 或者当复制仍然处于处理状态的时候</span></span><br><span class="line"><span class="meta"># 从服务器做出如下的两个行为:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1) 如果 slave-serve-stale-data 被设置为 yes(默认值), 从服务器将会持续</span></span><br><span class="line"><span class="meta"># 回复来自客户端的请求, 可能会回复已经过期的数据,</span></span><br><span class="line"><span class="meta"># 或者返回空的数据, 当从服务器第一次异步请求数据时.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 2) 如果 slave-serve-stale-data 被设置为 no ,</span></span><br><span class="line"><span class="meta"># 从服务器就会返回 "SYNC with master in progress"</span></span><br><span class="line"><span class="meta"># 这个错误, 来应答所有命令除了 INFO 和 SLAVEOF.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 你可以配置一个从服务器的实例是否接受写请求,</span></span><br><span class="line"><span class="meta"># 从服务器在存储一些短暂的数据的的时候, 接收写请求是一件非常正确的事情</span></span><br><span class="line"><span class="meta"># (因为数据在向主服务器同步之后非常容易擦除) 但是会因为配置不正确而导致一些问题.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 从 redis 2.6 开始默认从服务器是只读的服务器.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 提示: 只读的从服务器并不是设计用来公开给不受信任的互联网客户端的, 它</span></span><br><span class="line"><span class="meta"># 仅仅是一个用来防止对实例进行误操作的保护层. 只读从服务器默认用来输出管理命令</span></span><br><span class="line"><span class="meta"># 例如 CONFIG, DEBUG 和其他. 如果你想限制它的规模, 你可以使用'rename-command'来</span></span><br><span class="line"><span class="meta"># 提高它的安全性, 使得她作为一个影子来执行管理或者危险的命令.</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否使用 socket 方式复制数据. 目前 redis 复制提供两种方式, disk 和 socket.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 对于新连接的 slaves 或断开重连的 slaves 将无法执行 “部分同步”, 需要进行一次完全同步. 当进行完全同步时, 主节点将传播一个 RDB 文件给从节点. 该 RDB 文件的传播方式有两种:</span></span><br><span class="line"><span class="meta"># 1)基于磁盘: Redis 主节点创建一个新进程将 RDB 文件写到磁盘, 然后将生成的 RDB 文件传播给从节点.</span></span><br><span class="line"><span class="meta"># 2)无磁盘: Redis 主节点创建一个新进程直接将 RDB 文件写到 slaves 的套接字中, RDB 文件无需落盘.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 基于磁盘的复制, 一旦 RDB 文件生成, 多个 slaves 将排队等待并可以共享该文件. 而无磁盘复制一旦开始传输数据, 新 slaves 到来后将会排队等待.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在使用无磁盘复制时, 主节点在开始传输同步数据前将根据配置的时间进行等待, 从而实现多个从节点的并发传输.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在磁盘速度缓慢且网络速度很快 (高带宽) 时, 无磁盘复制效率更高. 默认情况下, 无磁盘复制同步关闭.</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 无磁盘复制前, 主节点需要等待的时间. 该配置在启用无磁盘复制时将生效.</span></span><br><span class="line"><span class="meta"># 由于一旦开启一次数据传输, 其余 slaves 将排队等待, 所以最好让主节点等待一段时间, 这样主节点就可对多个 slaves 并发传播数据.</span></span><br><span class="line"><span class="meta"># 等待的单位是秒(second), 默认是 5 秒. 一旦将其设置为 0, 主节点将会马上开始数据传输.</span></span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># slave 根据指定的时间间隔向服务器发送 ping 请求.</span></span><br><span class="line"><span class="meta"># 时间间隔可以通过 repl_ping_slave_period 来设置, 默认 10 秒.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># repl-ping-replica-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 复制连接超时时间. master 和 slave 都有超时时间的设置.</span></span><br><span class="line"><span class="meta"># master 检测到 slave 上次发送的时间超过 repl-timeout, 即认为 slave 离线, 清除该 slave 信息.</span></span><br><span class="line"><span class="meta"># slave 检测到上次和 master 交互的时间超过 repl-timeout, 则认为 master 离线.</span></span><br><span class="line"><span class="meta"># 需要注意的是 repl-timeout 需要设置一个比 repl-ping-slave-period 更大的值,</span></span><br><span class="line"><span class="meta"># 不然会经常检测到超时.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 以下情境将使用到复制超时阈值:</span></span><br><span class="line"><span class="meta"># 1) 从节点在执行 SYNC 期间, 检测块文件传输超时.</span></span><br><span class="line"><span class="meta"># 2) 从节点检测主节点离线(data、pings).</span></span><br><span class="line"><span class="meta"># 3) 主节点检测从节点离线(REPLCONF ACK).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 必须要确保复制超时阈值 (repl-timeout) 大于 slaves 定时向 master 发送 PING 的时间片(repl-ping-slave-period),</span></span><br><span class="line"><span class="meta"># 否则将总会检测到复制超时(当 slave 发送 PING 的时间片大于复制超时阈值时, slave 还未发送 ping 就会被定性为复制超时).</span></span><br><span class="line"><span class="meta"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 执行完 SYNC 后, 是否要禁用 TCP_NODELAY.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当禁用该功能后, Redis 会使用占用更少带宽的小 TCP 包向从节点发送数据.</span></span><br><span class="line"><span class="meta"># 但是这样做将会增大从节点端数据传输延时. 在 Linux 下禁用 TCP_NODELAY 功能将导致 40 微秒的延迟.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当启动该功能后, 在进行复制时将会减少数据传输延迟, 但是会占用更大的带宽.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 我们优先选择低延迟, 但是在高速网络或主从节点存在多 hops 路径时, 建议禁用 TCP_NODELAY 功能.</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置复制积压缓冲区 (replication backlog) 大小. 当 slaves 断开与节点连接后, Redis 使用复制积压缓冲区记录需要未发送给 slave 的数据.</span></span><br><span class="line"><span class="meta"># 当从节点重连后, 仅需执行一次部分同步, 将从节点缺失数据补全.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 复制积压缓冲区 (replication backlog) 越大, Redis 可以支持的 slave 离线时间就越长. 复制积压缓冲区用于部分重同步.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 复制缓冲区只有在有 slave 连接时才分配内存. 没有 slave 时, 该内存会被释放出来, 默认大小为 1m.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># repl-backlog-size 1mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当主节点不再有新连接的从节点后, 复制积压缓冲区将会被释放.</span></span><br><span class="line"><span class="meta"># 为避免因从节点频繁掉线后上线而频繁的进行复制积压缓冲区的释放与申请, Redis 提供复制积压缓冲区释放时间片 (repl-backlog-ttl) 参数, 保证主节点在检测到从节点掉线后的规定时间内不会释放该缓冲区.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 值为零时表示不会释放该复制积压缓冲区, 单位为秒.</span></span><br><span class="line"><span class="meta"># 单位为秒, 配置如下:</span></span><br><span class="line"><span class="meta"># repl-backlog-ttl 3600</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用整数表示从节点优先级.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当主节点无法正常工作后, Sentinel 将使用该优先级在从节点中推选出新的主节点.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 优先级对应的整数值越小, 被推选成主节点的可能性更大. 但是当优先级的值为零时表示该从节点不具备成为主节点的身份.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认优先级为 100.</span></span><br><span class="line">slave-priority <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当主节点的已连接从节点数小于 N 且这些从节点延迟均大于 M 秒, 该主节点将停止接收写请求.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点处于 “online” 状态, 当且仅当延迟 (通过计算距离上一次接收从节点的 ping 消息的时间间隔获得) 小于指定的阈值.</span></span><br><span class="line"><span class="meta"># 这个选项配置不是用来保证 N 个部分接收写信息, 而是为了在没有足够的从节点可用时, 限制写丢失.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如需要至少需要 3 个从节点并在 10s 内可用, 则设置:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 延迟小于 min-slaves-max-lag 秒的 slave 才认为是健康的 slave.</span></span><br><span class="line"><span class="meta"># min-slaves-to-write 3</span></span><br><span class="line"><span class="meta"># 设置 1 或另一个设置为 0 禁用这个特性.</span></span><br><span class="line"><span class="meta"># min-slaves-max-lag 10</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一旦对这两个中的一个赋值为零, 则该功能失效.</span></span><br><span class="line"><span class="meta"># 默认 min-slaves-to-write 参数设置为 0, 即该功能默认不启用.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 主节点可以通过多种途径显示已连接从节点的 IP 和 port. 如 Sentinel 可以使用 “INFO replication” 命令来发现从节点实例；</span></span><br><span class="line"><span class="meta"># Master 可以使用 “ROLE” 命令显示从节点 IP 和 port 信息等.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># slave 获取 IP 和 port 的方式是:</span></span><br><span class="line"><span class="meta"># IP: 自动检测获取. 当从节点连接主节点时, 通过检查对应套接字地址获取.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#Port: 从节点在复制中和主节点握手时需要使用到 port. 通常情况下, port 即为连接时的 port.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 但是, 当发生端口转发(port forwarding, 转发一个网络端口从一个网络节点到另一个网络节点的行为)</span></span><br><span class="line"><span class="meta"># 或使用 NAT(Network Address Translation, 网络地址转换)技术是, 从节点需要被分配不同 IP 和 port 后才能被访问.</span></span><br><span class="line"><span class="meta"># 接下来的两个配置用来设置从节点的 IP 和 port, 用来告知主节点所指定的 IP 和 port, 这样 INFO 和 ROLE 才能继续返回结果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当需要重写 IP 和 port 时, 则无需配置该选项.</span></span><br><span class="line"><span class="meta"># slave-announce-ip 5.5.5.5</span></span><br><span class="line"><span class="meta"># slave-announce-port 1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Server 在处理客户端命令前, 该客户端需要提供提供认证密码. 这在非可信网络环境中很有用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为减少后台执行复杂度, 这个选项一般都会被注释掉. 因为大多数用户不需要授权.(如用户使用自己的服务器)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Warning: 由于 Redis 执行高效, 所以外部用户每秒可以尝试认证 15w 次.</span></span><br><span class="line"><span class="meta"># 也就是说, 为避免密码被快送攻破, 用户需要使用一个极其复杂的密码.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># requirepass foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 重命名命令.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在一个共享环境中有必要对危险命令进行重命令, 从而避免危险命令的滥用、无用.</span></span><br><span class="line"><span class="meta"># 如给 CONFIG 命令重新设置一个难以猜测的命令, 这样这个命令就很难被普通用户使用的, 但仍能被内部工具使用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 设置成一个空的值, 可以禁止一个命令.</span></span><br><span class="line"><span class="meta"># rename-command CONFIG ""</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 一定要避免重命名那些写 AOF 文件或传输数据给 slaves 的命令, 否则将会导致各种难以预料的错误.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################### CLIENTS ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置能连上 redis 的最大客户端连接数量. 默认是 10000 个客户端连接.</span></span><br><span class="line"><span class="meta"># 由于 redis 不区分连接是客户端连接还是内部打开文件或者和 slave 连接等,</span></span><br><span class="line"><span class="meta"># 所以 maxclients 最小建议设置到 32. 如果超过了 maxclients,</span></span><br><span class="line"><span class="meta"># redis 会给新的连接发送’max number of clients reached’, 并关闭连接.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################## MEMORY MANAGEMENT ################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># redis 配置的最大内存容量. 不要再内存超过指定限制时仍然使用内存.</span></span><br><span class="line"><span class="meta"># 当达到内存上限时, Redis 会根据选定的过期键策略移除一些 key.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果根据过期键策略仍不能移除一些键或者过期键策略设置成 “noeviction”(不启用过期键策略),</span></span><br><span class="line"><span class="meta"># 那么 Redis 会向如 SET、LPUSH 等使用内存的命令返回错误, 向诸如 GET 等读命令正常返回结果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 这个配置通常在将 Redis 当过 LRU 缓存或对以设置硬性的内存上限的 Redis 很适用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># WARNING: slaves 的输出缓冲区不在主节点的 maxmemory 计算中, 所以设置的 maxmemory 不宜过大.</span></span><br><span class="line"><span class="meta"># 如果过大, 可能导致主机的剩余内存过小, 从而不能预留足够的内存用于创建 slaves 的输出缓冲区.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 简言之, 如果当前节点存在已连接的从节点, 建立设置一个较小的 maxmemory 上限, 这样系统就可以有多余的 RAM 用与创建从节点输出缓存.(当过期键策略设置成'noeviction'时, 则没有必要这么做)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 内存容量超过 maxmemory 后的处理策略. Redis 提供五种内存淘汰策略:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># volatile-lru -&gt; 利用 LRU 算法移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-lru -&gt; 利用 LRU 算法移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-lfu -&gt; 利用 LFU 算法移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-lfu -&gt; 利用 LFU 算法移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-random -&gt; 随机移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-random -&gt; 随机移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-ttl -&gt; 移除即将过期的 key, 根据最近过期时间来删除 (辅以 TTL)</span></span><br><span class="line"><span class="meta"># noeviction -&gt; 不移除任何 key, 只是返回一个写错误.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 上面的这些驱逐策略, 如果 redis 没有合适的 key 驱逐, 对于写命令, 还是会返回错误.</span></span><br><span class="line"><span class="meta"># redis 将不再接收写请求, 只接收 get 请求. 写命令包括: set setnx</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory-policy noeviction</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># lru 检测的样本数. 使用 lru 或者 ttl 淘汰算法, 从需要淘汰的列表中随机选择 sample 个 key,</span></span><br><span class="line"><span class="meta"># 选出闲置时间最长的 key 移除.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, Redis 会从五个键中选择一个最近最久未使用的键进行淘汰. 可以通过配置该选择设置检测基数.</span></span><br><span class="line"><span class="meta"># 一般情况下, 五个检测样本可以获得足够好的结果. 10 个样本的结果更接近 LRU 算法, 但是会消耗更多的 CPU.</span></span><br><span class="line"><span class="meta"># 3 个样本可以获得较高的执行速度但是不够精确.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory-samples 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 从 Redis 5 开始, 默认情况下, replica 节点会忽略 maxmemory 设置(除非在发生 failover 后, 此节点被提升为 master 节点).</span></span><br><span class="line"><span class="meta"># 这意味着只有 master 才会执行过期删除策略, 并且 master 在删除键之后会对 replica 发送 DEL 命令.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 这个行为保证了 master 和 replicas 的一致性, 并且这通常也是你需要的, 但是若你的 replica 节点是可写的,</span></span><br><span class="line"><span class="meta"># 或者你希望 replica 节点有不同的内存配置, 并且你确保所有到 replica 写操作都幂等的, 那么你可以修改这个默认的行为(请确保你明白你在做什么).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 需要注意的是默认情况喜爱 replica 节点不会执行过期策略, 它有可能使用了超过 maxmemory 设定的值的内存.</span></span><br><span class="line"><span class="meta"># 因此你需要监控 replicas 节点所在的机器并且确保在 master 节点到达配置的 maxmemory 大小时, replicas 节点不会超过物理内存的大小.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># replica-ignore-maxmemory yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################# LAZY FREEING ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 有两种方式删除键. 一种是使用如 DEL 这样的命令进行的同步删除. </span></span><br><span class="line"><span class="meta"># 同步删除意味着删除过程中服务端会停止处理新进来的命令. 若要删除的 key 关联了一个小的 object 删除耗时会很短.</span></span><br><span class="line"><span class="meta"># 若要删除的 key 管理了一个很大的 object, 比如此对象有上百万个元素, 服务端会阻塞相同长一段时间(甚至超过一秒).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 由于以上原因, Redis 同时提供了一种非阻塞的方式用于删除,</span></span><br><span class="line"><span class="meta"># 比如 UNLINK(非阻塞的 DEL)以及用于 FLUSHALL 和 FLUSHDB 的 ASYNC 选项, 这些命令能在后台回收内存.</span></span><br><span class="line"><span class="meta"># 这些命令能在常数时间内执行完毕. 其他线程会在后台尽快回收内存.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># DEL,UNLINK 以及用于 FLUSHALL 和 FLUSHDB 的 ASYNC 选项是用户可以控制的. </span></span><br><span class="line"><span class="meta"># 根据应用的设计, 用户可以选择使用阻塞或者非阻塞的方式. </span></span><br><span class="line"><span class="meta"># 但是作为某些命令的副作用 Redis 服务端有时会删除某些 object 或者 flush 整个数据库. </span></span><br><span class="line"><span class="meta"># 特别是以下独立于用户操作的情形: </span></span><br><span class="line"><span class="meta"># 1. 由于 maxmemory 和 maxmemory policy 配置导致的内存回收动作 </span></span><br><span class="line"><span class="meta"># 2. 由于过期, 当一个 key 过期后(可以查看 EXPIRE 命令获取相关信息), 必须回收其内存 </span></span><br><span class="line"><span class="meta"># 3. 由于某些命令的副作用, 比如 STORE 命令, 执行 STORE 命令可能需要删除已有的键. SET 命令需要删除已有的旧内容.</span></span><br><span class="line"><span class="meta"># 4. 在复制过程中, 当一个 replica 节点执行一个全量同步时, replica 需要删除整个数据库的内容以加载传输过来的 RDB 文件.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在上述所有情形中, 删除 object 的默认行为都是以阻塞方式删除. 当然你可以配置上述四个选项来改变这种默认行为:</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"><span class="meta">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认 redis 使用的是 rdb 方式持久化, 这种方式在许多应用中已经足够用了.</span></span><br><span class="line"><span class="meta"># 但是 redis 如果中途宕机, 会导致可能有几分钟的数据丢失, 根据 save 来策略进行持久化,</span></span><br><span class="line"><span class="meta"># Append Only File 是另一种持久化方式, 可以提供更好的持久化特性.</span></span><br><span class="line"><span class="meta"># Redis 会把每次写入的数据在接收后都写入 appendonly.aof 文件,</span></span><br><span class="line"><span class="meta"># 每次启动时 Redis 都会先把这个文件的数据读入内存里, 先忽略 RDB 文件.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, Redis 会异步将数据集快照到磁盘上. 尽管这种模式对许多应用友好, 但是当 Redis 进程崩溃或发生掉电时,</span></span><br><span class="line"><span class="meta"># 几分钟内的写信息将丢失(根据快照执行的粒度).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># AOF 作为一种可替换的持久化策略, 能够提供更好的耐久性.</span></span><br><span class="line"><span class="meta"># 如使用默认的 fsync 策略, Redis 仅会丢失 1s 的写信息, 当发生突发事件(服务器掉电、服务器进程崩溃但 OS 运行正常).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># AOF 持久化和 RDB 持久化可以同时开启. 如果在启动 Redis 时已经存在 AOF 文件, 则会直接加载 AOF 文件(考虑到 AOF 文件相比 RDB 文件有更好的耐久性).</span></span><br><span class="line"><span class="meta"># 关于 AOF 的更多讯息见: http://redis.io/topics/persistence </span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定 AOF 文件名称, 默认是 appendonly.aof.</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 调用 fsync() 系统函数用来告知 OS 将数据写入磁盘, 而不是在输出缓冲区等待数据. 有些 OS 将直接 flush 数据到磁盘, 有些其他的 OS 仅会尝试去 flush.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Redis 支持三种 fsync() 调用模式:</span></span><br><span class="line"><span class="meta"># no: 不执行 fsync, 由 OS 决定 flush 数据的频率. 高效. Linux 下默认是每 30s 执行一次 flush.</span></span><br><span class="line"><span class="meta"># always: 每写入一次 AOF 就调用一次 fsync. 慢, 最安全.</span></span><br><span class="line"><span class="meta"># everysec: 每秒调用一次 fsync, 可能会导致丢失这 1s 数据.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认 fsync 的调用频率是 “everysec”, 这种策略在执行速度和数据安全进行折中.</span></span><br><span class="line"><span class="meta"># 当可以容忍一定程度数据丢失并期望更高的性能时, 可以使用 “no” 策略(由操作系统决定 flush 的频率).</span></span><br><span class="line"><span class="meta"># 相反的, 如果不能容忍数据丢失, 可以使用 “always” 获得更好的安全性, 尽管执行更慢.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在无法确定 fsync 调用频率时, 推荐使用 “everysec” 策略.</span></span><br><span class="line"><span class="meta"># 在开启 AOF 持久化功能后, 该配置才会生效.</span></span><br><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在 aof 重写或者写入 rdb 文件的时候, 会执行大量 IO, 此时对于 everysec 和 always 的 aof 模式来说,</span></span><br><span class="line"><span class="meta"># 执行 fsync 会造成阻塞过长时间, no-appendfsync-on-rewrite 字段设置为默认设置为 no.</span></span><br><span class="line"><span class="meta"># 如果对延迟要求很高的应用, 这个字段可以设置为 yes, 否则还是设置为 no,</span></span><br><span class="line"><span class="meta"># 这样对持久化特性来说这是更安全的选择. 设置为 yes 表示 rewrite 期间对新写操作不 fsync,</span></span><br><span class="line"><span class="meta"># 暂时存在内存中, 等 rewrite 完成后再写入, 默认为 no, 建议 yes.</span></span><br><span class="line"><span class="meta"># Linux 的默认 fsync 策略是 30 秒. 可能丢失 30 秒数据.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当 AOF 执行 fsync 的策略是 always 和 everysec 时, 如果此时有一个后台进程 (BGSAVE 进程或 AOF rewrite 进程) 正在执行大量的 I/O 操作到磁盘,</span></span><br><span class="line"><span class="meta"># 在一些 Linux 系统中, 执行 fsync 会造成较长的阻塞. 当前对这种情况还没有很好的解决策略, 即使在不同的线程中执行 fsync 也会导致调用同步 write(2) 阻塞.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了缓解上述问题, 可以通过配置下述选项来避免在主线程调用 fsync() 时执行 BGSAVE 或 BGREWRITEAOF 带来的阻塞.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 也就是说, 默认情况下, 当子进程执行 BGSAVE 或 BGREWRITEAOF 时, Redis 的耐久性将默认转变成 "appendfsync none".</span></span><br><span class="line"><span class="meta"># 在实际的应用中就意味着在最坏的场景下将丢失 30s 的数据, 即使配置了 fsync 调用频率为 always 或 everysec.(默认情况下, Linux 每 30s 自动调用一次 fsync 将缓存数据 flush 到磁盘)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果当前应用已考虑延迟问题, 则将该配置设置成 “yes”. 否则使用默认配置(“no”), 这是从耐久性角度考虑的最安全的选择.</span></span><br><span class="line">no-appendfsync-on-rewrite no </span><br><span class="line"></span><br><span class="line"><span class="meta"># aof 自动重写配置. 当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写,</span></span><br><span class="line"><span class="meta"># 即当 aof 文件增长到一定大小的时候 Redis 能够调用 bgrewriteaof 对日志文件进行重写.</span></span><br><span class="line"><span class="meta"># 当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍 (设置为 100) 时,</span></span><br><span class="line"><span class="meta"># 自动启动新的日志重写过程.</span></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="meta"># 设置允许重写的最小 aof 文件大小, 避免了达到约定百分比但尺寸仍然很小的情况还要重写</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置 AOF 重写的触发条件.</span></span><br><span class="line"><span class="meta"># 当 AOF 日志按照指定的比例增长时, 可以通过调用 BGREWRITEAOF 执行自动的 AOF rewrite.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 工作原理: Redis 通过对比上一次执行 rewrite 时 AOF 文件的大小与当前 AOF 文件大小(在重启时将没有上一次执行 rewrite 的记录, 这时将使用 startup 时的 AOF 文件大小), 决定是否进行 rewrite.</span></span><br><span class="line"><span class="meta"># 如果当前 AOF 对于上一次执行 rewrite 的 AOF 文件的增长比率大于指定的比率, 将会触发一次 rewrite.</span></span><br><span class="line"><span class="meta"># 当然, 还需指定一个 AOF 进行重写的最小单位. 这样做可以避免增长比率已经达到要求, 但对应的 AOF 仍很小的情况 (这种情况下没有必要进行 rewrite) 的发生.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果想要关闭自动 AOF rewrite 功能, 可将进行 rewrite 要求的增长比率设置 0.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认当 AOF 大于 64MB 且相比于上一次 rewrite,AOF 以扩充了两倍时会触发一次 rewrite 执行. 默认配置如下:</span></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"><span class="meta"># aof 文件可能在尾部是不完整的, 当 redis 启动的时候, aof 文件的数据被载入内存.</span></span><br><span class="line"><span class="meta"># 重启可能发生在 redis 所在的主机操作系统宕机后,</span></span><br><span class="line"><span class="meta"># 尤其在 ext4 文件系统没有加上 data=ordered 选项 (redis 宕机或者异常终止不会造成尾部不完整现象.)</span></span><br><span class="line"><span class="meta"># 出现这种现象, 可以选择让 redis 退出, 或者导入尽可能多的数据. 如果选择的是 yes,</span></span><br><span class="line"><span class="meta"># 当截断的 aof 文件被导入的时候, 会自动发布一个 log 给客户端然后 load.</span></span><br><span class="line"><span class="meta"># 如果是 no, 用户必须手动 redis-check-aof 修复 AOF 文件才可以.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在将 AOF 文件加载到内存时(重启 Redis), 可能会出现 AOF 被截断的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如当 Redis 运行所在系统突然崩溃(当 ext4 文件系统在安装时没有配置成数据按序存储), 会出现 AOF 被截断情况.</span></span><br><span class="line"><span class="meta"># 如果 Redis 程序发生崩溃或异常, 但操作系统仍能正常工作, 则不会出现 AOF 被截断的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 出现 AOF 被截断后, Redis 要么直接退出并返回错误, 要么加载被截断 AOF 中尽可能多的数据(当前默认方式).</span></span><br><span class="line"><span class="meta"># 可以通过 aof-load-truncated 选项进行配置:</span></span><br><span class="line"><span class="meta"># 当 aof-load-truncated 设置成 “yes”,Redis 仍会加载一个被截断的 AOF 文件, 同时向用户报告 AOF 文件被截断.</span></span><br><span class="line"><span class="meta"># 如果设置成 “no”,Redis 会直接返回错误并拒绝启动, 这时用户需要使用 "redis-check-aof" 程序修复 AOF, 只有这样才能重启 Server.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 如果 AOF 文件在执行一半时就出现问题, 即使设置 aof-load-truncated 为 “yes”,Redis 也会直接退出并返回错误.</span></span><br><span class="line"><span class="meta"># 这个配置仅在 Redis 尝试从 AOF 文件读更多数据但发现没有足够字计数存在时有意义.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当重写 AOF 文件时, Redis 可以使用 RDB 文件作为 AOF 文件的前导, 这样可以更快地进行重写和恢复. </span></span><br><span class="line"><span class="meta"># 当启用这个功能时 AOF 文件由两部分组成:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   [RDB file][AOF tail]</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当加载 AOF 文件时, Redis 通过以 “REDIS” 字符串开头的 AOF 文件识别出此文件是由 RDB 和 AOF 组合而成的,</span></span><br><span class="line"><span class="meta"># Redis 会先加载 RDB 部分, 然后再加载 AOF 部分.</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"><span class="meta">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置 Lua 脚本执超时的时间上限, 单位是毫秒, milliseconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当 Lua 脚本执行超时, Redis 会记录脚本执行之后的结果 (超时后) 并向查询返回错误.</span></span><br><span class="line"><span class="meta"># 当一个长时脚本执行时间超过最大执行时间时, 只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 命令可用.</span></span><br><span class="line"><span class="meta"># 停止这类脚本运行的第一个方法是调用一个非写命令. 第二种方法是 shut down 这个 server, 如果已经发送了一个写命令但用户并不想等待脚本自然终止.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果想不限制脚本的执行时间并且不需要返回 warning, 可以将该参数设置成 0 或负数.</span></span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 正常情况下, 启动的 Redis 实例为非集群模式. 只有当节点配置成集群模式时才能成为集群节点.</span></span><br><span class="line"><span class="meta"># 如需以集群模式启动, 取消下述配置的注释即可:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-enabled yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 集群配置文件的名称, 每个节点都有一个集群相关的配置文件, 持久化保存集群的信息.</span></span><br><span class="line"><span class="meta"># 这个文件并不需要手动配置, 这个配置文件有 Redis 生成并更新,</span></span><br><span class="line"><span class="meta"># 每个 Redis 集群节点需要一个单独的配置文件, 请确保与实例运行的系统中配置文件名称不冲突.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 集群节点超时阈值用来作为节点不可达并被标记为失效状态的超时上限, 单位是毫秒(millisecond)</span></span><br><span class="line"><span class="meta"># 大部分其他内部时间将其基本参考数.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-node-timeout 15000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在进行故障转移的时候, 全部 slave 都会请求申请为 master,</span></span><br><span class="line"><span class="meta"># 但是有些 slave 可能与 master 断开连接一段时间了, 导致数据过于陈旧,</span></span><br><span class="line"><span class="meta"># 这样的 slave 不应该被提升为 master. 该参数就是用来判断 slave 节点与 master 断线的时间是否过长.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 没有简单的方式可以直接准确判定从节点的”data age”, 可以通过下面两个方面的检测实现:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 1) 如果有多个从节点可以发起故障转移, 可以让他们交换信息以选出数据状态最节点主节点的从节点.</span></span><br><span class="line"><span class="meta"># 从节点可以通过 offset 进行排名并通过该排名延迟发起故障转移的时机.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 2) 每个独立的从节点计算最近一次与主节点交互的时间.</span></span><br><span class="line"><span class="meta"># 这里的交互可以是最近一次 PING、最近一次接收到来自主节点的命令、与主节点断开连接的时间(当复制链接已经 down 掉时).</span></span><br><span class="line"><span class="meta"># 如果最近一次与主节点的交互已经足够久远, 那么这个从节点将放弃进行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在 2) 中的时间阈值可以由用户设定. 特别地, 当从节点的最近一次与主节点的交互远大于 (node-timeout * slave-validity-factor) + repl-ping-slave-period 时, 这个从节点将不会执行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如假设 node-timeout 为 30 秒, slave-validity-factor 参数为 10,repl-ping-slave-period 为 10 秒, 当从节点距离最近一次与主节点的交互时间大于 310 秒 (30*10+10) 时, 该从节点不能进行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一个过大的从节点有效因子 (slave-validity-factor) 会允许存储过旧数据的从节点进行故障转移, 而一个过小的从节点有效因子将会妨碍集群选择从节点成为新的主节点.</span></span><br><span class="line"><span class="meta"># 所以合理的设置从节点有效因子很重要.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了获得最大的可用性, 可以将从节点有效因子 (slave-validity-factor) 赋值为 0.</span></span><br><span class="line"><span class="meta"># 也就是说, 从节点忽略距离最近一次与主节点交互的时间段, 则是直接点尝试发起故障转移.(但是这种策略下, 这些从节点仍会根据 offset 的排名来推迟发起故障转移的时间)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点有效因子 (slave-validity-factor) 值为 0 是唯一可以保证网络分区消失后, 集群仍继续工作的值.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-replica-validity-factor 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 集群支持将从节点迁移到孤立主节点(orphaned masters), 没有可以工作从节点的主节点.</span></span><br><span class="line"><span class="meta"># 该功能减少了集群孤立主节点故障但没有可工作从节点进行故障转移的情况的发生.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点可以迁移到孤立主节点当且仅当原来的主节点的剩余可工作从节点个数大于等于指定的可工作从节点数.</span></span><br><span class="line"><span class="meta"># 这个数称为从节点迁移屏蔽因子(migration barrier).</span></span><br><span class="line"><span class="meta"># 当迁移屏蔽因子设置为 1 时, 当且仅当主节点拥有至少两个可工作的从节点才允许其中从节点迁移到孤立主节点(orphaned masters).</span></span><br><span class="line"><span class="meta"># 该因子通常用来表明使用者需要为集群中的主节点配置从节点个数.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认迁移屏蔽因子是 1(从节点可以执行迁移当前仅当其主节点在该节点迁移后仍保有至少一个从节点).</span></span><br><span class="line"><span class="meta"># 如果想关闭该功能, 只需将该参数设置成一个极大值即可.</span></span><br><span class="line"><span class="meta"># 允许将迁移屏蔽因子置零. 这种行为仅在调试时有用, 且在生产环境中存在极大风险.</span></span><br><span class="line"><span class="meta"># cluster-migration-barrier 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, Redis 集群将停止接收客户端请求 (停止服务) 当集群检测到存在哈希槽没有对应负责的节点.</span></span><br><span class="line"><span class="meta"># 也就是说, 如果集群部分 down(如有一部分哈希槽没有对应的节点), 整个集群最终将会不可用.(集群信息传播遵循最终一致性)</span></span><br><span class="line"><span class="meta"># 当所有的槽都再次有对应负责的节点后, 集群将会自动再次可用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 但是有时希望即使集群只有部分槽有对应的节点, 集群也能继续接受客户端请求并处理对应的键空间.</span></span><br><span class="line"><span class="meta"># 为了达到上述目的, 将 ecluster-require-full-coverage 设置为 “no” 即可.</span></span><br><span class="line"><span class="meta"># cluster-require-full-coverage yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 这个选项用于控制 master 发生故障时是否自动进行 failover.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当设置为 yes 后 master 发生故障时不会自动进行 failover, 这时你可以进行手动的 failover 操作.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-replica-no-failover no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="meta"># available at http://redis.io web site.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">########################## CLUSTER DOCKER/NAT support  ########################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在某些部署环境下, Redis 集群的节点地址不能被自动发现, 这是因为这些节点是部署在 NAT 网络或者端口是转发的 (典型的情况就是使用了 Docker 或者其他容器).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 为了能让 Redis 集群工作在这种环境下, 我们需要进行相关配置让各个节点知道相互之间的外部地址,</span></span><br><span class="line"><span class="meta"># 这可以通过设置以下选项做到:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># * cluster-announce-ip: 表示节点的外部地址</span></span><br><span class="line"><span class="meta"># * cluster-announce-port: 表示节点的客户端口</span></span><br><span class="line"><span class="meta"># * cluster-announce-bus-port: 表示集群消息总线端口</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Each instruct the node about its address, client port, and cluster message</span></span><br><span class="line"><span class="meta"># bus port. The information is then published in the header of the bus packets</span></span><br><span class="line"><span class="meta"># so that other nodes will be able to correctly map the address of the node</span></span><br><span class="line"><span class="meta"># publishing the information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 若以上选项未配置, 则将会启用正常的 Redis 集群自动检测机制. </span></span><br><span class="line"><span class="meta"># 若 bus port 未设置, 则会将其设置为 port + 10000.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Example:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-announce-ip 10.1.1.5</span></span><br><span class="line"><span class="meta"># cluster-announce-port 6379</span></span><br><span class="line"><span class="meta"># cluster-announce-bus-port 6380</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 慢日志系统用来记录执行时间较长的查询.</span></span><br><span class="line"><span class="meta"># 这里的执行时间 (“execution time”) 不包括 IO 操作时间, 如接收客户端的请求, 返回请求结果等,</span></span><br><span class="line"><span class="meta"># 而是实际执行命令的时间(此时线程处于阻塞状态, 仅能执行该命令, 不能同时处理其他请求).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 可以使用两个参数配置慢日志: 一个参数告知 Redis 执行时间超时阈值(单位是微秒, microseconds), 这样一旦某个执行时间超过指定上限, 将会被记录到慢日志中；</span></span><br><span class="line"><span class="meta"># 另一个参数是慢日志的长度. 慢日志使用环式结构存储超时命令.(当慢日志满后, 新命令添加进去后, 最老的命令将被踢出)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 单位是微秒(microsecon). 注意, 负数时间会禁用慢查询日志, 而 0 则会强制记录所有命令.</span></span><br><span class="line"><span class="meta"># 默认慢日志功能是开启的.</span></span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 慢查询日志长度. 当一个新的命令被写进日志的时候, 最老的那个记录会被删掉.</span></span><br><span class="line"><span class="meta"># 这个长度没有限制. 只要有足够的内存就行. 你可以通过 SLOWLOG RESET 来释放内存.</span></span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################ LATENCY MONITOR ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 延迟监测自系统通过对执行期间的操作的检测来收集与延迟相关的数据.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 通过使用 LATENCY 命令, Redis 用户可以获得延迟相关的图形、报告等信息.</span></span><br><span class="line"><span class="meta"># 延迟系统只会记录大于等于设置的 latency-monitor-threshold 值的操作. 当该值为零时,</span></span><br><span class="line"><span class="meta"># 则表明关闭 latency monitor.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 默认情况下, latency monitor 功能是关闭的, 因为大多数场景下并不需要该功能.</span></span><br><span class="line"><span class="meta"># latency monitor 可以在 Redis 运行时通过 "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" 启动.</span></span><br><span class="line">latency-monitor-threshold <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################# EVENT NOTIFICATION ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 可以通知那些已 Pub/Sub 客户端键空间发生的事件.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如, 如果开启键空间通知功能且一个客户端对 0 号数据库上的 “foo”key 执行 DEL 操作, 那么 Redis 将使用 Pub/Sub 发送两条消息:</span></span><br><span class="line"><span class="meta"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="meta"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Redis 对通知的事件进行了分类, 每一类都使用唯一的字符标记:</span></span><br><span class="line"><span class="meta">#  K  键空间 (Key) 通知, 前缀为:__keyspace@&lt;db&gt;__ </span></span><br><span class="line"><span class="meta">#  E     键事件 (Event) 通知, 前缀为:__keyevent@&lt;db&gt;__ 对于所有命令类型和非键事件, 均使用小写字母表示, 且没有前缀.</span></span><br><span class="line"><span class="meta">#  g     一般命令(Generic commands), 如 DEL, EXPIRE, RENAME 等</span></span><br><span class="line"><span class="meta">#  $     字符串 (String) 命令</span></span><br><span class="line"><span class="meta">#  l     列表 (list) 命令</span></span><br><span class="line"><span class="meta">#  s     集合 (set) 命令</span></span><br><span class="line"><span class="meta">#  h     哈希 (hash) 命令</span></span><br><span class="line"><span class="meta">#  z     有序集合 (sorted set) 命令</span></span><br><span class="line"><span class="meta">#  x     过期事件(过期键产生的事件)</span></span><br><span class="line"><span class="meta">#  e     驱逐事件(因 maxmemory 而驱逐的事件)</span></span><br><span class="line"><span class="meta">#  A     g$lshzxe 等类型的别称(Alias), 如此一来就可以使用 "AKE" 代表所有的事件类型</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># notify-keyspace-events 可以指定多个字符组成的字符串或空串. 其中空串代表关闭通知功能.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例 1: 为了开启 List 事件和 Genetic 事件(从事件名称分类来说), 可以使用如下设置:</span></span><br><span class="line"><span class="meta"># notify-keyspace-events Elg</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例 2: 为了获取过期键的信息并发送到订阅的频道, 即__keyevent@0__:expired use 信息, 可设置如下:</span></span><br><span class="line"><span class="meta"># notify-keyspace-events Ex</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 事件通知功能是关闭的, 因为大多数用户并不需要这个功能且这个功能会带来额外的性能开销.</span></span><br><span class="line"><span class="meta"># 注意, 如果没有指定键空间 (K) 通知还是键事件 (E) 通知, 那么任何事件通知都不会被传送.</span></span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Hash 数据类型的底层实现有压缩链表 (ziplist) 和哈希表(hash).</span></span><br><span class="line"><span class="meta"># 当且仅当存储的数据量小于 hash-max-ziplist-entries 且节点占用的容量小于 hash-max-ziplist-value 时才使用小数据量存储高效的 ziplist 结构存储.</span></span><br><span class="line"><span class="meta"># 否则, 使用哈希结构存储.</span></span><br><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># List 类型也可以通过特殊的方式来节省空间.</span></span><br><span class="line"><span class="meta"># 每个内部 list 节点允许存储的 entries 数量可以指定为已修订最大数量或最大元素数.</span></span><br><span class="line"><span class="meta"># 如指定 - 5 到 - 1, 其含义是:</span></span><br><span class="line"><span class="meta"># -5: max size: 64 Kb  &lt;-- 对于普通的工作负载, 不建议使用</span></span><br><span class="line"><span class="meta"># -4: max size: 32 Kb  &lt;-- 不建议使用</span></span><br><span class="line"><span class="meta"># -3: max size: 16 Kb  &lt;-- 有时不建议使用</span></span><br><span class="line"><span class="meta"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta"># 整数代表每个 list 节点准确存储指定数量的 elements</span></span><br><span class="line"><span class="meta"># 最高效的参数设置是 - 2 (8 Kb size) 或 -1 (4 Kb size)</span></span><br><span class="line"><span class="meta"># 但是, 如果需求很特殊, 则应根据需要调整参数:</span></span><br><span class="line">list-max-ziplist-size <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># List 可以实现压缩.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 压缩深度是划定 quicklist、ziplist 等 list 在压缩时的节点范围.</span></span><br><span class="line"><span class="meta"># 为了进行快速的 push/pop 操作, 不会对 list 的 head 和 tail 进行压缩, 只会对中间节点进行压缩.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 参数设置如下:</span></span><br><span class="line"><span class="meta"># 0: 关闭 list 压缩功能</span></span><br><span class="line"><span class="meta"># 1: 深度为 1 表示只有当 list 添加一个节点 (无论从 head 还是 tail 添加该节点) 后才开始进行压缩.</span></span><br><span class="line"><span class="meta">#  所以对于 [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="meta">#  只有黑体部分加入才会执行压缩操作.</span></span><br><span class="line"><span class="meta"># 2: 深度为 2</span></span><br><span class="line"><span class="meta">#  对于链表:[head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="meta">#  不会压缩 head 或 head-&gt;next 或 tail-&gt;prev 或 tail, 而仅压缩剩余部分.</span></span><br><span class="line"><span class="meta"># 3: 深度为 3</span></span><br><span class="line"><span class="meta">#   [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line">list-compress-depth <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Set 数据类型的底层实现默认是 intSet, 也可以是 hash.</span></span><br><span class="line"><span class="meta"># Set 使用 hash 编码格式当且仅当字符串组成的 set 变成底数为 10 的整数, 且其值范围在 64 位整数中.</span></span><br><span class="line"><span class="meta"># 下面的配置设置用来指定 set 可以使用特殊编码格式的阈值:</span></span><br><span class="line"><span class="keyword">set</span>-max-intset-entries <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Sorted Set 默认使用 ziplist 实现, 也可通过 skiplist 编码实现来节省空间.</span></span><br><span class="line"><span class="meta"># 当且仅当 Sorted Set 中元素值大于 zset-max-ziplist-value、元素数量大于 zset-max-ziplist-entries 时, 才使用 skiplist 实现 Sorted Set.</span></span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构 (sparse),</span></span><br><span class="line"><span class="meta"># 大于 hll-sparse-max-bytes 使用稠密的数据结构 (dense).</span></span><br><span class="line"><span class="meta"># 一个比 16000 大的 value 是几乎没用的, 建议的 value 大概为 3000.</span></span><br><span class="line"><span class="meta"># 如果对 CPU 要求不高, 对空间要求较高的, 建议设置到 10000 左右.</span></span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># HyperLogLog 稀疏表示阈值.</span></span><br><span class="line"><span class="meta"># 16 位的 header 部分也在 limit 中. 当使用稀疏表示的 HyperLogLog 存储的字节超过了指定的阈值, 它将转变成稠密表示.</span></span><br><span class="line"><span class="meta"># 不建议使用大于 16000 的值. 当小于 16000 时能够获得较高存储效率.</span></span><br><span class="line"><span class="meta"># 建议的值是 3000, 该值可以在较少 PFADD(在执行稀疏编码时时间复杂度是 O(N))操作执行的同时获得极高空间使用收益. 当 CPU 问题无需考虑时, 可将该值提升到 10000, 但其值不应超过 15000.</span></span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Streams macro node max size / items. The stream data structure is a radix</span></span><br><span class="line"><span class="meta"># tree of big nodes that encode multiple items inside. Using this configuration</span></span><br><span class="line"><span class="meta"># it is possible to configure how big a single node can be in bytes, and the</span></span><br><span class="line"><span class="meta"># maximum number of items it may contain before switching to a new node when</span></span><br><span class="line"><span class="meta"># appending new stream entries. If any of the following settings are set to</span></span><br><span class="line"><span class="meta"># zero, the limit is ignored, so for instance it is possible to set just a</span></span><br><span class="line"><span class="meta"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span></span><br><span class="line"><span class="meta"># value.</span></span><br><span class="line"><span class="meta"># 用于设定 Streams 单个节点的最大大小和最多能保存多个个元素.</span></span><br><span class="line">stream-node-max-bytes <span class="number">4096</span></span><br><span class="line">stream-node-max-entries <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 激活的 rehash 会占用每 100 毫秒的 1 millisecond 的 CPU 时间来对 Redis hash table(存储数据库的键值对的 hash table)执行 rehash.</span></span><br><span class="line"><span class="meta"># 在 Redis 中 hash table 使用惰性 rehash: 在 rehashing 时, hash table 中执行的操作越多, rehash 执行的步骤也越多.</span></span><br><span class="line"><span class="meta"># 所以当 server 很空闲时, rehash 将很简单, hash table 也会有更多的内存可以使用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了在条件许可的情况下对 hash table 进行 rehash, 从而节省内存空间, 默认情况下, rehash 功能会每 100 毫秒中 1 毫秒被调用一次.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果不确定:</span></span><br><span class="line"><span class="meta"># 使用 "activerehashing no" 如果当前应用环境很注重延迟、Redis 仅允许 2 毫秒的延迟应答.</span></span><br><span class="line"><span class="meta"># 使用 "activerehashing yes" 如果当前应用环境不是太注重延迟且想要尽可能块的释放内存空间.</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 客户端输出缓冲区可以用来强制断开那些不能够快速读取服务器数据的客户端连接.(如在 Pub/Sub 模式中, 客户端不能够快速的处理 publisher 发送过来的消息)</span></span><br><span class="line"><span class="meta"># 客户端类型可以细分为三类:</span></span><br><span class="line"><span class="meta"># normal -&gt; 普通客户端(包括 MONITOR 客户端)</span></span><br><span class="line"><span class="meta"># slave  -&gt; 从节点客户端</span></span><br><span class="line"><span class="meta"># pubsub -&gt; 订阅至少一个 pubsub 通道或模式的客户端</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># client-output-buffer-limit 设置的通用格式如下:</span></span><br><span class="line"><span class="meta"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一旦 hard limit 达到, 客户端将直接断开连接. 如果 soft limit 达到, 客户端连接将会持续 soft seconds 后才断开连接.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如, 当 hard limit 是 32 MB(megabytes)、soft limit 在 10 秒内持续超过 16MB,</span></span><br><span class="line"><span class="meta"># 如果客户端输出缓冲区 (clients output buffer) 超过 32 MB 或客户客户端输出缓冲区 (clients output buffer) 超过 16MB, 并在接下来的 10 秒都高于 16MB, 客户端连接将马上断开.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 不需对 normal 级别的 clients 进行约束因为这些客户端如果没有发起询问就不会接受数据.</span></span><br><span class="line"><span class="meta"># 所以, 只需对异步客户端进行约束因为异步客户端会出现请求速度大于 read 速度的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 因为订阅者和从节点使用推的方式接受数据, 所以需要对 pubsub 客户端和 slave 客户端设置默认的客户端输出缓冲区约束.</span></span><br><span class="line"><span class="meta"># 将 hard limit 或 soft limit 置零表示关闭对应的功能.</span></span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 客户端查询缓冲区会累加新的命令. </span></span><br><span class="line"><span class="meta"># 默认情况下, 他们会限制在一个固定的数量避免协议同步失效 (比如客户端的 bug) 导致查询缓冲区出现未绑定的内存.</span></span><br><span class="line"><span class="meta"># 但是, 如果有类似于巨大的 multi/exec 请求的时候可以修改这个值以满足你的特殊需求.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># client-query-buffer-limit 1gb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在 Redis 协议中, 批量请求通常限制在 512 mb 内, 可以通过修改 proto-max-bulk-len 选项改变这个限制.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># proto-max-bulk-len 512mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 调用一个内部函数来执行后台任务, 如在 timeout 时关闭客户端连接, 清除从未被请求的过期键, 等等.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 虽然并不是所有的 tasks 都使用同样的频率执行, 但是 Redis 会根据指定的频率值来检测 tasks 的执行.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认设置的值为 10, 即每秒执行 10 次.</span></span><br><span class="line"><span class="meta"># 在 Redis 处于空闲提升该值时, 将会消耗更多的 CPU.</span></span><br><span class="line"><span class="meta"># 但是, 提升该值也会使 Redis 更精确的处理超时问题, 并检测到更多的过期键.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 该值设置范围是 1 到 500. 但是不建议将其设置大于 100.</span></span><br><span class="line"><span class="meta"># 大多数的用户建议使用默认的值(10), 并根据应用环境的低延迟需求适当提升该值(峰值建议不要大于 100).</span></span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 通常来说根据连接上来的客户端数量对 HZ 的值按比例进行调整是有用的.</span></span><br><span class="line"><span class="meta"># 这很有用, 例如, 为了避免每次后台任务处理太多的客户端, 从而避免高延迟峰值.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 默认情况下 HZ 的值为 10, 启用 dynamic-hz 后, 当有大量客户端连接进来时 HZ 的值会临时性地调高.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 启用 dynamic-hz 后, HZ 的配置值将作为基线, 当有大量的客户端连接进来时, Redis 会将 HZ 的实际值设置为 HZ 的配置值的整数倍.</span></span><br><span class="line"><span class="meta"># 通过这种方式, 空闲的 Redis 实例只会占用非常小的 CPU 时间, 当实例变得繁忙时 Redis 能更快地进行响应(相对未启用 dynamic-hz 的情况).</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当子进程进行 AOF 的重写时, 如果启用了 aof-rewrite-incremental-fsync, 子进程会每生成 32 MB 数据就进行一次 fsync 操作.</span></span><br><span class="line"><span class="meta"># 通过这种方式将数据分批提交到硬盘可以避免高延迟峰值.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当 Redis 保存 RDB 文件时, 如果启用了 rdb-save-incremental-fsync 功能, Redis 会每生成 32 MB 数据就执行一次 fsync 操作. </span></span><br><span class="line"><span class="meta"># 通过这种方式将数据分批提交到硬盘可以避免高延迟峰值.</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="meta"># idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="meta"># how to improve the performances and how the keys LFU change over time, which</span></span><br><span class="line"><span class="meta"># is possible to inspect via the OBJECT FREQ command.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># There are two tunable parameters in the Redis LFU implementation: the</span></span><br><span class="line"><span class="meta"># counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="meta"># understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span></span><br><span class="line"><span class="meta"># uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="meta"># of the old counter, when a key is accessed, the counter is incremented in</span></span><br><span class="line"><span class="meta"># this way:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1. A random number R between 0 and 1 is extracted.</span></span><br><span class="line"><span class="meta"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="meta"># 3. The counter is incremented only if R &lt; P.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span><br><span class="line"><span class="meta"># counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="meta"># logarithmic factors:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># NOTE: The above table was obtained by running the following commands:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="meta">#   redis-cli object freq foo</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span><br><span class="line"><span class="meta"># to accumulate hits.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The counter decay time is the time, in minutes, that must elapse in order</span></span><br><span class="line"><span class="meta"># for the key counter to be divided by two (or decremented if it has a value</span></span><br><span class="line"><span class="meta"># less &lt;= 10).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span></span><br><span class="line"><span class="meta"># decay the counter every time it happens to be scanned.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># lfu-log-factor 10</span></span><br><span class="line"><span class="meta"># lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">########################### ACTIVE DEFRAGMENTATION #######################</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 警告: 这个功能是实验性的. 当然此功能已经在包括生产环境在内的环境中通过压力测试. </span></span><br><span class="line"><span class="meta"># 并且被多名工程师手工测过一段时间.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># What is active defragmentation?</span></span><br><span class="line"><span class="meta"># -------------------------------</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 活动碎片整理允许 Redis 服务器压缩内存中由于申请和释放数据块导致的碎片, 从而回收内存. </span></span><br><span class="line"><span class="meta"># 碎片是每次申请内存 (幸运的是 Jemalloc 出现碎片的几率小很多) 的时候会自然发生的. </span></span><br><span class="line"><span class="meta"># 通常来说, 为了降低碎片化程度需要重启服务, 或者至少需要清除所有的数据然后重新创建. </span></span><br><span class="line"><span class="meta"># 得益于 Oran Agra 在 Redis 4.0 实现的这个特性, 进程可以在服务运行时以 “热” 方式完成这些目的.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 通常来说当碎片化达到一定程度(查看下面的配置)Redis 会使用 Jemalloc 的特性创建连续的内存空间, </span></span><br><span class="line"><span class="meta"># 并在此内存空间对现有的值进行拷贝, 拷贝完成后会释放掉旧的数据. </span></span><br><span class="line"><span class="meta"># 这个过程会对所有的导致碎片化的 key 以增量的形式进行.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 需要重点理解的是: </span></span><br><span class="line"><span class="meta"># 1. 这个特性默认是关闭的, 并且只有在编译 Redis 时使用我们代码中的 Jemalloc 版本才生效.(这是 Linux 下的默认行为)</span></span><br><span class="line"><span class="meta"># 2. 如果没有碎片问题, 你永远不需要启用这项特性 </span></span><br><span class="line"><span class="meta"># 3. 如果你需要试验这项特性, 可以通过命令 CONFIG SET activefrag yes 来启用</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 相关的配置参数可以很好的调整碎片整理过程. 如果你不知道这些选项的作用最好使用默认值.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 启用碎片整理.</span></span><br><span class="line"><span class="meta"># activedefrag yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有至少多少碎片时才开始碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-ignore-bytes 100mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有至少多少比例的碎片时才开始碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-threshold-lower 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有多少比例的碎片时才开始以最大努力进行碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-threshold-upper 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 进行碎片整理时至少使用多少比例的 CPU 时间.</span></span><br><span class="line"><span class="meta"># active-defrag-cycle-min 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 最大努力进行碎片整理时使用多少 CPU 时间.</span></span><br><span class="line"><span class="meta"># active-defrag-cycle-max 75</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 进行主字典扫描时处理的 set/hash/zset/list 字段的最大数量</span></span><br><span class="line"><span class="meta"># (就是说在进行主字典扫描时 set/hash/zset/list 的长度小于这个值才会处理, 大于这个值的会放在一个列表中延迟处理).</span></span><br><span class="line"><span class="meta"># active-defrag-max-scan-fields 1000</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf </a><br>[2]. <a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener">Redis 命令</a><br>[3]. <a href="http://blog.didispace.com/%E9%98%BF%E9%87%8C%E4%BA%91Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">阿里云 Redis 开发规范</a></p><hr><h2 id="Redis-深度探险系列"><a href="#Redis-深度探险系列" class="headerlink" title="Redis 深度探险系列"></a>Redis 深度探险系列</h2><ul><li><a href="8fb486e9.html">Redis 深度探险（一）：那些绕不过去的 Redis 知识点</a></li><li><a href="e993c76c.html">Redis 深度探险（二）：Redis 深入之道</a></li><li><a href="14348371.html">Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</a></li><li><a href="d63e1e23.html">Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经过 Redis 深度探险系列的学习相信大家对 Redis 的数据结构、对象、持久化机制、过期键删除策略等知识有了大致的了解，本篇博文主要讲述 Redis 的安装步骤，然后介绍一下 Redis 配置说明，最后对 Redis 集群搭建进行详细的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.maoning.pro/categories/Redis/"/>
    
    
      <category term="安装教程" scheme="http://blog.maoning.pro/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="Redis" scheme="http://blog.maoning.pro/tags/Redis/"/>
    
      <category term="配置说明" scheme="http://blog.maoning.pro/tags/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</title>
    <link href="http://blog.maoning.pro/archives/c0dca125.html"/>
    <id>http://blog.maoning.pro/archives/c0dca125.html</id>
    <published>2019-06-29T06:31:41.000Z</published>
    <updated>2019-08-16T02:04:33.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。</p><p>Git flow 工作流是经典模型，体现了工作流的经验和精髓。随着项目过程复杂化，会感受到这个工作流中深思熟虑和威力！Git flow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。在这章节中我们将一起学习一个当前非常流行的工作流 Git flow。</p><a id="more"></a><h2 id="Git-flow-工作介绍"><a href="#Git-flow-工作介绍" class="headerlink" title="Git flow 工作介绍"></a>Git flow 工作介绍</h2><h3 id="版本管理的挑战"><a href="#版本管理的挑战" class="headerlink" title="版本管理的挑战"></a>版本管理的挑战</h3><p>虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p><ul><li>如何开始一个 Feature 的开发，而不影响别的 Feature？</li><li>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？</li><li>哪些分支已经合并回了主干？</li><li>如何进行 Release 的管理？开始一个 Release 的时候如何冻结 Feature, 如何在 Prepare Release 的时候，开发人员可以继续开发新的功能？</li><li>线上代码出 Bug 了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个 Release?</li></ul><p>大部分开发人员现在使用 Git 就只是用三个甚至两个分支，一个是 Master, 一个是 Develop, 还有一个是基于 Develop 打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个 Release, 但是人员一多，而且项目周期一长就会出现各种问题。</p><h3 id="Git-flow-流程"><a href="#Git-flow-流程" class="headerlink" title="Git flow 流程"></a>Git flow 流程</h3><p>荷兰程序员 Vincent Driessen 曾发表了一篇博客 <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A Successful Git Branching Model</a>，让一个分支策略广为人知。</p><p>下面是 Git flow 的流程图：</p><p><img src="/media/15619490256878/git-model@2x.png" alt="git-model@2x"></p><p>这一流程最大的亮点是考虑了紧急 Bug 的应对措施，整个流程显得过于复杂，所以在实施该方案前，需要对整个开发流程进行系统的学习。也需要借助 Git flow 等工具的辅助。</p><h2 id="Git-flow-安装以及初始化"><a href="#Git-flow-安装以及初始化" class="headerlink" title="Git flow 安装以及初始化"></a>Git flow 安装以及初始化</h2><p>工具 Git-flow 是按照 Vincent Driessen 的 branch 模型，实现的一个高层次（级别）的 git 仓库操作扩展集合。 </p><h3 id="Linux-安装-Git-flow"><a href="#Linux-安装-Git-flow" class="headerlink" title="Linux 安装 Git flow"></a>Linux 安装 Git flow</h3><p>Ubuntu 中使用 apt-get 安装 Git flow 的方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install git-flow</span><br></pre></td></tr></table></figure><p>CentOS7 中使用 wget 安装 Git flow 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget --no-check-certificate -q  <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/petervanderdoes</span><span class="regexp">/gitflow-avh/develop</span><span class="regexp">/contrib/gitflow</span>-installer.sh &amp;&amp; sudo bash gitflow-installer.sh install develop; rm gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="Mac-安装-Git-flow"><a href="#Mac-安装-Git-flow" class="headerlink" title="Mac 安装 Git flow"></a>Mac 安装 Git flow</h3><p>Mac 中使用 brew 安装 Git flow 的方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>git-flow-avh</span><br></pre></td></tr></table></figure><h3 id="Windows-安装-Git-flow"><a href="#Windows-安装-Git-flow" class="headerlink" title="Windows 安装 Git flow"></a>Windows 安装 Git flow</h3><p>Windows 中使用 wget 安装 Git flow 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget -q -O - --no-check-certificate <span class="symbol">https:</span>/<span class="regexp">/raw.github.com/petervanderdoes</span><span class="regexp">/gitflow-avh/develop</span><span class="regexp">/contrib/gitflow</span>-installer.sh install stable | bash</span><br></pre></td></tr></table></figure><h3 id="Git-flow-初始化"><a href="#Git-flow-初始化" class="headerlink" title="Git flow 初始化"></a>Git flow 初始化</h3><p>回答几个关于分支的命名约定的问题，建议使用默认值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git flow init</span><br><span class="line"></span><br><span class="line"><span class="symbol">No</span> <span class="keyword">branches </span>exist yet. <span class="keyword">Base </span><span class="keyword">branches </span>must <span class="keyword">be </span>created now.</span><br><span class="line"><span class="keyword">Branch </span>name for production releases: [master] </span><br><span class="line"><span class="keyword">Branch </span>name for <span class="string">"next release"</span> development: [develop] </span><br><span class="line"></span><br><span class="line"><span class="symbol">How</span> to name your supporting <span class="keyword">branch </span>prefixes?</span><br><span class="line"><span class="symbol">Feature</span> <span class="keyword">branches? </span>[feature/] </span><br><span class="line"><span class="keyword">Bugfix </span><span class="keyword">branches? </span>[<span class="keyword">bugfix/] </span></span><br><span class="line"><span class="symbol">Release</span> <span class="keyword">branches? </span>[release/] </span><br><span class="line"><span class="symbol">Hotfix</span> <span class="keyword">branches? </span>[hotfix/] </span><br><span class="line"><span class="symbol">Support</span> <span class="keyword">branches? </span>[support/] </span><br><span class="line"><span class="symbol">Version</span> tag prefix? [v] </span><br><span class="line"><span class="symbol">Hooks</span> <span class="keyword">and </span>filters directory? [/home/ubuntu/study/.git/hooks]</span><br></pre></td></tr></table></figure><h2 id="Git-flow-分支模型的介绍"><a href="#Git-flow-分支模型的介绍" class="headerlink" title="Git flow 分支模型的介绍"></a>Git flow 分支模型的介绍</h2><p>Git flow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到要中央仓库中。</p><ul><li>Master 分支 - 生产分支<br>最为稳定功能比较完整的随时可发布的代码，即代码开发完成，经过测试，没有明显的 bug，才能合并到 master 中。请注意永远不要在 master 分支上直接开发和提交代码，以确保 master 上的代码一直可用。</li><li>Develop 分支 - 开发分支<br>用作平时开发的主分支，并一直存在，永远是功能最新最全的分支，包含所有要发布到下一个 release 的代码，主要用于合并其他分支，比如 feature 分支；如果修改代码，新建 feature 分支修改完再合并到 develop 分支。所有的 feature、release 分支都是从 develop 分支上拉的。</li><li>Feature 分支 - 功能分支<br>这个分支主要是用来开发新的功能，一旦开发完成，通过测试没问题（这个测试，测试新功能没问题），我们合并回 develop 分支进入下一个 release。</li><li>Release 分支 - 发布分支<br>用于发布准备的专门分支。当开发进行到一定程度，或者说快到了既定的发布日，可以发布时，建立一个 release 分支并指定版本号（可以在 finish 的时候添加）。开发人员可以对 release 分支上的代码进行集中测试和修改 bug。（这个测试，测试新功能与已有的功能是否有冲突，兼容性）全部完成经过测试没有问题后，将 release 分支上的代码合并到 master 分支和 develop 分支。</li><li>Hotfix 分支 - 热修复分支<br>用于修复线上代码的 bug。从 master 分支上拉，完成 hotfix 后，打上 tag 我们合并回 master 和 develop 分支。</li></ul><h3 id="功能分支-Feature-分支"><a href="#功能分支-Feature-分支" class="headerlink" title="功能分支 - Feature 分支"></a>功能分支 - Feature 分支</h3><p><img src="/media/15619490256878/20151223121021496.jpg" alt="20151223121021496"></p><p>功能分支：通常为即将发布或者未来发布版开发新的功能，这通常只存在开发者的库中。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到 develop 分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。</p><p>分支命名规则：分支名称以 feature/* 开头</p><ol><li>使用 Git 命令开发功能分支 - Feature 分支流程：</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 开始一项功能的开发工作时, 基于'develop'创建分支</span><br><span class="line">$ git checkout -b <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 推送到远程 -&gt; 可选</span><br><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 在'<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>'功能分支上开发完成后, 提交至仓库</span><br><span class="line">$ git commit -a -m <span class="string">"some feature"</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>. 切换到'develop'分支</span><br><span class="line">$ git checkout develop</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>. 从远程仓库拉去最新'develop'</span><br><span class="line">$ git pull <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>. 'develop'分支合并'<span class="built_in">feature</span>'功能分支   </span><br><span class="line">$ git merge --no-ff <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">7</span>. 推送'develop'分支至远程仓库   </span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">8</span>. 删除'<span class="built_in">feature</span>'功能分支</span><br><span class="line">$ git branch -d <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">9</span>. 删除远程'<span class="built_in">feature</span>'功能分支</span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>–no-ff 标志导致合并操作创建一个新 commit 对象，即使该合并操作可以 fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。</p><p><img src="/media/15619490256878/20151223121138110.jpg" alt="20151223121138110"></p><ol start="2"><li>使用 Git-flow 命令开发功能分支 - Feature 分支流程：</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 增加新特性 P.S.[创建了一个基于'develop'的功能分支'<span class="built_in">some</span>-<span class="built_in">feature</span>', 并切换到这个分支之下]</span><br><span class="line">$ git flow <span class="built_in">feature</span> start <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 完成新特性 P.S.[<span class="number">1</span>. 合并'<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>'分支到'develop';<span class="number">2</span>. 删除这个新特性分支; <span class="number">3</span>. 切换回'develop'分支]</span><br><span class="line">    Summary of actions:</span><br><span class="line">    - The <span class="built_in">feature</span> branch '<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>' was merged into 'develop'</span><br><span class="line">    - Feature branch '<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>' has been locally deleted</span><br><span class="line">    - You are now on branch 'develop'</span><br><span class="line">$ git flow <span class="built_in">feature</span> finsh --no-ff <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 推送'develop'分支至远程仓库   </span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 发布新特性 P.S.[发布新特性分支到远程服务器, 所以, 其它用户也可以使用这分支]</span><br><span class="line">$ git flow <span class="built_in">feature</span> publish <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 取得一个发布的新特性分支 P.S.[取得其它用户发布的新特性分支, 并签出远程的变更]</span><br><span class="line">$ git flow <span class="built_in">feature</span> pull <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 跟踪在 <span class="built_in">origin</span> 上的特性分支]</span><br><span class="line">$ git flow <span class="built_in">feature</span> <span class="built_in">track</span> <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><h3 id="热修复分支-Hotfix-分支"><a href="#热修复分支-Hotfix-分支" class="headerlink" title="热修复分支 - Hotfix 分支"></a>热修复分支 - Hotfix 分支</h3><p><img src="/media/15619490256878/20151223121423096.jpg" alt="20151223121423096"></p><p>热修复分支：热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于 master 分支上对应与线上版本的 tag 创建。</p><p>分支命名规则：分支名称以 hotfix/* 开头</p><ol><li>使用 Git 命令开发热修复分支 - Hotfix 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 基于<span class="string">'master'</span>创建热修复分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix/some-hotfix-0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支上完成紧急修复, 提交至仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"some hotfix"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. <span class="string">'master'</span>分支合并<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 推送<span class="string">'master'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. <span class="string">'develop'</span>分支合并<span class="string">'hotfix/some-hotfix-0.1.1'</span>功能分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 推送<span class="string">'develop'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 删除<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 重新打标签 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10. 提交所有 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Git-flow 命令开发热修复分支 - Hotfix 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 开始 git flow 紧急修复 P.S.[创建了一个基于<span class="string">'master'</span>的热修复分支, 并切换到这个分支之下]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git flow hotfix start 0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 完成新特性 P.S.[1. 合并<span class="string">'hotfix/0.1.1'</span>分支到<span class="string">'master'</span>;2. 给<span class="string">'master 打标签'</span>v0.1.1<span class="string">';3. 合并'</span>v0.1.1<span class="string">'分支到'</span>develop<span class="string">';4. 删除本地'</span>hotfix/v0.1.1<span class="string">'分支; 5. 切换回'</span>develop<span class="string">'分支]</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git flow hotfix finish --no-ff 0.1.1</span></span><br><span class="line">    Summary of actions:</span><br><span class="line">    - Hotfix branch 'hotfix/0.1.1' has been merged into 'master'</span><br><span class="line">    - The hotfix was tagged 'v0.1.1'</span><br><span class="line">    - Hotfix tag 'v0.1.1' has been back-merged into 'develop'</span><br><span class="line">    - Hotfix branch 'hotfix/0.1.1' has been locally deleted</span><br><span class="line">    - You are now on branch 'develop'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 推送<span class="string">'master'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 切换到<span class="string">'develop'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 推送<span class="string">'develop'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure><h3 id="发布分支-Release-分支"><a href="#发布分支-Release-分支" class="headerlink" title="发布分支 - Release 分支"></a>发布分支 - Release 分支</h3><p>发布分支：Release 分支是为新产品的发布做准备的，它允许我们在最后时刻做一些细小的修改，它们允许小 bugs 的修改和准备发布元数据（版本号，开发时间等等）。Release 分支基于 develop 分支创建； 一旦创建了 release 分支，不能在从 develop 分支合并新的改动到 release 分支，可以基于 release 分支进行测试和 bug 修改，测试不用再另外创建用于测试的分支。</p><p>分支命名规则：分支名称以 release/* 开头</p><ol><li>使用 Git 命令开发发布分支 - Release 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 基于<span class="string">'develop'</span>创建发布分支, 在此分支上小 bugs 的修改和准备发布元数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release/some-release-0.1.1 develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. <span class="string">'master'</span>分支合并<span class="string">'release/some-release-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 推送<span class="string">'master'</span>发布分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. <span class="string">'develop'</span>开发分支合并<span class="string">'release/some-release-0.1.1'</span>功能分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 推送<span class="string">'develop'</span>开发分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 删除<span class="string">'release/some-release-0.1.1'</span>发布分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 重新打标签 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10. 提交所有 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Git-flow 命令开发发布分支 - Release 分支流程：</li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 开始准备 <span class="keyword">release</span> 版本 P.S.[创建了一个基于<span class="symbol">'develop</span>'的热修复分支, 并切换到这个分支之下]</span><br><span class="line">$ git flow <span class="keyword">release</span> start <span class="number">0.1</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 完成 <span class="keyword">release</span> 版本 P.S.[<span class="number">1</span>. 合并<span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>'分支到<span class="symbol">'master</span>';<span class="number">2</span>. 给<span class="symbol">'master</span> 打标签<span class="symbol">'v0</span>.<span class="number">1.1</span>';<span class="number">3</span>. 合并<span class="symbol">'v0</span>.<span class="number">1.1</span>'分支到<span class="symbol">'develop</span>';<span class="number">4</span>. 删除本地<span class="symbol">'release</span>/v0.<span class="number">1.1</span>'分支; <span class="number">5</span>. 切换回<span class="symbol">'develop</span>'分支]</span><br><span class="line">$ git flow <span class="keyword">release</span> finish <span class="number">0.1</span>.<span class="number">1</span></span><br><span class="line">    Summary <span class="keyword">of</span> actions:</span><br><span class="line">    - <span class="keyword">Release</span> branch <span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>' has been merged into <span class="symbol">'master</span>'</span><br><span class="line">    - The <span class="keyword">release</span> was tagged <span class="symbol">'v0</span>.<span class="number">1.1</span>'</span><br><span class="line">    - <span class="keyword">Release</span> tag <span class="symbol">'v0</span>.<span class="number">1.1</span>' has been back-merged into <span class="symbol">'develop</span>'</span><br><span class="line">    - <span class="keyword">Release</span> branch <span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>' has been locally deleted</span><br><span class="line">    - You are now <span class="keyword">on</span> branch <span class="symbol">'develop</span>'</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 切换到<span class="symbol">'master</span>'分支</span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>. 推送<span class="symbol">'master</span>'分支至远程仓库   </span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>. 切换到<span class="symbol">'develop</span>'分支</span><br><span class="line">$ git checkout develop</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>. 推送<span class="symbol">'develop</span>'分支至远程仓库   </span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><h2 id="Git-的分支工作流与-Pull-Request"><a href="#Git-的分支工作流与-Pull-Request" class="headerlink" title="Git 的分支工作流与 Pull Request"></a>Git 的分支工作流与 Pull Request</h2><p>Pull request 是 github/bitbucket 给开发人员实现便利合作提供的一个 feature。他们提供一个用户友好的 web 界面在进代码之前来讨论这些变更。</p><p>简单说，Pull request 是一种为了开发人员通知 team member 他们已经完成了一个 feature 的机制。一旦他们的 feature branch ready 了，开发人员就通过他们的 github 帐号执行一个 pull request。这将使得每个相干人知晓这个事件，他们需要 review 这个 feature branch 的代码，并且需要决定是否 merge 到 master 分支上去。</p><p>但是 pull request 并不仅仅是一种 notification, 他也是一个专门用于讨论这些即将落地代码的细节的论坛。如果有任何问题或意见，同事们可以在 pull request 中提 comments，甚至直接在这个 Pull request 中修改要落地的代码。所有这些活动都由 pull request 来跟踪。</p><p>下面通过例子介绍：热修复分支 - Hotfix 分支 Git flow 工作流和 Pull Request</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> <span class="string">'master'</span>创建<span class="string">'hotfix'</span>分支并发布<span class="string">'hotfix'</span>分支到远程服务器</span><br><span class="line"><span class="symbol">$</span> git flow hotfix start [hotfix version <span class="keyword">No</span>.] [release version <span class="keyword">No</span>.]</span><br><span class="line"><span class="symbol">$</span> git flow hotfix publish [hotfix version <span class="keyword">No</span>.] </span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> <span class="string">'developer'</span>更新代码, 切换到<span class="string">'hotfix'</span>分支</span><br><span class="line"><span class="symbol">$</span> git pull</span><br><span class="line"><span class="symbol">$</span> git checkout hotfix/[hotfix version <span class="keyword">No</span>.]</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> <span class="string">'developer'</span>修复代码, 然后提交到远程仓库, 申请 pull request 从 hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name] 到 hotfix/[hotfix version <span class="keyword">No</span>.]</span><br><span class="line"><span class="symbol">$</span> git checkout –b hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name]</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// todo fix bug</span></span><br><span class="line"><span class="symbol">$</span> git push –u origin hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name]</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// create pull request to hotfix/[hotfix version No.]</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> <span class="string">'master'</span>处理 merge 后, 测试人员跟进测试; 无误后, 申请 pull request 从 hotfix/[hotfix version <span class="keyword">No</span>.] 到 master</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// create pull request to master</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> <span class="string">'master'</span>merge to master. 针对项目维护者: git pull 和 git merge 是最常用的 merge Pull Requests 的方式, 在命令行下 merge 之后, PullRequest 也会相应地自动关闭; 或者在网站上点击同意合并</span><br><span class="line"><span class="symbol">$</span> git flow hotfix finish --<span class="keyword">no</span>-ff [hotfix version <span class="keyword">No</span>.]</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://weyunx.com/2019/02/28/gitflow-branching-model/" target="_blank" rel="noopener">「译」浅谈 Gitflow</a><br>[2]. <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">git-flow 备忘清单</a><br>[3]. <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a></p><hr><h2 id="Git-在团队中的最佳实践系列"><a href="#Git-在团队中的最佳实践系列" class="headerlink" title="Git 在团队中的最佳实践系列"></a>Git 在团队中的最佳实践系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="c0dca125.html">Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。&lt;/p&gt;
&lt;p&gt;Git flow 工作流是经典模型，体现了工作流的经验和精髓。随着项目过程复杂化，会感受到这个工作流中深思熟虑和威力！Git flow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。在这章节中我们将一起学习一个当前非常流行的工作流 Git flow。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.maoning.pro/categories/Git/"/>
    
    
      <category term="Git flow" scheme="http://blog.maoning.pro/tags/Git-flow/"/>
    
      <category term="工作流" scheme="http://blog.maoning.pro/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</title>
    <link href="http://blog.maoning.pro/archives/f30530aa.html"/>
    <id>http://blog.maoning.pro/archives/f30530aa.html</id>
    <published>2019-06-03T11:45:12.000Z</published>
    <updated>2019-08-13T11:34:52.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客《Java 并发编程之美（四）：深入剖析 ThreadLocal》提到 ThreadLocal 变量的基本使用方式，ThreadLocal 是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。但是在实际的开发中，有这样的一种需求：父线程生成的变量需要传递到子线程中进行使用，那么在使用 ThreadLocal 似乎就解决不了这个问题。由于 ThreadLocal 设计之初就是为了绑定当前线程，如果希望当前线程的 ThreadLocal 能够被子线程使用，实现方式就会相当困难。在此背景下，InheritableThreadLocal 应运而生，使用 InheritableThreadLocal 这个变量就可以轻松的在子线程中依旧使用父线程中的本地变量。</p><a id="more"></a><h2 id="ThreadLocal-与-InheritableThreadLocal-区别"><a href="#ThreadLocal-与-InheritableThreadLocal-区别" class="headerlink" title="ThreadLocal 与 InheritableThreadLocal 区别"></a>ThreadLocal 与 InheritableThreadLocal 区别</h2><p>ThreadLocal 声明的变量是线程私有的成员变量，每个线程都有该变量的副本，线程对变量的修改对其他线程不可见。</p><p>InheritableThreadLocal 声明的变量同样是线程私有的，但是子线程可以使用同样的 InheritableThreadLocal 类型变量从父线程继承 InheritableThreadLocal 声明的变量，父线程无法拿到其子线程的。即使可以继承，但是子线程对变量的修改对父线程也是不可见的。</p><h2 id="对-InheritableThreadLocal-的理解"><a href="#对-InheritableThreadLocal-的理解" class="headerlink" title="对 InheritableThreadLocal 的理解"></a>对 InheritableThreadLocal 的理解</h2><p>InheritableThreadLocal 类是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p><p>ThreadLocal 是不支持继承性的，所谓继承性也是针对父线程和子线程来说，代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scratch</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> final ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in main"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable in main</span></span><br><span class="line"><span class="comment">// Thread-0:null</span></span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 用于子线程能够拿到父线程往 ThreadLocal 里设置的值，代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scratch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in main"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable in main</span></span><br><span class="line"><span class="comment">// Thread-0:I'm variable in main</span></span><br></pre></td></tr></table></figure><h2 id="深入解析-InheritableThreadLocal-类"><a href="#深入解析-InheritableThreadLocal-类" class="headerlink" title="深入解析 InheritableThreadLocal 类"></a>深入解析 InheritableThreadLocal 类</h2><p>InheritableThreadLocal 类重写了 ThreadLocal 的 3 个函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">ThreadLocal&lt;T&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该函数在父线程创建子线程，向子线程赋值 InheritableThreadLocal 变量时使用</span></span><br><span class="line"><span class="comment">     * 可重写 childValue() 方法实现子线程与父线程之间互不影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">T</span> childValue(<span class="type">T</span> parentValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于重写了 getMap，操作 InheritableThreadLocal 时，</span></span><br><span class="line"><span class="comment">     * 将只影响 Thread 类中的 inheritableThreadLocals 变量，</span></span><br><span class="line"><span class="comment">     * 与 threadLocals 变量不再有关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> getMap(<span class="type">Thread</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似于 getMap，操作 InheritableThreadLocal 时，</span></span><br><span class="line"><span class="comment">     * 将只影响 Thread 类中的 inheritableThreadLocals 变量，</span></span><br><span class="line"><span class="comment">     * 与 threadLocals 变量不再有关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void createMap(<span class="type">Thread</span> t, <span class="type">T</span> firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="type">ThreadLocalMap</span>(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-赋值"><a href="#InheritableThreadLocal-赋值" class="headerlink" title="InheritableThreadLocal 赋值"></a>InheritableThreadLocal 赋值</h3><p>从源码上看，跟 ThreadLocal 不一样的无非是 ThreadLocalMap 的引用不一样了，从逻辑上来讲，这并不能做到子线程得到父线程里的值。那么秘密在那里呢？通过跟踪 Thread 的构造方法，你能够发现是在构造 Thread 对象的时候对父线程的 InheritableThreadLocal 进行了赋值。下面是 Thread 的部分源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认人构造方法, 会调用 init 方法进行初使化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Thread() &#123;</span><br><span class="line">        <span class="keyword">init</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终初始化线程的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void <span class="keyword">init</span>(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc,</span><br><span class="line">                      boolean inheritThreadLocals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parent 为当前线程, 也就是调用了 new Thread(); 方法的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里会继承父线程是否为后台线程的属性还有父线程的优先级</span></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 这里是重点, 当父线程的 inheritableThreadLocals 不为空的时候, 会调用 ThreadLocal.createInheritedMap 方法, 传入的是父线程的 inheritableThreadLocals。原来复制变量的秘密在这里</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过跟踪 Thread 的构造方法，我们发现只要父线程在构造子线程（调用 new Thread()）的时候 inheritableThreadLocals 变量不为空。新生成的子线程会通过 ThreadLocal.createInheritedMap 方法将父线程 inheritableThreadLocals 变量有的对象复制到子线程的 inheritableThreadLocals 变量上。这样就完成了线程间变量的继承与传递。</p><h3 id="ThreadLocal-createInheritedMap"><a href="#ThreadLocal-createInheritedMap" class="headerlink" title="ThreadLocal.createInheritedMap"></a>ThreadLocal.createInheritedMap</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 map, 构造一个新的 ThreadLocalMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> class ThreadLocalMap &#123;</span><br><span class="line">        <span class="comment">// 这个 private 的构造方法就是专门给 ThreadLocal 使用的</span></span><br><span class="line">        <span class="keyword">private</span> ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">            <span class="comment">// ThreadLocalMap 还是用 Entry 数组来存储对象的</span></span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="built_in">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            <span class="comment">// 创建跟父线程相同大小的 table</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line">            <span class="comment">// 这里是复制 parentMap 数据的逻辑</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得到父线程中变量对应的 key, 即 ThreadLocal 对象</span></span><br><span class="line">                    ThreadLocal <span class="built_in">key</span> = e.<span class="built_in">get</span>();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">key</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 此处会调用 InheritableThreadLocal 重写的方法, 默认直接返回入参值</span></span><br><span class="line">                        <span class="keyword">Object</span> value = <span class="built_in">key</span>.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</span><br><span class="line">                        <span class="comment">// 通过位与运算找到索引位置</span></span><br><span class="line">                        <span class="built_in">int</span> h = <span class="built_in">key</span>.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">// 如果该索引位置已经被占, 则寻找下一个索引位置</span></span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        <span class="comment">// 将 Entry 放在对应的位置</span></span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        <span class="built_in">size</span>++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InheritableThreadLocal-和线程池搭配使用存在的问题"><a href="#InheritableThreadLocal-和线程池搭配使用存在的问题" class="headerlink" title="InheritableThreadLocal 和线程池搭配使用存在的问题"></a>InheritableThreadLocal 和线程池搭配使用存在的问题</h2><h3 id="问题展示"><a href="#问题展示" class="headerlink" title="问题展示"></a>问题展示</h3><p>代码示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; localVariable = <span class="keyword">new</span> <span class="type">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">2</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.main 线程第一次赋值 "I'm variable_1 in main"localVariable.set("I'm variable_1 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.wait for all to finish[等待线程 pool-1-thread-1/pool-1-thread-2 执行完后, 在对主线程的 InheritableThreadLocal 进行赋值, 查看赋值后, 线程池中线程的 InheritableThreadLocal 是否发生变法]</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.main 线程第二次赋值 "I'm variable_2 in main"localVariable.set("I'm variable_2 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch doneSignal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// main:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br></pre></td></tr></table></figure><p>前后两次调用获取的值是一开始赋值的值，因为线程池中是缓存使用过的线程，当线程被重复调用的时候并没有再重新初始化 init() 线程，而是直接使用已经创建过的线程，所以这里的值并不会被再次操作。因为实际的项目中线程池的使用频率非常高，每一次从线程池中取出线程不能够直接使用之前缓存的变量，所以要解决这一个问题，网上大部分是推荐使用 alibaba 的开源项目 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a>。</p><h3 id="transmittable-thread-local"><a href="#transmittable-thread-local" class="headerlink" title="transmittable-thread-local"></a>transmittable-thread-local</h3><p>JDK 的 InheritableThreadLocal 类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的 ThreadLocal 值传递已经没有意义，应用需要的实际上是把任务提交给线程池时的 ThreadLocal 值传递到任务执行时。</p><p>在 ThreadLocal 的需求场景即是 TTL（装饰器模式）的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的组件情况下传递 ThreadLocal』则是 TTL 目标场景。下面是几个典型场景例子：1、分布式跟踪系统；2、日志收集记录系统上下文；3 应用容器或上层框架跨应用代码给下层 SDK 传递信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; localVariable = <span class="keyword">new</span> <span class="type">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 额外的处理，生成修饰了的对象 executorService</span></span><br><span class="line">        executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.main 线程第一次赋值 "I'm variable_1 in main"localVariable.set("I'm variable_1 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.wait for all to finish[等待线程 pool-1-thread-1/pool-1-thread-2 执行完后, 在对主线程的 InheritableThreadLocal 进行赋值, 查看赋值后, 线程池中线程的 InheritableThreadLocal 是否发生变法]</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.main 线程第二次赋值 "I'm variable_2 in main"localVariable.set("I'm variable_2 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch doneSignal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// main:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_2 in main</span></span><br></pre></td></tr></table></figure><p>整个过程的完整时序图：</p><p><img src="/media/15633498026981/r45yw78ty.png" alt="r45yw78ty"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ThreadLocal 和 InheritableThreadLocal 本质上只是为了方便编码给的工具类，具体存数据是 ThreadLocalMap 对象。</li><li>ThreadLocalMap 存的 key 对象是 ThreadLocal，value 就是真正需要存的业务对象。</li><li>Thread 里通过两个变量持用 ThreadLocalMap 对象，分别为：threadLocals 和 inheritableThreadLocals。</li><li>InheritableThreadLocal 之所以能够完成线程间变量的传递，是在 newThread() 的时候对 inheritableThreadLocals 对象里的值进行了复制。</li><li>子线程通过继承得到的 InheritableThreadLocal 里的值与父线程里的 InheritableThreadLocal 的值具有相同的引用，如果父子线程想实现不影响各自的对象，可以重写 InheritableThreadLocal 的 childValue 方法。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/1af4f7582b80" target="_blank" rel="noopener">ThreadLocal 和 InheritableThreadLocal 深入分析</a><br>[2]. <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a><br>[3]. <a href="https://www.jianshu.com/p/94ba4a918ff5" target="_blank" rel="noopener">InheritableThreadLocal 详解</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客《Java 并发编程之美（四）：深入剖析 ThreadLocal》提到 ThreadLocal 变量的基本使用方式，ThreadLocal 是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。但是在实际的开发中，有这样的一种需求：父线程生成的变量需要传递到子线程中进行使用，那么在使用 ThreadLocal 似乎就解决不了这个问题。由于 ThreadLocal 设计之初就是为了绑定当前线程，如果希望当前线程的 ThreadLocal 能够被子线程使用，实现方式就会相当困难。在此背景下，InheritableThreadLocal 应运而生，使用 InheritableThreadLocal 这个变量就可以轻松的在子线程中依旧使用父线程中的本地变量。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://blog.maoning.pro/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="InheritableThreadLocal" scheme="http://blog.maoning.pro/tags/InheritableThreadLocal/"/>
    
      <category term="ThreadLocal" scheme="http://blog.maoning.pro/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构（一）：那些年面试常见的 Java 排序算法</title>
    <link href="http://blog.maoning.pro/archives/9c51d4e.html"/>
    <id>http://blog.maoning.pro/archives/9c51d4e.html</id>
    <published>2019-05-23T09:56:00.000Z</published>
    <updated>2019-10-11T10:31:36.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排序就是将一组对象按照某种逻辑顺序重新排列的过程。排序在数据处理和现代科学计算中有很重要的地位，应用于很多领域。排序问题一直是程序员工作与面试的重点，今天特意整理研究下与大家共勉。本文将介绍一下常见的排序算法以及 Java 代码实现，如有问题，欢迎指正！</p><a id="more"></a><h2 id="各算法原理及代码实现"><a href="#各算法原理及代码实现" class="headerlink" title="各算法原理及代码实现"></a>各算法原理及代码实现</h2><p><img src="/media/15565217714788/1556538098111.jpg" alt="1556538098111"></p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><img src="/media/15565217714788/15565238194673.gif" alt="15565238194673"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numbers.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[j] &lt; numbers[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换两数位置</span></span><br><span class="line">                <span class="keyword">int</span> temp = numbers[j];</span><br><span class="line">                numbers[j] = numbers[j + <span class="number">1</span>];</span><br><span class="line">                numbers[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>选择一个基准元素，通常选择第一个元素或者最后一个元素，通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素，此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p><p><img src="/media/15565217714788/15565242837841.gif" alt="15565242837841"></p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> quickSort(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="comment">// 找到递归算法的出口</span></span><br><span class="line">    <span class="built_in">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = numbers[low], <span class="built_in">begin</span> = low, <span class="built_in">end</span> = high;</span><br><span class="line">    <span class="built_in">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="built_in">while</span> (low &lt; high &amp;&amp; numbers[high] &gt;= temp) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比中轴小的记录移到低端</span></span><br><span class="line">        numbers[low] = numbers[high];</span><br><span class="line">        <span class="built_in">while</span> (low &lt; high &amp;&amp; numbers[low] &lt;= temp) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比中轴大的记录移到高端</span></span><br><span class="line">        numbers[high] = numbers[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中轴记录到尾</span></span><br><span class="line">    numbers[low] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对低字段表进行递归排序</span></span><br><span class="line">    quickSort(numbers, <span class="built_in">begin</span>, low - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对高字段表进行递归排序</span></span><br><span class="line">    quickSort(numbers, high + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三向切分快速排序"><a href="#三向切分快速排序" class="headerlink" title="三向切分快速排序"></a>三向切分快速排序</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> quickSort3Way(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">    <span class="built_in">if</span> (low &gt;= high) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = numbers[low], <span class="built_in">begin</span> = low, i = low + <span class="number">1</span>, <span class="built_in">end</span> = high;</span><br><span class="line">    <span class="built_in">while</span> (i &lt;= high) &#123;</span><br><span class="line">        <span class="built_in">if</span> (numbers[i] &lt; temp) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = numbers[i];</span><br><span class="line">            numbers[i] = numbers[low];</span><br><span class="line">            numbers[low] = t;</span><br><span class="line">            i++;</span><br><span class="line">            low++;</span><br><span class="line">        &#125; <span class="built_in">else</span> <span class="built_in">if</span> (numbers[i] &gt; temp) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = numbers[i];</span><br><span class="line">            numbers[i] = numbers[high];</span><br><span class="line">            numbers[high] = t;</span><br><span class="line">            high--;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quickSort3Way(numbers, <span class="built_in">begin</span>, low - <span class="number">1</span>);</span><br><span class="line">    quickSort3Way(numbers, high + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p>直接选择排序是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾(目前已被排序的序列)。以此类推，直到所有元素均排序完毕。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>假设数据放在一个数组 a 中，且数组的长度是 N，则直接选择排序的流程为：</p><ul><li>从 a[0]-a[N-1]中选出最小的数据，然后与 a[0]交换位置</li><li>从 a[1]-a[N-1]中选出最小的数据，然后与 a[1]交换位置（第 1 步结束后 a[0]就是 N 个数的最小值）</li><li>从 a[2]-a[N-1]中选出最小的数据，然后与 a[2]交换位置（第 2 步结束后 a[1]就是 N-1 个数的最小值）</li><li>以此类推，N-1 次排序后，待排数据就已经按照从小到大的顺序排列了。</li></ul><p><img src="/media/15565217714788/15565245438056.gif" alt="15565245438056"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 待确定的位置</span></span><br><span class="line">        <span class="keyword">int</span> k = i;</span><br><span class="line">        <span class="comment">// 选择出应该在第 i 个位置的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; numbers.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[j] &lt; numbers[k]) &#123;</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在内层循环结束, 也就是找到本轮循环的最小的数以后, 再进行交换</span></span><br><span class="line">        <span class="keyword">if</span> (k != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[k];</span><br><span class="line">            numbers[k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>堆排序算法和直接选择排序算法最大的不同在于，堆排序算法充分利用大顶堆和完全二叉树的性质，保留每次排序后的结构，同时由于每次比较只是比较根节点和它的子节点，因此大大降低了比较的次数和交换的次数，从而提高效率。</p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>假设数据放在一个数组 a 中，且数组的长度是 N：</p><ul><li>以数组 a 为数据，建立一个大顶堆（这样对于二叉树的每个节点，根节点总是比子节点大，其实没必要要求二叉树的每个子树也是大顶堆）</li><li>交换大顶堆的根节点和数组 a 中的最后一个节点（最后一个节点不在参与后边的工作）</li><li>重复上边的工作，经过 N-1 次后，数组 a 已经排好序。</li></ul><p><img src="/media/15565217714788/15565248890502.gif" alt="15565248890502"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">headSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将待排序的序列构建成一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numbers.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; </span><br><span class="line">        <span class="comment">// 从第一个非叶子结点从下至上, 从右至左调整结构</span></span><br><span class="line">        adjustHeap(numbers, i, numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整堆结构 + 交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = numbers.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶记录和当前未经排序子序列的最后一个记录交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = numbers[<span class="number">0</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[j];</span><br><span class="line">        numbers[j] = temp;</span><br><span class="line">        <span class="comment">// 重新对堆进行调整</span></span><br><span class="line">        adjustHeap(numbers, <span class="number">0</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先取出当前元素 i</span></span><br><span class="line">    <span class="keyword">int</span> temp = numbers[low];</span><br><span class="line">    <span class="comment">// 从 low 结点的左子结点开始, 也就是 2low+1 处开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = low * <span class="number">2</span> + <span class="number">1</span>; k &lt; high; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果左子结点小于右子结点, k 指向右子结点</span></span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; high &amp;&amp; numbers[k] &lt; numbers[k + <span class="number">1</span>]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果子节点大于父节点, 将子节点值赋给父节点(不用进行交换)</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[k] &gt; temp) &#123;</span><br><span class="line">            numbers[low] = numbers[k];</span><br><span class="line">            low = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 temp 值放到最终的位置</span></span><br><span class="line">    numbers[low] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>插入排序是一种通过不断地把新元素插入到已排好序的数据中的排序算法，常用的插入排序算法包括直接插入排序和希尔（Shell）排序，直接插入排序实现比较简单，但是直接插入没有充分的利用已插入的数据已经排序这个事实，因此有很多针对直接插入排序改进的算法。</p><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>在要排序的一组数中，假设前面 (n-1)[n&gt;=2] 个数已经是排好顺序的，现在要把第 n 个数插到前面的有序数中，使得这 n 个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p><p>也就是说，先从无序区拿第一个记录出来，它是有序的，然后把无序区中的记录一个一个插入到其中，那么插入之后是有序的，所以直到最后都是有序的。</p><p><img src="/media/15565217714788/15565246207690.gif" alt="15565246207690"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 保存每次需要插入的那个数</span></span><br><span class="line">        <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 假如 temp 比前面的值小, 则将前面的值后移</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt;= <span class="number">1</span> &amp;&amp; temp &lt; numbers[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            numbers[j] = numbers[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        numbers[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>希尔排序是插入排序的一种。是针对直接插入排序算法的改进。该方法又称缩小增量排序，因 DL．Shell 于 1959 年提出而得名。</p><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>先取定一个小于 n 的整数 d1 作为第 1 个增量，把文件的全部记录分成 d1 个组，所有距离为 d1 的倍数的记录放在同一个组中，在各组内进行直接插入排序；然后，取第 2 个增量 d2&lt;d1 重复上述的分组和排序，直至所取的增量 d1=1(dt&lt;dt-1&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><p><img src="/media/15565217714788/15565251647186.jpg" alt="15565251647186"></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每次将步长缩短为原来的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = numbers.length / <span class="number">2</span>; h &gt; <span class="number">0</span>; h /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="comment">// 保存每次需要插入的那个数</span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= h &amp;&amp; temp &lt; numbers[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="comment">// 如想从小到大排只需修改这里</span></span><br><span class="line">                numbers[j] = numbers[j - h];</span><br><span class="line">            &#125;</span><br><span class="line">            numbers[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法, 该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="/media/15565217714788/15565247200768.gif" alt="15565247200768"></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 找出中间索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 对左边数组进行递归</span></span><br><span class="line">        mergeSort(numbers, low, mid);</span><br><span class="line">        <span class="comment">// 对右边数组进行递归</span></span><br><span class="line">        mergeSort(numbers, mid + <span class="number">1</span>, high);</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        merge(numbers, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个新空间来保存排序后数组</span></span><br><span class="line">    <span class="keyword">int</span>[] mergeArr = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// i、j 是检测指针, k 是存放指针</span></span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &lt; numbers[j]) &#123;</span><br><span class="line">            mergeArr[k++] = numbers[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mergeArr[k++] = numbers[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把左边剩余的元素导入</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        mergeArr[k++] = numbers[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把右边剩余的元素导入</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        mergeArr[k++] = numbers[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新排好序的数组放入元素相应的位置中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; mergeArr.length; m++) &#123;</span><br><span class="line">        numbers[low + m] = mergeArr[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="大话数据结构系列"><a href="#大话数据结构系列" class="headerlink" title="大话数据结构系列"></a>大话数据结构系列</h2><ul><li><a href="9c51d4e.html">大话数据结构（一）：那些年面试常见的 Java 排序算法</a></li><li><a href="6e0aae0d.html">大话数据结构（二）：大白话布隆过滤器 Bloom Filter</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;排序就是将一组对象按照某种逻辑顺序重新排列的过程。排序在数据处理和现代科学计算中有很重要的地位，应用于很多领域。排序问题一直是程序员工作与面试的重点，今天特意整理研究下与大家共勉。本文将介绍一下常见的排序算法以及 Java 代码实现，如有问题，欢迎指正！&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.maoning.pro/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://blog.maoning.pro/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序算法" scheme="http://blog.maoning.pro/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式设计之美（一）：主流分布式锁实现方案</title>
    <link href="http://blog.maoning.pro/archives/e8097e40.html"/>
    <id>http://blog.maoning.pro/archives/e8097e40.html</id>
    <published>2019-04-03T08:38:00.000Z</published>
    <updated>2019-10-11T10:09:28.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式系统的 CAP 理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项”。所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。</p><p>针对分布式锁的实现，目前比较常用的有以下几种方案：1、基于数据库实现分布式锁；2、基于缓存 Redis 实现分布式锁；3、基于 Zookeeper 实现分布式锁。下面我将谈谈它们各种的实现方案。</p><a id="more"></a><h2 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h2><h3 id="基于单机版-Redis-分布式锁-SETNX"><a href="#基于单机版-Redis-分布式锁-SETNX" class="headerlink" title="基于单机版 Redis 分布式锁 SETNX"></a>基于单机版 Redis 分布式锁 SETNX</h3><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><p>命令 SET resource-name anystring NX EX max-lock-time 是一种在 Redis 中实现锁的简单方法。客户端执行以上的命令：如果服务器返回 OK，那么这个客户端获得锁；如果服务器返回 NIL，那么客户端获取锁失败，可以在稍后再重试。设置的过期时间到达之后，锁将自动释放。</p><p>可以通过以下修改，让这个锁实现更健壮：1、不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。2、不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 锁的获取：</span><br><span class="line"><span class="keyword">SET</span> resource_name my_random_value NX PX <span class="number">30000</span></span><br><span class="line"></span><br><span class="line">// 锁的释放：</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,<span class="keyword">KEYS</span>[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,<span class="keyword">KEYS</span>[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4><p>1、组件依赖：通过 Maven 引入 Jedis 开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现分布式锁</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">Long</span> RELEASE_SUCCESS = <span class="number">1</span>L;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELEASE_LOCK_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis      Redis 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey    加锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId   加锁客户端唯一标识(采用 UUID)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 锁过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Boolean</span> acquireLock(Jedis jedis, String lockKey, String clientId, <span class="keyword">int</span> expireTime) &#123;</span><br><span class="line">        <span class="comment">// String nxxx,NX|XX; String expx,EX|PX, EX = seconds, PX = milliseconds;</span></span><br><span class="line">        String result = jedis.set(lockKey, clientId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="comment">// 如果 setNX 成功, 返回 "OK"; 如果 setNX 失败, 返回 null;</span></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放 Redis 全局锁</span></span><br><span class="line"><span class="comment">     * P.S.</span></span><br><span class="line"><span class="comment">     * 1. 锁的释放必须使用 lua 脚本, 保证操作的原子性; 使用 lua 脚本使 get 与 del 方法执行成为原子性</span></span><br><span class="line"><span class="comment">     * 2. 为了保证锁被锁的持有者释放, 使用 lua 脚本删除 redis 中匹配 value 的 key, 可以避免由于方法执行时间过长而 redis 锁自动过期失效的时候误删其他线程的锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis    Redis 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey  加锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId 加锁客户端唯一标识(采用 UUID)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Boolean</span> releaseLock(Jedis jedis, String lockKey, String clientId) &#123;</span><br><span class="line">        <span class="comment">// 释放锁的时候, 有可能因为持锁之后方法执行时间大于锁的有效期, 此时有可能已经被另外一个线程持有锁, 所以不能直接删除</span></span><br><span class="line">        Object result = jedis.<span class="keyword">eval</span>(RELEASE_LOCK_SCRIPT, Collections.singletonList(lockKey), Collections.singletonList(clientId));</span><br><span class="line">        <span class="keyword">return</span> RELEASE_SUCCESS.equals(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、try-with-resources 实现：大家在写程序的时候是不是总忘记释放锁呢？就像以前对流操作时，忘记了关闭流。从 Java 7 开始，加入了 try-with-resources 的方式，它可以 自动的执行 close() 方法，释放资源，再也不用写 finally 块了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RELEASE_LOCK_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line">    <span class="keyword">private</span> String lockKey;</span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expireTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造全局分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis      Redis 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey    加锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId   加锁客户端唯一标识(采用 UUID)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 锁过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String clientId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jedis = jedis;</span><br><span class="line">        <span class="keyword">this</span>.lockKey = lockKey;</span><br><span class="line">        <span class="keyword">this</span>.clientId = clientId;</span><br><span class="line">        <span class="keyword">this</span>.expireTime = expireTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Boolean <span class="title">acquireLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// String nxxx,NX|XX; String expx,EX|PX, EX = seconds, PX = milliseconds;</span></span><br><span class="line">        String result = jedis.set(lockKey, clientId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">        <span class="comment">// 如果 setNX 成功, 返回 "OK"; 如果 setNX 失败, 返回 null;</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> LOCK_SUCCESS.<span class="title">equals</span><span class="params">(result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放 Redis 全局锁</span></span><br><span class="line"><span class="comment">     * P.S.</span></span><br><span class="line"><span class="comment">     * 1. 锁的释放必须使用 lua 脚本, 保证操作的原子性; 使用 lua 脚本使 get 与 del 方法执行成为原子性</span></span><br><span class="line"><span class="comment">     * 2. 为了保证锁被锁的持有者释放, 使用 lua 脚本删除 redis 中匹配 value 的 key, 可以避免由于方法执行时间过长而 redis 锁自动过期失效的时候误删其他线程的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 释放锁的时候, 有可能因为持锁之后方法执行时间大于锁的有效期, 此时有可能已经被另外一个线程持有锁, 所以不能直接删除</span></span><br><span class="line">        jedis.eval(RELEASE_LOCK_SCRIPT, Collections.singletonList(lockKey), Collections.singletonList(clientId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h4><p>1、组件依赖：通过 Maven 引入 spring-boot-starter-data-redis 开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现分布式锁</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributedLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该加锁方法仅针对单实例 Redis 可实现分布式加锁;</span></span><br><span class="line"><span class="comment">     * P.S.</span></span><br><span class="line"><span class="comment">     * 1. 单机版分布式锁 SETNX, 所谓 SETNX, 是「SET if Not eXists」的缩写;</span></span><br><span class="line"><span class="comment">     * 2. SET resource_name my_random_value NX PX 30000 因此当多个客户端去争抢执行上锁或解锁代码时, 最终只会有一个客户端执行成功. 同时 set 命令还可以指定 key 的有效期, 这样即使当前客户端奔溃, 过一段时间锁也会被 redis 自动释放, 这就给了其它客户端获取锁的机会.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey  加锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId 加锁客户端唯一标识(采用 UUID)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout  锁过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 锁过期单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Boolean</span> acquireLock(String lockKey, String clientId, <span class="built_in">Long</span> timeout, TimeUnit timeUnit) &#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForValue().setIfAbsent(lockKey, clientId, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放 Redis 全局锁</span></span><br><span class="line"><span class="comment">     * P.S.</span></span><br><span class="line"><span class="comment">     * 1. 锁的释放必须使用 lua 脚本, 保证操作的原子性; 使用 lua 脚本使 get 与 del 方法执行成为原子性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey  加锁键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clientId 加锁客户端唯一标识(采用 UUID)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Boolean</span> releaseLock(String lockKey, String clientId) &#123;</span><br><span class="line">        <span class="comment">// 释放锁的时候, 有可能因为持锁之后方法执行时间大于锁的有效期, 此时有可能已经被另外一个线程持有锁, 所以不能直接删除</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">Boolean</span>) stringRedisTemplate.execute((RedisCallback&lt;Object&gt;) connection -&gt; &#123;</span><br><span class="line">            <span class="comment">// 为了保证锁被锁的持有者释放, 使用 lua 脚本删除 redis 中匹配 value 的 key, 可以避免由于方法执行时间过长而 redis 锁自动过期失效的时候误删其他线程的锁</span></span><br><span class="line">            String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">            <span class="keyword">return</span> connection.&lt;<span class="built_in">Boolean</span>&gt;eval(script.getBytes(), ReturnType.BOOLEAN, <span class="number">1</span>, lockKey.getBytes(), clientId.getBytes());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>上述代码实现，仅对 redis 单实例架构有效，当面对 redis 集群时就无效了。但是一般情况下，我们的 redis 架构多数会做成 “主备” 模式，然后再通过 redis 哨兵实现主从切换，这种模式下我们的应用服务器直接面向主机，也可看成是单实例，因此上述代码实现也有效。但是当在主机宕机，从机被升级为主机的一瞬间的时候，如果恰好在这一刻，由于 redis 主从复制的异步性，导致从机中数据没有即时同步，那么上述代码依然会无效，导致同一资源有可能会产生两把锁，违背了分布式锁的原则。</p><h3 id="基于-Redis-的-RedLock-算法"><a href="#基于-Redis-的-RedLock-算法" class="headerlink" title="基于 Redis 的 RedLock 算法"></a>基于 Redis 的 RedLock 算法</h3><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。Redis 的作者提出了 RedLock 的解决方案。方案非常的巧妙和简洁。RedLock 的核心思想就是，同时使用多个 Redis Master 来冗余，且这些节点都是完全的独立的，也不需要对这些节点之间的数据进行同步。</p><p>假设我们有 N 个 Redis 节点，N 应该是一个大于 2 的奇数。RedLock 的实现步骤：</p><ul><li>获取当前 Unix 时间，以毫秒为单位。</li><li>使用上文提到的方法依次获取 N 个节点的 Redis 锁。</li><li>如果获取到的锁的数量大于（N/2+1）个，且获取的时间小于锁的有效时间（lock validity time）就认为获取到了一个有效的锁。</li><li>如果获取锁的数量小于（N/2+1），或者在锁的有效时间（lock validity time）内没有获取到足够的锁，就认为获取锁失败。这个时候需要向所有节点发送释放锁的消息。</li></ul><h4 id="实现方式一-1"><a href="#实现方式一-1" class="headerlink" title="实现方式一"></a>实现方式一</h4><p>Redisson 在基于 NIO 的 Netty 框架上，充分的利用了 Redis 键值数据库提供的一系列优势，在 Java 实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p><p>基于 Redis 的 Redisson 红锁 RedissonRedLock 对象实现了 Redlock 介绍的加锁算法。该对象也可以用来将多个 RLock 对象关联为一个红锁，每个 RLock 对象实例可以来自于不同的 Redisson 实例。</p><p>1、组件依赖：通过 Maven 引入 redisson 开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现分布式锁</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public static void main() &#123;</span><br><span class="line">    <span class="type">Config</span> config1 = <span class="function"><span class="keyword">new</span> <span class="title">Config</span>();</span></span><br><span class="line"><span class="function">    <span class="title">config1</span>.<span class="title">useSingleServer</span>().<span class="title">setAddress</span>("redis://xxxx1:xxx1")</span></span><br><span class="line"><span class="function">            .<span class="title">setPassword</span>("xxxx1")</span></span><br><span class="line"><span class="function">            .<span class="title">setDatabase</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="function">    <span class="title">RedissonClient</span> <span class="title">redissonClient1</span> = <span class="title">Redisson</span>.<span class="title">create</span>(config1);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Config</span> <span class="title">config2</span> = <span class="title">new</span> <span class="title">Config</span>();</span></span><br><span class="line"><span class="function">    <span class="title">config2</span>.<span class="title">useSingleServer</span>()</span></span><br><span class="line"><span class="function">            .<span class="title">setAddress</span>("redis://xxxx2:xxx2")</span></span><br><span class="line"><span class="function">            .<span class="title">setPassword</span>("xxxx2")</span></span><br><span class="line"><span class="function">            .<span class="title">setDatabase</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="function">    <span class="title">RedissonClient</span> <span class="title">redissonClient2</span> = <span class="title">Redisson</span>.<span class="title">create</span>(config2);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Config</span> <span class="title">config3</span> = <span class="title">new</span> <span class="title">Config</span>();</span></span><br><span class="line"><span class="function">    <span class="title">config3</span>.<span class="title">useSingleServer</span>().</span></span><br><span class="line"><span class="function">            <span class="title">setAddress</span>("redis://xxxx3:xxx3")</span></span><br><span class="line"><span class="function">            .<span class="title">setPassword</span>("xxxx3")</span></span><br><span class="line"><span class="function">            .<span class="title">setDatabase</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="function">    <span class="title">RedissonClient</span> <span class="title">redissonClient3</span> = <span class="title">Redisson</span>.<span class="title">create</span>(config3);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">String</span> <span class="title">lockName</span> = "<span class="title">redlock</span>-<span class="title">test</span>";</span></span><br><span class="line"><span class="function">    <span class="title">RLock</span> <span class="title">lock1</span> = <span class="title">redissonClient1</span>.<span class="title">getLock</span>(lockName);</span></span><br><span class="line"><span class="function">    <span class="title">RLock</span> <span class="title">lock2</span> = <span class="title">redissonClient2</span>.<span class="title">getLock</span>(lockName);</span></span><br><span class="line"><span class="function">    <span class="title">RLock</span> <span class="title">lock3</span> = <span class="title">redissonClient3</span>.<span class="title">getLock</span>(lockName);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">RedissonRedLock</span> <span class="title">redLock</span> = <span class="title">new</span> <span class="title">RedissonRedLock</span>(lock1, lock2, lock3);</span></span><br><span class="line"><span class="function">    <span class="title">boolean</span> <span class="title">isLock</span>;</span></span><br><span class="line"><span class="function">    <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="comment">// 为加锁等待 0.5 秒时间，并在加锁成功 30 秒钟后自动解开</span></span></span><br><span class="line"><span class="function">        <span class="title">isLock</span> = <span class="title">redLock</span>.<span class="title">tryLock</span>(<span class="number">500</span>, <span class="number">30000</span>, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>);</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>("isLock =" + isLock);</span></span><br><span class="line"><span class="function">        <span class="title">if</span> (isLock) &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">// lock success, do something;</span></span></span><br><span class="line"><span class="function">            <span class="title">Thread</span>.<span class="title">sleep</span>(<span class="number">30000</span>);</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125; <span class="title">catch</span> (<span class="type">Exception</span> e) &#123;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="comment">// 无论如何, 最后都要解锁</span></span></span><br><span class="line"><span class="function">        <span class="title">redLock</span>.<span class="title">unlock</span>();</span></span><br><span class="line"><span class="function">        <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span>("unlock success");</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p><strong>失败时重试</strong>：当客户端无法获取到锁时，应该随机延时后进行重试，防止多个客户端在同一时间抢夺同一资源的锁（会导致脑裂，最终都不能获取到锁）。客户端获得超过半数节点的锁花费的时间越短，那么脑裂的概率就越低。所以，理想的情况下，客户端最好能够同时（并发）向所有 redis 发出 set 命令。当客户端从多数节点获取锁失败时，应该尽快释放已经成功获取的锁，这样其他客户端不需要等待锁过期后再获取。（如果存在网络分区，客户端已经无法和 redis 进行通信，那么此时只能等待锁过期后自动释放）。</p><p><strong>PUBSUB</strong>：订阅者模式，当释放锁的时候，其他客户端能够知道锁已经被释放的消息，并让队列中的第一个消费者获取锁。使用 PUB/SUB 消息机制的优点：减少申请锁时的等待时间、安全、 锁带有超时时间、锁的标识唯一，防止死锁 锁设计为可重入，避免死锁。</p><h2 id="基于-Zookeeper-实现分布式锁"><a href="#基于-Zookeeper-实现分布式锁" class="headerlink" title="基于 Zookeeper 实现分布式锁"></a>基于 Zookeeper 实现分布式锁</h2><p><strong>Zookeeper 节点性质 </strong></p><ul><li>有序节点：假如当前有一个父节点为 / lock，我们可以在这个父节点下面创建子节点；zookeeper 提供了一个可选的有序特性，例如我们可以创建子节点 “/lock/node-” 并且指明有序，那么 zookeeper 在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为 / lock/node-0000000000，下一个节点则为 / lock/node-0000000001，依次类推。</li><li>临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper 会自动删除该节点。</li><li>事件监听：在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper 会通知客户端。当前 zookeeper 有如下四种事件：1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。</li></ul><h3 id="基于创建临时-Znode"><a href="#基于创建临时-Znode" class="headerlink" title="基于创建临时 Znode"></a>基于创建临时 Znode</h3><p>某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p><p>这种方案的正确性和可靠性是 ZooKeeper 机制保证的，实现简单。缺点是会产生 “惊群” 效应，假如许多客户端在等待一把锁，当锁释放时候所有客户端都被唤醒，仅仅有一个客户端得到锁。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ZooKeeperSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zookeeper;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperSession</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.zookeeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>, <span class="number">50000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connectedSemaphore.<span class="keyword">await</span>();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"ZooKeeper session established......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">acquireDistributedLock</span>(<span class="params">Long productId</span>)</span> &#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 相当于是给 node 注册一个监听器，去看看这个监听器是否存在</span></span><br><span class="line">                    Stat stat = zk.exists(path, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stat != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>.latch.<span class="keyword">await</span>(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">                        <span class="keyword">this</span>.latch = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    zookeeper.create(path, <span class="string">""</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放掉一个分布式锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param productId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseDistributedLock</span>(<span class="params">Long productId</span>)</span> &#123;</span><br><span class="line">        String path = <span class="string">"/product-lock-"</span> + productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zookeeper.delete(path, <span class="number">-1</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"release the lock for product[id="</span> + productId + <span class="string">"]......"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立 zk session 的 watcher</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="title">implements</span> <span class="title">Watcher</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"Receive watched event:"</span> + <span class="keyword">event</span>.getState());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (KeeperState.SyncConnected == <span class="keyword">event</span>.getState()) &#123;</span><br><span class="line">                connectedSemaphore.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装单例的静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeperSession instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ZooKeeperSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeperSession <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化单例的便捷方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于创建临时顺序节点"><a href="#基于创建临时顺序节点" class="headerlink" title="基于创建临时顺序节点"></a>基于创建临时顺序节点</h3><p>对于加锁操作，可以让所有客户端都去 / lock 目录下创建临时顺序节点，如果客户端发现自身创建节点序列号是 / lock / 目录下最小的节点，则获得锁。否则，监视比自己创建节点的序列号小的节点（比自己创建的节点小的最大节点），进入等待。对于解锁操作，只需要将自身创建的节点删除即可，然后唤醒自己的后一个节点。</p><p>特点：利用临时顺序节点来实现分布式锁机制其实就是一种按照创建顺序排队的实现。这种方案效率高，避免了 “惊群” 效应，多个客户端共同等待锁，当锁释放时只有一个客户端会被唤醒。</p><p><strong>实现步骤</strong></p><ul><li>客户端连接 zookeeper，并在 / lock 下创建临时的且有序的子节点，第一个客户端对应的子节点为 / lock/lock-0000000000，第二个为 / lock/lock-0000000001，以此类推。</li><li>客户端获取 / lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁，否则监听刚好在自己之前一位的子节点删除消息，获得子节点变更通知后重复此步骤直至获得锁；</li><li>执行业务代码；</li><li>完成业务流程后，删除对应的子节点释放锁。</li></ul><p><img src="/media/15536013319744/15542776154355.jpg" alt="15542776154355"></p><h4 id="实现方式一-2"><a href="#实现方式一-2" class="headerlink" title="实现方式一"></a>实现方式一</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ZooKeeperDistributedLock</span> <span class="title">implements</span> <span class="title">Watcher</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zk;</span><br><span class="line">    <span class="keyword">private</span> String locksRoot = <span class="string">"/locks"</span>;</span><br><span class="line">    <span class="keyword">private</span> String productId;</span><br><span class="line">    <span class="keyword">private</span> String waitNode;</span><br><span class="line">    <span class="keyword">private</span> String lockNode;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectedLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZooKeeperDistributedLock</span>(<span class="params">String productId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String address = <span class="string">"192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181"</span>;</span><br><span class="line">            zk = <span class="keyword">new</span> ZooKeeper(address, sessionTimeout, <span class="keyword">this</span>);</span><br><span class="line">            connectedLatch.<span class="keyword">await</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">WatchedEvent <span class="keyword">event</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">event</span>.getState() == KeeperState.SyncConnected) &#123;</span><br><span class="line">            connectedLatch.countDown();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.latch != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireDistributedLock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                waitForLock(waitNode, sessionTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">tryLock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 传入进去的 locksRoot + "/" + productId</span></span><br><span class="line">            <span class="comment">// 假设 productId 代表了一个商品 id, 比如说 1</span></span><br><span class="line">            <span class="comment">// locksRoot = locks</span></span><br><span class="line">            <span class="comment">// /locks/10000000000,/locks/10000000001,/locks/10000000002</span></span><br><span class="line">            lockNode = zk.create(locksRoot + <span class="string">"/"</span> + productId, <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 看看刚创建的节点是不是最小的节点</span></span><br><span class="line">            <span class="comment">// locks：10000000000,10000000001,10000000002</span></span><br><span class="line">            List&lt;String&gt; locks = zk.getChildren(locksRoot, <span class="literal">false</span>);</span><br><span class="line">            Collections.sort(locks);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lockNode.<span class="keyword">equals</span>(locksRoot + <span class="string">"/"</span> + locks.<span class="keyword">get</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">// 如果是最小的节点, 则表示取得锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不是最小的节点, 找到比自己小 1 的节点</span></span><br><span class="line">            <span class="keyword">int</span> previousLockIndex = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lockNode.<span class="keyword">equals</span>(locksRoot + <span class="string">"/"</span> + locks.<span class="keyword">get</span>(i))) &#123;</span><br><span class="line">                    previousLockIndex = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.waitNode = locks.<span class="keyword">get</span>(previousLockIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">waitForLock</span>(<span class="params">String waitNode, <span class="keyword">long</span> waitTime</span>) throws InterruptedException, KeeperException</span> &#123;</span><br><span class="line">        Stat stat = zk.exists(locksRoot + <span class="string">"/"</span> + waitNode, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.latch.<span class="keyword">await</span>(waitTime, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">this</span>.latch = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 删除 / locks/10000000001 节点</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"unlock"</span> + lockNode);</span><br><span class="line">            zk.delete(lockNode, <span class="number">-1</span>);</span><br><span class="line">            lockNode = <span class="literal">null</span>;</span><br><span class="line">            zk.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现方式二-1"><a href="#实现方式二-1" class="headerlink" title="实现方式二"></a>实现方式二</h4><p>虽然 Zookeeper 原生客户端暴露的 API 已经非常简洁了，但是实现一个分布式锁还是比较麻烦的。我们可以直接使用 curator 这个开源项目提供的 zookeeper 分布式锁实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="built_in">log</span> = LoggerFactory.getLogger(DistributedLock.class);</span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex interProcessMutex;  <span class="comment">// 可重入排它锁</span></span><br><span class="line">    <span class="keyword">private</span> String lockName;  <span class="comment">// 竞争资源标志</span></span><br><span class="line">    <span class="keyword">private</span> String root = <span class="string">"/distributed/lock/"</span>;<span class="comment">// 根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CuratorFramework curatorFramework;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ZK_URL = <span class="string">"zookeeper1.tq.master.cn:2181,zookeeper3.tq.master.cn:2181,zookeeper2.tq.master.cn:2181,zookeeper4.tq.master.cn:2181,zookeeper5.tq.master.cn:2181"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        curatorFramework = CuratorFrameworkFactory.newClient(ZK_URL, <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">        curatorFramework.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param lockName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockName = lockName;</span><br><span class="line">            interProcessMutex = <span class="keyword">new</span> InterProcessMutex(curatorFramework, root + lockName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="built_in">log</span>.error(<span class="string">"initial InterProcessMutex exception="</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 重试 2 次，每次最大等待 2s，也就是最大等待 4s</span></span><br><span class="line">            <span class="keyword">while</span> (!interProcessMutex.acquire(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;  <span class="comment">// 重试两次</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="built_in">log</span>.error(<span class="string">"distributed lock acquire exception="</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"Thread:"</span> + Thread.currentThread().getId() + <span class="string">"acquire distributed lock  busy"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"Thread:"</span> + Thread.currentThread().getId() + <span class="string">"acquire distributed lock  success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (interProcessMutex != null &amp;&amp; interProcessMutex.isAcquiredInThisProcess()) &#123;</span><br><span class="line">                interProcessMutex.release();</span><br><span class="line">                curatorFramework.<span class="keyword">delete</span>().inBackground().forPath(root + lockName);</span><br><span class="line">                <span class="built_in">log</span>.info(<span class="string">"Thread:"</span> + Thread.currentThread().getId() + <span class="string">"release distributed lock  success"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="built_in">log</span>.info(<span class="string">"Thread:"</span> + Thread.currentThread().getId() + <span class="string">"release distributed lock  exception="</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-MySQL-实现分布式锁"><a href="#基于-MySQL-实现分布式锁" class="headerlink" title="基于 MySQL 实现分布式锁"></a>基于 MySQL 实现分布式锁</h2><h3 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h3><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源的时候，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。</p><p>创建这样一张数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`method_lock`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line"><span class="string">`method_name`</span> <span class="built_in">VARCHAR</span> (<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span><span class="keyword">COMMENT</span><span class="string">'锁定的方法名'</span>,</span><br><span class="line"><span class="string">`desc`</span> <span class="built_in">VARCHAR</span> (<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'备注信息'</span>,</span><br><span class="line"><span class="string">`update_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'保存数据时间, 自动生成'</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_method_name`</span> (<span class="string">`method_name `</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8 <span class="keyword">COMMENT</span> = <span class="string">'锁定中的方法'</span>;</span><br></pre></td></tr></table></figure><p>a. 当我们要锁住某个方法时，执行以下 SQL：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> method_lock (method_name, <span class="keyword">DESC</span>) <span class="keyword">VALUES</span> (‘method_name’, ‘<span class="keyword">desc</span>’);</span><br></pre></td></tr></table></figure><p>因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们可以认为操作成功的那个线程获得了该方法的锁，可以执行具体内容。</p><p>b. 当方法执行完毕之后，想要释放锁的话，需要执行以下 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> method_lock <span class="keyword">WHERE</span> method_name = <span class="string">'method_name'</span>;</span><br></pre></td></tr></table></figure><p>上面这种简单的实现有以下几个问题：<br>1、这把锁依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解决操作失败，就会导致记录一直在数据库中，其他线程无法在获得锁。<br>3、这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁的操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据库表中数据已经存在了。</p><h3 id="基于数据库表做乐观锁"><a href="#基于数据库表做乐观锁" class="headerlink" title="基于数据库表做乐观锁"></a>基于数据库表做乐观锁</h3><p>大多数是基于数据版本（version）的记录机制实现的。何谓数据版本号？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表添加一个 “version” 字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加 1。在更新过程中，会对版本号进行比较，如果是一致的，没有发生改变，则会成功执行本次操作；如果版本号不一致，则会更新失败。</p><p>假设我们有一张资源表，状态(1：未分配；2：已分配)、资源创建时间、资源更新时间、资源数据版本号。</p><p><img src="/media/15536013319744/15536934001599.jpg" alt="15536934001599"></p><p>那么如果使用乐观锁如何解决问题呢?</p><p>a. 先执行 select 操作查询当前数据的数据版本号，比如当前数据版本号是 26：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, resource, <span class="keyword">state</span>, version FROM t_resource WHERE <span class="keyword">state</span> = <span class="number">1</span> AND id = <span class="number">5780</span>;</span><br></pre></td></tr></table></figure><p>b. 执行更新操作：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE t_resoure <span class="builtin-name">SET</span> state = 2, version = 27, update_time = now() WHERE<span class="built_in"> resource </span>= xxxxxx <span class="keyword">AND</span> state = 1 <span class="keyword">AND</span> version = 26;</span><br></pre></td></tr></table></figure><p>c. 如果上述 update 语句真正更新影响到了一行数据，那就说明占位成功。如果没有更新影响到一行数据，则说明这个资源已经被别人占位了。</p><p>基于数据库表做乐观锁的一些缺点：<br>1、这种操作方式，使原本一次的 update 操作，必须变为 2 次操作：select 版本号一次；update 一次。增加了数据库操作的次数。<br>2、如果业务场景中的一次业务流程中，多个资源都需要用保证数据一致性，那么如果全部使用基于数据库资源表的乐观锁，就要让每个资源都有一张资源表，这个在实际使用场景中肯定是无法满足的。而且这些都基于数据库操作，在高并发的要求下，对数据库连接的开销一定是无法忍受的。<br>3、乐观锁机制往往基于系统中的数据存储逻辑，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整，如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开。</p><h3 id="基于数据库表做悲观锁"><a href="#基于数据库表做悲观锁" class="headerlink" title="基于数据库表做悲观锁"></a>基于数据库表做悲观锁</h3><p>利用 for update 加显式的行锁，这样就能利用这个行级的排他锁来实现分布式锁了，同时 unlock 的时候只要释放 commit 这个事务，就能达到释放锁的目的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超时获取锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeOuts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">acquireByUpdate</span><span class="params">(String lockID, <span class="keyword">long</span> timeOuts)</span> <span class="keyword">throws</span> InterruptedException, SQLException </span>&#123;</span><br><span class="line">    String sql = <span class="string">"SELECT id from test_lock where id = ? for UPDATE"</span>;</span><br><span class="line">    <span class="keyword">long</span> futureTime = System.currentTimeMillis() + timeOuts;</span><br><span class="line">    <span class="keyword">long</span> ranmain = timeOuts;</span><br><span class="line">    <span class="keyword">long</span> timerange = <span class="number">500</span>;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement statement = connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, lockID);</span><br><span class="line">            statement.setInt(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">            statement.setLong(<span class="number">1</span>, System.currentTimeMillis());</span><br><span class="line">            <span class="keyword">boolean</span> ifsucess = statement.execute();<span class="comment">// 如果成功，那么就是获取到了锁</span></span><br><span class="line">            <span class="keyword">if</span> (ifsucess)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await(timerange, TimeUnit.MILLISECONDS);</span><br><span class="line">        ranmain = futureTime - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (ranmain &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ranmain &lt; timerange) &#123;</span><br><span class="line">            timerange = ranmain;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockID</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">unlockforUpdtate</span><span class="params">(String lockID)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：实现简单<br>缺点：连接池爆满和事务超时的问题单点的问题，单点问题，行锁升级为表锁的问题，并发量大的时候请求量太大、没有线程唤醒机制。<br>适用场景：并发量略高于上面使用乐观锁的情况下，可以采用这种方法。</p><p>总结：不论如何，使用 Mysql 来实现分布式锁都不推荐，其性能，可靠性，以及实现上跟其它两种方式对比均没啥优势，因此，学习 Mysql 实现分布式锁可以仅仅作为一种了解和思想升华。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/7e47a4503b87" target="_blank" rel="noopener">Redlock：Redis 分布式锁最牛逼的实现</a><br>[2]. <a href="https://www.jianshu.com/p/9d3b1927e627" target="_blank" rel="noopener">一般实现分布式锁都有哪些方式？使用 redis 如何设计分布式锁？使用 zk 来设计分布式锁可以吗？这两种分布式锁的实现方式哪种效率比较高？</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式系统的 CAP 理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项”。所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。&lt;/p&gt;
&lt;p&gt;针对分布式锁的实现，目前比较常用的有以下几种方案：1、基于数据库实现分布式锁；2、基于缓存 Redis 实现分布式锁；3、基于 Zookeeper 实现分布式锁。下面我将谈谈它们各种的实现方案。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://blog.maoning.pro/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="MySQL" scheme="http://blog.maoning.pro/tags/MySQL/"/>
    
      <category term="Redis" scheme="http://blog.maoning.pro/tags/Redis/"/>
    
      <category term="分布式锁" scheme="http://blog.maoning.pro/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="Zookeeper" scheme="http://blog.maoning.pro/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Git 在团队中的最佳实践（一）：Git 备忘清单</title>
    <link href="http://blog.maoning.pro/archives/1cad84b0.html"/>
    <id>http://blog.maoning.pro/archives/1cad84b0.html</id>
    <published>2019-03-22T06:36:22.000Z</published>
    <updated>2019-08-07T02:44:11.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是一个免费并且开源的分布式版本控制系统，旨在快速高效地处理从小到大所有项目的版本管理。Git 是目前最流行的版本管理工具，目前绝大部分公司都是使用 Git 作为项目的版本管理工具。目前最火的开源社区 Github，就是基于 Git 版本控制系统，所以掌握 Git 技能很重要。由于 Git 开发效率高、团队协作方便，现在很多 IDE 都集成了 Git，并且提供一些相关的图形化操作。也有很多很优秀，专门用来简化 Git 操作的 Git GUI 工具，例如 Sourcetree，Tortoise 等。我刚接触 Git 的时候，就是从 GUI 入手的，使用 Sourcetree 可视化版本控制工具进行操作。Sourcetree 底层也是对常用的 Git 命令进行封装实现的，傻瓜式操作，使用非常方便，但是我用完什么都不懂，Git 的内部原理也不易理解，决定在回头仔细学习一下 Git 命令行。学习完 Git 命令行后发现，命令行很好学，非常灵活，而且使用起来非常帅气。因此，直接 Git 命令，才是最灵活的操作。</p><p>本篇是我学习 Git 系列的开篇，主要讲述 Git 的基本概念和工作原理，然后介绍一下 Git 安装以及环境配置，最后探讨一下 Git 常用命令以及使用场景。</p><a id="more"></a><h2 id="Git-基本概念以及工作原理"><a href="#Git-基本概念以及工作原理" class="headerlink" title="Git 基本概念以及工作原理"></a>Git 基本概念以及工作原理</h2><h3 id="你所不了解的-Git-诞生史"><a href="#你所不了解的-Git-诞生史" class="headerlink" title="你所不了解的 Git 诞生史"></a>你所不了解的 Git 诞生史</h3><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。众所周知，Linux 内核开源项目有着为数众广的参与者，但是绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002 年间），即 Linus 本人通过手工方式合并世界各地志愿者通过 diff 的方式传过来的代码。</p><p>到 2002 年后，由于代码库太大，Linus 很难继续通过手工方式进行管理，于是 Linux 整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。</p><p>到了 2005 年，一位 Linux 开发成员 Andrew（Samba 协议之父）写了一个可以连接 BitKeeper 仓库的外挂，因此 BitMover 公司（BitKeeper 持有者）认为他反编译了 BitKeeper；于是 BitMover 决定中止 Linux 免费使用 BitKeeper 的授权。最终 Linux 团队与 BitMover 磋商无果，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。</p><p>于是，Linus 花了两周时间用 C 语言写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 进行管理了！</p><h3 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h3><p>Git 是一套内容寻址文件系统，Git 从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会返回一个键值，通过该键值可以在任何时候再取出该内容。可以通过底层命令 hash-object 来示范这点，传一些数据给该命令，它会将数据保存在. git 目录并返回表示这些数据的键值。    </p><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><p><img src="/media/15613612592458/590093-20170910122805351-1396180991.png" alt="590093-20170910122805351-1396180991"></p><p>Git 工作区有个隐藏目录. git，核心文件包括：config 文件、objects 文件夹、HEAD 文件、index 文件以及 refs 文件夹。下面依次对其进行说明：</p><ul><li>config 文件：该文件主要记录针对该项目的一些配置信息，例如是否以 bare 方式初始化、remote 的信息等，通过 git remote add 命令增加的远程分支的信息就保存在这里；</li><li>objects 文件夹：该文件夹主要包含 git 对象。Git 中的文件和一些操作都会以 git 对象来保存，git 对象分为 BLOB、tree 和 commit 三种类型，例如 git commit 便是 git 中的 commit 对象，而各个版本之间是通过版本树来组织的，比如当前的 HEAD 会指向某个 commit 对象，而该 commit 对象又会指向几个 BLOB 对象或者 tree 对象。objects 文件夹中会包含很多的子文件夹，其中 Git 对象保存在以其 sha-1 值的前两位为子文件夹、后 38 位位文件名的文件中；除此以外，Git 为了节省存储对象所占用的磁盘空间，会定期对 Git 对象进行压缩和打包，其中 pack 文件夹用于存储打包压缩的对象，而 info 文件夹用于从打包的文件中查找 git 对象；</li><li>HEAD 文件：该文件指明了 git branch（即当前分支）的结果，比如当前分支是 master，则该文件就会指向 master，但是并不是存储一个 master 字符串，而是分支在 refs 中的表示，例如 ref: refs/heads/master。</li><li>index 文件：该文件保存了暂存区域的信息。该文件某种程度就是缓冲区（staging area），内容包括它指向的文件的时间戳、文件名、sha1 值等；</li><li>Refs 文件夹：该文件夹存储指向数据（分支）的提交对象的指针。其中 heads 文件夹存储本地每一个分支最近一次 commit 的 sha-1 值（也就是 commit 对象的 sha-1 值），每个分支一个文件；remotes 文件夹则记录你最后一次和每一个远程仓库的通信，Git 会把你最后一次推送到这个 remote 的每个分支的值都记录在这个文件夹中；tag 文件夹则是分支的别名，这里不需要对其有过多的了解；</li></ul><h4 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h4><p>Git 本地有三个工作区域：工作目录（Workspace）、暂存区 (Stage/Index)、资源库(Repository)。如果在加上远程的 git 仓库(Remote Directory) 就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="/media/15613612592458/bg2015120901.png" alt="bg2015120901"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方。</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本。</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>Git 的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到 Git 仓库。</p><p><img src="/media/15613612592458/63651-20170905201033647-1915833066.png" alt="63651-20170905201033647-1915833066"></p><h4 id="GIT-文件-4-种状态"><a href="#GIT-文件-4-种状态" class="headerlink" title="GIT 文件 4 种状态"></a>GIT 文件 4 种状态</h4><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到 git 库, 不参与版本控制. 通过 git add 状态变为 Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为 Modified. 如果使用 git rm 移出版本库, 则成为 Untracked 文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过 git add 可进入暂存 staged 状态, 使用 git checkout 则丢弃修改过, 返回到 unmodify 状态, 这个 git checkout 即从库中取出文件, 覆盖当前修改</li><li>Staged: 暂存状态. 执行 git commit 则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为 Unmodify 状态. 执行 git reset HEAD filename 取消暂存, 文件状态为 Modified</li></ul><p><img src="/media/15613612592458/63651-20170909091456335-1787774607.jpg" alt="63651-20170909091456335-1787774607"></p><h2 id="Git-安装以及环境配置"><a href="#Git-安装以及环境配置" class="headerlink" title="Git 安装以及环境配置"></a>Git 安装以及环境配置</h2><p>本文统一使用软件包管理器的方式安装 Git，减少环境变量的配置，更加方便快捷。</p><h3 id="Linux-安装-Git"><a href="#Linux-安装-Git" class="headerlink" title="Linux 安装 Git"></a>Linux 安装 Git</h3><p>CentOS7 中使用 yum 安装 Git 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看 git 是否安装</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 显示所有已经安装和可以安装的 git 程序包</span></span><br><span class="line"><span class="variable">$ </span>sudo yum list git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用 yum 安装</span></span><br><span class="line"><span class="variable">$ </span>sudo yum install git -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看安装是否成功</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br></pre></td></tr></table></figure><h3 id="Mac-安装-Git"><a href="#Mac-安装-Git" class="headerlink" title="Mac 安装 Git"></a>Mac 安装 Git</h3><p>Mac 中使用 brew 安装 Git 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看 git 是否安装</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用 brew 安装</span></span><br><span class="line"><span class="variable">$ </span>brew install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看安装是否成功</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br></pre></td></tr></table></figure><h3 id="Windows-安装-Git"><a href="#Windows-安装-Git" class="headerlink" title="Windows 安装 Git"></a>Windows 安装 Git</h3><p>Windows 中使用 choco 安装 Git 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看 git 是否安装</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 搜索 git 安装包</span></span><br><span class="line"><span class="variable">$ </span>choco search git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用 choco 安装</span></span><br><span class="line"><span class="variable">$ </span>choco install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看安装是否成功</span></span><br><span class="line"><span class="variable">$ </span>git --version</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>Git 用户的配置文件位于 ~/.gitconfig<br>Git 单个仓库的配置文件位于 ~/$PROJECT_PATH/.git/config</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 显示当前的 Git 配置</span></span><br><span class="line">$ git<span class="built_in"> config </span>--list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 编辑 Git 配置文件 p.s.[--global: 表示全局配置, 如果不加, 则表示当前 git 仓库的配置]</span></span><br><span class="line">$ git<span class="built_in"> config </span>-e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置提交代码时的用户信息</span></span><br><span class="line">$ git<span class="built_in"> config </span>[--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git<span class="built_in"> config </span>[--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><p>如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。</p><h3 id="服务器上的-Git-生成-SSH-公钥"><a href="#服务器上的-Git-生成-SSH-公钥" class="headerlink" title="服务器上的 Git - 生成 SSH 公钥"></a>服务器上的 Git - 生成 SSH 公钥</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 进入主目录下的~/.ssh 目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/.ssh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 创建一个 SSH key p.s.[-t 指定密钥类型，默认是 rsa，可以省略；-C 设置注释文字，比如邮箱；-f 指定密钥文件存储文件名]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 添加你的 SSH key 到 github 上面去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ./id_rsa.pub</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 测试一下该 SSH key</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br></pre></td></tr></table></figure><p><a href="http://github.com/guides/providing-your-ssh-key" target="_blank" rel="noopener">关于在多个操作系统上设立相同 SSH 公钥的教程，可以查阅 GitHub 上有关 SSH 公钥的向导。</a></p><h2 id="Git-常用命令以及使用场景"><a href="#Git-常用命令以及使用场景" class="headerlink" title="Git 常用命令以及使用场景"></a>Git 常用命令以及使用场景</h2><p><img src="/media/15613612592458/2429e4d2661e60027537aea0077f6e40.png" alt="2429e4d2661e60027537aea0077f6e40"></p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 在当前目录新建一个 Git 代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 新建一个目录, 将其初始化为 Git 代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [3]. 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加 / 删除文件"></a>增加 / 删除文件</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 添加指定文件到暂存区</span></span><br><span class="line">$ git <span class="builtin-name">add</span> [file1] [file2] <span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加指定目录到暂存区, 包括子目录</span></span><br><span class="line">$ git <span class="builtin-name">add</span> [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [3]. 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git <span class="builtin-name">add</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 添加每个变化前, 都会要求确认[对于同一个文件的多处变化, 可以实现分次提交]</span></span><br><span class="line">$ git <span class="builtin-name">add</span> -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 删除工作区文件, 并且将这次删除放入暂存区 p.s.[git rm -f [file1]强制删除暂存区某个文件]</span></span><br><span class="line">$ git rm [file1] [file2] <span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># [6]. 停止追踪指定文件, 但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 改名文件, 并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 提交暂存区到仓库区</span></span><br><span class="line">$ git <span class="keyword">commit</span> -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git <span class="keyword">commit</span> [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [3]. 提交工作区自上次 commit 之后的变化, 直接到仓库区</span></span><br><span class="line">$ git <span class="keyword">commit</span> -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># [4]. 提交时显示所有 diff 信息</span></span><br><span class="line">$ git <span class="keyword">commit</span> -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># [5]. 使用一次新的 commit, 替代上一次提交[如果代码没有任何新变化, 则用来改写上一次 commit 的提交信息]</span></span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 重做上一次 commit, 并包括指定文件的新变化</span></span><br><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [3]. 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 新建一个分支, 但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [5]. 新建一个分支, 并切换到该分支 p.s.[git checkout -b [branch] [remote/branch]根据远程分支，创建本地分支]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [remote/branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 新建一个分支, 指向指定 commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 新建一个分支, 与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 切换到指定分支, 并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [9]. 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10. 建立追踪关系, 在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [11]. 合并指定分支到当前分支 p.s.[git merge --no-ff -m <span class="string">"message"</span> [branch]: 合并某分支到当前分支, 可以保存你之前的分支历史]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [12]. 选择一个 commit，合并进当前分支 p.s.[选择某一个分支中的一个或几个 commit(s)来进行操作（操作的对象是 commit）]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit1] [commit2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [13]. 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [14]. 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [1]. 列出所有 tag</span></span><br><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 新建一个 tag 在当前 commit p.s.[git tag -a [tag] -m [message]]</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 新建一个 tag 在指定 commit</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">[tag</span>] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除本地 tag</span></span><br><span class="line">$ git <span class="keyword">tag</span> <span class="title">-d</span> [<span class="keyword">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [5]. 删除远程 tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [6]. 查看 tag 信息</span></span><br><span class="line">$ git show [<span class="keyword">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [7]. 提交指定 tag</span></span><br><span class="line">$ git push [remote] [<span class="keyword">tag</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 提交所有 tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># [9]. 新建一个分支, 指向某个 tag</span></span><br><span class="line">$ git checkout -b [branch] [<span class="keyword">tag</span>]</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> [1]. 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [3]. 显示 commit 历史, 以及每次 commit 发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 搜索提交历史, 根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 显示某个 commit 之后的所有变动, 每个 commit 占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 显示某个 commit 之后的所有变动, 其 <span class="string">"提交说明"</span> 必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [7]. 显示某个文件的版本历史, 包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [8]. 显示指定文件相关的每一次 diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [9]. 显示过去 5 次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [10]. 显示所有提交过的用户, 按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [11]. 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [12]. 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [13]. 显示暂存区和上一个 commit 的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 14. 显示工作区与当前分支最新 commit 之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [15]. 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 16. 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [17]. 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 18. 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [19]. 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> [20]. 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [1]. 下载远程仓库的所有变动 p.s.[从远程 refs/heads / 命名空间复制所有分支, 并将它们存储到本地的 refs/remotes/origin / 命名空间]</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"><span class="comment"># 1.1.1 将远程仓库的 master 分支下载到本地当前 branch 中</span></span><br><span class="line">$ git fetch orgin <span class="literal">master</span></span><br><span class="line"><span class="comment"># 1.1.2 比较本地的 master 分支和 origin/master 分支的差别</span></span><br><span class="line">$ git log -p <span class="keyword">master</span> <span class="title">..origin</span>/<span class="literal">master</span></span><br><span class="line"><span class="comment"># 1.1.3 最后进行合并</span></span><br><span class="line">$ git merge origin/<span class="literal">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2.1 从远程仓库 master 分支获取最新, 在本地建立 tmp 分支</span></span><br><span class="line">$ git fetch origin <span class="literal">master</span>:tmp</span><br><span class="line"><span class="comment"># 1.2.2 将当前分支和 tmp 进行对比</span></span><br><span class="line">$ git diff tmp</span><br><span class="line"><span class="comment"># 1.2.3 合并 tmp 分支到当前分支</span></span><br><span class="line">$ git merge tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 增加一个新的远程仓库, 并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [5]. 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [6]. 上传本地指定分支到远程仓库 </span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [7]. 强行推送当前分支到远程仓库, 即使有冲突 p.s.[git push -f [remote] [branch]: 强行用本地仓库覆盖远端仓库, 强制推送是非常不好的行为, 建议禁止使用这个方式]</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 恢复暂存区的指定文件到工作区 p.s.[撤销对工作区修改: 这个命令是以最新的存储时间节点 (add 和 commit) 为参照, 覆盖工作区对应文件 file; 这个命令改变的是工作区]</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 恢复某个 commit 的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [3]. 恢复暂存区的所有文件到工作区, 即放弃工作区所有改动</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># [4]. 重置暂存区的指定文件, 与上一次 commit 保持一致, 但工作区不变 p.s.[git reset HEAD &lt;filename&gt;：取消暂存某个文件]</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 重置暂存区与工作区, 与上一次 commit 保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># [6]. 重置当前分支的指针为指定 commit, 同时重置暂存区, 但工作区不变 p.s.[git reset HEAD：重置暂存区]</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [7]. 重置当前分支的 HEAD 为指定 commit, 同时重置暂存区和工作区, 与指定 commit 一致 p.s.[git reset --hard HEAD：强制恢复 git 管理的文件夹的內容及状态]</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 重置当前 HEAD 为指定 commit, 但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [9]. 抵消式撤销, 新建一个 commit, 用来撤销指定 commit, 后者的所有变化都将被前者抵消, 并且应用到当前分支 p.s.[git revert [commit]..HEAD: 撤销指定 commit 到当前 HEAD 之间所有的变化]</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># [10]. 暂时将未提交的变化移除, 稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line"><span class="comment"># 10.1 将当前 stash 中的内容弹出, 并应用到当前分支对应的工作目录上</span></span><br><span class="line">    $ git stash pop</span><br><span class="line"><span class="comment"># 10.2 查看当前 stash 中的内容</span></span><br><span class="line">    $ git stash list</span><br><span class="line"><span class="comment"># 10.3 查看堆栈中最新保存的 stash 和当前目录的差异  </span></span><br><span class="line">    $ git stash slow</span><br><span class="line"></span><br><span class="line"><span class="comment"># [11]. 重置当前 HEAD 为指定 commit[hard: 强行合并 - 重置 stage 区和工作目录; soft: 软合并 - 保留工作目录, 并把重置 HEAD 所带来的新的差异放进暂存区; mixed: 混合合并 - 保留工作目录, 并清空暂存区]</span></span><br><span class="line">$ git reset [--hard<span class="params">|soft|</span>mixed<span class="params">|merge|</span>keep] [commit<span class="params">|HEAD]</span></span><br></pre></td></tr></table></figure><p><img src="/media/15613612592458/493ba44224a5e1b32703cf063a7f5979.png" alt="493ba44224a5e1b32703cf063a7f5979"></p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.cnblogs.com/syp172654682/p/7689328.html" target="_blank" rel="noopener">深入浅出 Git 教程</a><br>[2]. <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单</a><br>[3]. <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a></p><hr><h2 id="Git-在团队中的最佳实践系列"><a href="#Git-在团队中的最佳实践系列" class="headerlink" title="Git 在团队中的最佳实践系列"></a>Git 在团队中的最佳实践系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="c0dca125.html">Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Git 是一个免费并且开源的分布式版本控制系统，旨在快速高效地处理从小到大所有项目的版本管理。Git 是目前最流行的版本管理工具，目前绝大部分公司都是使用 Git 作为项目的版本管理工具。目前最火的开源社区 Github，就是基于 Git 版本控制系统，所以掌握 Git 技能很重要。由于 Git 开发效率高、团队协作方便，现在很多 IDE 都集成了 Git，并且提供一些相关的图形化操作。也有很多很优秀，专门用来简化 Git 操作的 Git GUI 工具，例如 Sourcetree，Tortoise 等。我刚接触 Git 的时候，就是从 GUI 入手的，使用 Sourcetree 可视化版本控制工具进行操作。Sourcetree 底层也是对常用的 Git 命令进行封装实现的，傻瓜式操作，使用非常方便，但是我用完什么都不懂，Git 的内部原理也不易理解，决定在回头仔细学习一下 Git 命令行。学习完 Git 命令行后发现，命令行很好学，非常灵活，而且使用起来非常帅气。因此，直接 Git 命令，才是最灵活的操作。&lt;/p&gt;
&lt;p&gt;本篇是我学习 Git 系列的开篇，主要讲述 Git 的基本概念和工作原理，然后介绍一下 Git 安装以及环境配置，最后探讨一下 Git 常用命令以及使用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.maoning.pro/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.maoning.pro/tags/Git/"/>
    
      <category term="安装教程" scheme="http://blog.maoning.pro/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Redis 深度探险（二）：Redis 深入之道</title>
    <link href="http://blog.maoning.pro/archives/e993c76c.html"/>
    <id>http://blog.maoning.pro/archives/e993c76c.html</id>
    <published>2019-03-01T06:39:44.000Z</published>
    <updated>2019-11-20T10:52:54.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Redis 系列的开篇文章中，我们对 Redis 概述以及 Redis 数据结构与对象进行了详细的讨论以及了解。经过上一篇文章的阅读，相信读者已经对 Redis 的内部结构有了大致了解，接下来我们继续深入了解 Redis 内部结构。</p><p>对于 Redis，相信大家对 “Redis 的持久化有哪几种方式？”、“Redis 的数据淘汰机制？” 、“Redis 的过期键淘汰策略？” 、“Redis 订阅与发布机制？” 等面试题目都不陌生，那么本文就从常见的 Redis 面试题目出发，带领大家深入了解 Redis。</p><a id="more"></a><h2 id="Redis-数据库结构？"><a href="#Redis-数据库结构？" class="headerlink" title="Redis 数据库结构？"></a>Redis 数据库结构？</h2><h3 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h3><p>Redis 服务器将所有数据库都保存在服务器状态 redis.h/redisServer 结构的 db 数组中，db 数据的每一项都是一个 redis.h/redisDb 结构，每个 redisDb 结构代表一个数据库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 服务器的数据库数量</span></span><br><span class="line"><span class="keyword">int</span> dbnum;</span><br><span class="line"><span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">redisDb *db;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的 dbnum 属性来决定应该创建多少个数据库，dbnum 属性的值由服务器配置的 database 选项决定，默认情况下，该选项的值为 16。默认情况下，Redis 客户端的目标数据库为 0 号数据库。</p><p>在服务器内部，客户端状态 redisClient 结构的 db 属性记录了客户端当前的目标数据库，这个属性是一个指向 redisDb 结构的指针：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">redisDb *db;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure><p><img src="/media/15711367156213/20191028164552.png" alt="20191028164552"></p><p>客户端通过修改目标数据库指针，让它指向 redisServer.db 数组中的不同元素来切换不同的数据库。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis 是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个 redis.h/redisDb 结构表示，数据库主要由 dict 和 expires 两个字典构成，其中，redisDb 结构的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）；而 expires 字典保存了数据库中的键的过期时间：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">reddisDb</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">dict *dict;</span><br><span class="line">    <span class="comment">// 过期时间，保存着键的过期时间</span></span><br><span class="line">dict *expires;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="/media/15711367156213/20191028170844.png" alt="20191028170844"></p><p>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过键空间字段进行操作来实现的。</p><p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li>在读取一个键之后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或者键空间不命中（miss）次数，这两个值可以在 INFO stats 命令的 keyspace_hits 属性和 keyspace_misses 属性中查看。</li><li>在读取一个键之后，服务器会更新键的 LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用 OBJECT idletime &lt; key &gt; 命令可以查看键 key 的闲置时间。</li><li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其它操作。</li><li>如果有客户端使用 WATCH 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事物程序注意到这个键已经被修改过。</li><li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增 1，这个计数器会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li></ul><h2 id="Redis-的过期键淘汰策略？"><a href="#Redis-的过期键淘汰策略？" class="headerlink" title="Redis 的过期键淘汰策略？"></a>Redis 的过期键淘汰策略？</h2><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><h4 id="设置键的生存时间或者过期时间"><a href="#设置键的生存时间或者过期时间" class="headerlink" title="设置键的生存时间或者过期时间"></a>设置键的生存时间或者过期时间</h4><p>通过 EXPIRE 命令或者 PEXPIRE 命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为 0 的键。</p><p>与 EXPIRE 命令和 PEXPIRE 命令类似，客户端可以通过 EXPIREAT 命令或者 PEXPIREAT 命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（expire time）。</p><p>虽然有多种不同单位和不同形式的设置命令，但实际上 EXPIRE、PEXPIRE、EXPIREAT 三个命令都是使用 PEXPIREAT 命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行 PEXPIREAT 命令一样。</p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb 结构的 expires 字典保存了数据中所有键的过期时间，我们称这个字典为过期字典：</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个 long 类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的 UNIX 时间戳。</li></ul><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">dict *dict;</span><br><span class="line"><span class="comment">// 过期时间，保存着键的过期时间</span></span><br><span class="line">dict *expires;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p><img src="/media/15711367156213/20191028181632.png" alt="20191028181632"></p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。（主动删除）</p><p>优点：对内存是最友好的，通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p><p>缺点：对 CPU 时间是最不友好的，在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分的 CPU 时间，在内存不紧张但是 CPU 时间非常紧张的情况下，将 CPU 时间用在删除和当前任务无关的过期键上，无疑会对服务器的相应时间和吞吐量造成影响。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。（被动删除）</p><p>优点：对 CPU  时间来说是最友好的，程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。</p><p>缺点：对内存不友好，如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期不被删除，它所占用的内存就不会释放。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。（主动删除）</p><p>优点：定期删除策略是定时删除和惰性删除两种策略的一种整合和折中，通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响；通过定期删除过期键，有效减少了因为过期键而带来的内存浪费。</p><p>缺点：定期删除策略的难点是确定删除操作执行的时长和频率，如果删除操作执行得太频繁或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面；如果删除操作执行的得太少或者执行得时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</p><h4 id="Redis-的过期键删除策略"><a href="#Redis-的过期键删除策略" class="headerlink" title="Redis 的过期键删除策略"></a>Redis 的过期键删除策略</h4><p>Redis 服务器实际使用的是惰性删除和定期删除两种策略（定期删除是集中处理，惰性删除是零散处理）：通过配合使用这两种删除策略，服务器可以很好地合理使用 CPU 时间和避免浪费内存空间之间取得平衡</p><p>惰性删除策略的实现：过期键的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有读写数据库的 Redis 命令在执行之前都会调用 expireIfNeeded 函数对输入键进行检查。expireIfNeeded 函数就像一个过滤器，它可以在命令真正执行之前，过滤掉过期的输入键，从而避免命令接触到过期键。</p><p><img src="/media/15711367156213/20191029134637.png" alt="20191029134637"></p><p>定期删除策略的实现：过期键的定期删除策略由 redis.c/activeExpireCycle 函数实现，每当 Redis 的服务器周期性操作 redis.c/serverCron 函数执行时，activeExpireCycle 函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库（默认每次检查的数据库数量为 16），从数据库的 expire 字典中随机检查一部分键（默认每个数据库检查的键数量为 20）的过期时间，并删除其中的过期键。</p><h3 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h3><ul><li>执行 SAVE 命令或者 BGSAVE 命令所产生的新 RDB 文件不会包含已经过期的键。</li><li>执行 BGREWRITEAOF 命令所产生的重写 AOF 文件不会包含已经过期的键。</li><li>当一个过期键被删除之后，服务器会追加一条 DEL 命令到现有 AOF 文件的末尾，显式地删除过期键。</li><li>当主服务器删除一个过期键之后，它会向所有从服务器发送一条 DEL 命令，显式地删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来 DEL 命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li><li>当 Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li></ul><h2 id="Redis-的数据淘汰机制？"><a href="#Redis-的数据淘汰机制？" class="headerlink" title="Redis 的数据淘汰机制？"></a>Redis 的数据淘汰机制？</h2><p>Redis 配置文件中可以使用 maxmemory&lt; bytes &gt; 将内存使用限制设置为指定的字节数。当达到内存限制时，Redis 会根据选择的淘汰策略来删除键。这样可以减少内存紧张的情况，由此获取更为稳健的服务。Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p>Redis 中当内存超过限制时，按照配置的策略，淘汰掉相应的 kv，使得内存可以继续留有足够的空间保存新的数据。Redis 确定驱逐某个键值对后，会删除这个数据，并将这个数据变更消息发布到本地（AOF 持久化）和从机（主从连接）。 </p><h3 id="缓存淘汰算法"><a href="#缓存淘汰算法" class="headerlink" title="缓存淘汰算法"></a>缓存淘汰算法</h3><p><strong>FIFO</strong>（First In First Out，先进先出算法） 一种比较容易实现的算法。它的思想是先进先出（FIFO，队列），这是最简单、最公平的一种思想，即如果一个数据是最先进入的，那么可以认为在将来它被访问的可能性很小。空间满的时候，最先进入的数据最先被置换（淘汰）。</p><p><strong>LRU</strong>（Least Recently Used， 最近最少使用算法 ）是一种常见的缓存算法，在很多分布式缓存系统（如 Redis、Memcached）中都有广泛使用。LRU 算法的思想是：如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。</p><p><strong>LFU</strong>（Least Frequently Used ， 最不经常使用算法）也是一种常见的缓存算法。LFU 算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被置换（淘汰）。</p><h3 id="Redis-提供-6-种数据淘汰策略"><a href="#Redis-提供-6-种数据淘汰策略" class="headerlink" title="Redis 提供 6 种数据淘汰策略"></a>Redis 提供 6 种数据淘汰策略</h3><p>我们在该系列的上一篇文章中了解到，redisobject 中除了 type、encoding、ptr 和 refcount 属性外，还有一个 lru 属性用来计算空转时长。OBJECT IDLETIME 命令可以打印出给定键的空转时长，是用当前时间减去键的 lru 时间计算得出的。OBJECT IDLETIME 命令是特殊的，这个命令在访问键的对象时，不会修改值对象的 lru 属性。</p><p>键的空转时长还有一个作用，如果服务器打开了 maxmemory 选项，并且服务器用于回收内存的算法是 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><ul><li>volatile-lru : 从已设置过期时间的数据集 (server.db[i].expires) 中挑选最近最少使用的数据淘汰。（推荐）</li><li>volatile-ttl : 从已设置过期时间的数据集 (server.db[i].expires) 中挑选将要过期的数据淘汰。</li><li>volatile-random : 从已设置过期时间的数据集 (server.db[i].expires) 中任意选择数据淘汰。</li><li>allkeys-lru : 从数据集 (server.db[i].dict) 中挑选最近最少使用的数据淘汰。（一般推荐）</li><li>allkeys-random : 从数据集 (server.db[i].dict) 中任意选择数据淘汰。</li><li>no-enviction：不会继续服务写请求 (DEL 请求可以继续服务)，读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。（默认）</li></ul><p>Redis 4.0 版本后增加以下两种：</p><ul><li>volatile-lfu：从已设置过期时间的数据集 (server.db[i].expires) 中挑选最不经常使用的数据淘汰。</li><li>allkeys-lfu：从数据集 (server.db[i].dict) 中挑选最不经常使用的数据淘汰。</li></ul><p>在 Redis 中 LRU 算法是一个近似算法，默认情况下，Redis 随机挑选 5 个键，并且从中选取一个最近最久未使用的 key 进行淘汰，在配置文件中可以通过 maxmemory-samples 的值来设置 redis 需要检查 key 的个数，但是检查的越多，耗费的时间也就越久，结构越精确 (也就是 Redis 从内存中淘汰的对象未使用的时间也就越久)，设置多少，综合权衡。</p><p>对于具体的数据淘汰机制以及数据淘汰策略，大家可以阅读 <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf </a> 中有相关注释。</p><h2 id="Redis-的持久化有哪几种方式？"><a href="#Redis-的持久化有哪几种方式？" class="headerlink" title="Redis 的持久化有哪几种方式？"></a>Redis 的持久化有哪几种方式？</h2><p>因为 Redis 是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存的数据库状态保存至磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。</p><p>为了解决这个问题，Redis 提供了 RDB（Redis DataBase） 持久化功能，这个功能可以将 Redis 在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>除了 RDB 持久化功能之外，Redis 还提供了 AOF（Append Only File）持久化功能。与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p><h3 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h3><p>RDB（Redis DataBase） 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个 dump.rdb 文件，Redis 重启会通过加载 dump.rdb 文件恢复数据。</p><p>RDB 文件是一个经过压缩的二进制文件，由多个部分组成，用于保存和还原 Redis 服务器所有数据库中的所有键值对数据。对于不同类型的键值对，RDB 文件会使用不同的方式来保存它们。</p><p><img src="/media/15711367156213/20191030112142.png" alt="20191030112142"></p><h4 id="RDB-文件的创建和载入"><a href="#RDB-文件的创建和载入" class="headerlink" title="RDB 文件的创建和载入"></a>RDB 文件的创建和载入</h4><p>有两个 Redis 命令可以用于生成 RDB 文件，一个是 SAVE，另一个是 BGSAVE。</p><p>SAVE 命令有服务器进程直接执行保存操作，因此 SAVE 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。</p><p>BGSAVE 命令由子进程执行保存操作，BGSAVE 命令会派生（fork）出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理命令请求，所以该命令不会阻塞服务器。</p><p>服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><p><img src="/media/15711367156213/1368782-20180827202822469-987391396.png" alt="1368782-20180827202822469-987391396"></p><h4 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h4><p>当 Redis 服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置 save 选项，如果用户没有主动设置 save 选项，那么服务器就会为 save 选项设置默认条件：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器在 900 秒（15 分钟）之内，对数据库进行了至少 1 次修改。</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 服务器在 300 秒（5 分钟）之内，对数据库进行了至少 10 次修改。</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="comment">// 服务器在 60 秒（1 分钟）之内，对数据库进行了至少 10000 次修改。</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>以上三个条件中的任意一个满足，BGSAVE 命令就会被执行。Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查 save 选项所设置的保存条件是否已经满足，如果满足的话，就执行 BGSAVE 命令。</p><h3 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h3><p>AOF（Append Only File）在 Redis 中默认不开启（appendonly no）， 默认是每秒将写操作日志追加到 AOF 文件中，它的出现是为了弥补 RDB 的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的时候会根据日志文件 appendonly.aof 的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><p>AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存，请求命令会先保存到 AOF 缓冲区里面，之后再定期写入并同步到 AOF 文件。</p><p>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</p><p><img src="/media/15711367156213/1368782-20180827205445425-1775814051.png" alt="1368782-20180827205445425-1775814051"></p><h4 id="AOF-文件的载入与数据还原"><a href="#AOF-文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h4><p>因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p><img src="/media/15711367156213/20191030112710.png" alt="20191030112710"></p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且 AOF 文件的体积越大，使用 AOF 文件来进行数据还原所需的时间就越多。</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写（rewrite）功能。AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有的 AOF 文件进行任何读取、分析或者写入操作。通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新的 AOF 文件不会包含任何浪费空间的冗余命令，所以新的 AOF 文件的体积通常会比旧的 AOF 文件体积要小得多。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新的 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的  AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><h3 id="Redis-4-0-对于持久化机制的优化"><a href="#Redis-4-0-对于持久化机制的优化" class="headerlink" title="Redis 4.0 对于持久化机制的优化"></a>Redis 4.0 对于持久化机制的优化</h3><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点，快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><img src="/media/15711367156213/1368782-20180827211636970-1023205339.png" alt="1368782-20180827211636970-1023205339"></p><h2 id="Redis-订阅（subscribe）与发布（publish）机制？"><a href="#Redis-订阅（subscribe）与发布（publish）机制？" class="headerlink" title="Redis 订阅（subscribe）与发布（publish）机制？"></a>Redis 订阅（subscribe）与发布（publish）机制？</h2><p>Redis 的发布和订阅功能由 PUBLIST、SUBSCRIBE、PSUBSCRIBE 等命令组成。通过执行 SUBSCRIBE 命令，客户端可以订阅一个或多个频道，从而你成为这些频道的订阅者（subscriber）：每当有其它客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。除了订阅频道之外，客户端还可以通过执行 PSUBSCRIBE 命令订阅一个或多个模式，从而成为这些模式的订阅者：每当有其它客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。</p><p><img src="/media/15711367156213/20191031140414.png" alt="20191031140414"></p><ul><li>服务器状态在 pubsub_channels 字典保存了所有频道的订阅关系， 字典的键为被订阅的频道，字典的值为订阅频道的所有客户端：SUBSCRIBE 命令负责将客户端和被订阅的频道关联到这个字典里面，而 UNSUBSCRIBE 命令则负责解除客户端和被退订频道之间的关联。 当有新消息发送到频道时，程序遍历频道（键）所对应的（值）所有客户端，然后将消息发送到所有订阅频道的客户端上。 </li><li>服务器状态在 pubsub_patterns 链表保存了所有模式的订阅关系，链表的每个节点都保存着一个 pubsubPattern 结构，结构中保存着被订阅的模式，以及订阅该模式的客户端：PSBUSCRIBE 命令负责将客户端和被订阅的模式记录到这个链表中，而 PUNSUBSCRIBE 命令则负责移除客户端和被退订模式在链表中的记录。 程序通过遍历链表来查找某个频道是否和某个模式匹配。 </li><li>PUBLISH 命令通过访问 pubsub_channels 字典在向频道的所有订阅者发送消息，通过访问 pubsub_patterns 链表来向所有匹配频道的模式的订阅者发送消息。</li><li>PUBSUB 命令的三个子命令都是通过读取 pubsub_channels 字典和 pubsub_patterns 链表中的信息来实现的。</li></ul><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 保存所有频道订阅关系</span></span><br><span class="line">dict *pubsub_channels;</span><br><span class="line"><span class="comment">// 保存所有模式订阅关系</span></span><br><span class="line"><span class="keyword">list</span> *pubsub_patterns;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》，第二部分 单机数据库的实现</a><br>[2]. <a href="https://www.cnblogs.com/rjzheng/p/9041659.html#!comments" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析</a><br>[3]. <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf</a></p><hr><h2 id="Redis-深度探险系列"><a href="#Redis-深度探险系列" class="headerlink" title="Redis 深度探险系列"></a>Redis 深度探险系列</h2><ul><li><a href="8fb486e9.html">Redis 深度探险（一）：那些绕不过去的 Redis 知识点</a></li><li><a href="e993c76c.html">Redis 深度探险（二）：Redis 深入之道</a></li><li><a href="14348371.html">Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</a></li><li><a href="d63e1e23.html">Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Redis 系列的开篇文章中，我们对 Redis 概述以及 Redis 数据结构与对象进行了详细的讨论以及了解。经过上一篇文章的阅读，相信读者已经对 Redis 的内部结构有了大致了解，接下来我们继续深入了解 Redis 内部结构。&lt;/p&gt;
&lt;p&gt;对于 Redis，相信大家对 “Redis 的持久化有哪几种方式？”、“Redis 的数据淘汰机制？” 、“Redis 的过期键淘汰策略？” 、“Redis 订阅与发布机制？” 等面试题目都不陌生，那么本文就从常见的 Redis 面试题目出发，带领大家深入了解 Redis。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.maoning.pro/categories/Redis/"/>
    
    
      <category term="发布与订阅" scheme="http://blog.maoning.pro/tags/%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85/"/>
    
      <category term="持久化" scheme="http://blog.maoning.pro/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="数据淘汰" scheme="http://blog.maoning.pro/tags/%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（四）：深入剖析 ThreadLocal</title>
    <link href="http://blog.maoning.pro/archives/b9c60c0e.html"/>
    <id>http://blog.maoning.pro/archives/b9c60c0e.html</id>
    <published>2019-02-19T02:12:12.000Z</published>
    <updated>2019-09-27T08:54:12.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想必很多朋友对 ThreadLocal 并不陌生，而本人也在项目中应用到了 ThreadLocal，今天我们就来一起探讨下 ThreadLocal 的使用方法和实现原理。首先，本文先谈一下对 ThreadLocal 的理解，然后根据 ThreadLocal 类的源码分析了其实现原理和使用需要注意的地方，最后给出了 ThreadLocal 应用场景。</p><a id="more"></a><h2 id="对-ThreadLocal-的理解"><a href="#对-ThreadLocal-的理解" class="headerlink" title="对 ThreadLocal 的理解"></a>对 ThreadLocal 的理解</h2><p>ThreadLocal 为解决多线程的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程中的对象使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其他线程所对应的副本。从线程的角度看，这个变量就像是线程的本地变量。</p><p>ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。</p><p><img src="/media/15470357637639/2184951-9611b7b31c9b2e20.png" alt="2184951-9611b7b31c9b2e20"></p><p>从上面的结构图，我们已经窥见 ThreadLocal 的核心机制：</p><ul><li>每个 Thread 线程内部都有一个 Map。</li><li>Map 里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread 内部的 Map 是由 ThreadLocal 维护的，由 ThreadLocal 负责向 Map 获取和设置线程的变量值。</li></ul><p>代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scratch</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 String 型的线程本地变量, 设置初始值 "Hello World!"</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final ThreadLocal&lt;String&gt; localVariable = ThreadLocal.withInitial(() -&gt; <span class="string">"Hello World!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in threadOne"</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in threadTwo"</span>);</span><br><span class="line">            System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line">        threadTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread-0:I'm variable in threadOne</span></span><br><span class="line"><span class="comment">// Thread-1:I'm variable in threadTwo</span></span><br></pre></td></tr></table></figure><p>虽然程序里面是操作的同一个变量 localVariable，但是不同线程都有自己的一份拷贝。</p><p><img src="/media/15470357637639/15500714012019.jpg" alt="15500714012019"></p><h2 id="深入解析-ThreadLocal-类"><a href="#深入解析-ThreadLocal-类" class="headerlink" title="深入解析 ThreadLocal 类"></a>深入解析 ThreadLocal 类</h2><p>先了解一下 ThreadLocal 类提供的几个方法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get() 方法用于获取当前线程的副本变量值</span></span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">get</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// set() 方法用于保存当前线程的副本变量值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">set</span>(T value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove() 方法移除当前前程的副本变量值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> remove()</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialValue() 为当前线程初始副本变量值 [一个 protected 方法，一般是用来在使用时进行重写的]</span></span><br><span class="line"><span class="keyword">protected</span> T initialValue()</span><br></pre></td></tr></table></figure><h3 id="public-T-get"><a href="#public-T-get" class="headerlink" title="public T get()"></a>public T get()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 1. 获取当前线程的 ThreadLocalMap 对象 threadLocals</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 从 map 中获取线程存储的 K-V Entry 节点</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 3. 从 Entry 节点获取存储的 Value 副本值返回.</span></span><br><span class="line">            <span class="keyword">return</span> (T) e.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.map 为空的话返回初始值 null, 即线程变量副本为 null, 在使用时需要注意判断 NullPointerException.</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    T <span class="keyword">value</span> = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-set-T-value"><a href="#public-void-set-T-value" class="headerlink" title="public void set(T value)"></a>public void set(T value)</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 1. 获取当前线程的 ThreadLocalMap 对象 threadLocals</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 2.map 非空, 则重新将 ThreadLocal 和新的 value 副本放入到 map 中.</span></span><br><span class="line">        map.<span class="keyword">set</span>(<span class="keyword">this</span>, <span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 3.map 空, 则对线程的成员变量 ThreadLocalMap 进行初始化创建, 并将 ThreadLocal 和 value 副本放入 map 中.</span></span><br><span class="line">        createMap(t, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span>(<span class="params">Thread t, T firstValue</span>)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-void-remove"><a href="#public-void-remove" class="headerlink" title="public void remove()"></a>public void remove()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取当前线程的 ThreadLocalMap 对象 threadLocals</span></span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 2. 从 map 中删除该 K-V Entry 节点</span></span><br><span class="line">        m.<span class="keyword">remove</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span>(<span class="params">Thread t</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hash-冲突怎么解决？"><a href="#Hash-冲突怎么解决？" class="headerlink" title="Hash 冲突怎么解决？"></a>Hash 冲突怎么解决？</h2><p>和 HashMap 的最大的不同在于，ThreadLocalMap 结构非常简单，没有 next 引用，也就是说 ThreadLocalMap 中解决 Hash 冲突的方式并非链表的方式，而是采用线性探测（开放寻址法）的方式，所谓线性探测，就是根据初始 Key 的 Hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经有其他 Key 值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><p>ThreadLocalMap 解决 Hash 冲突的方式就是简单的步长加 1 或减 1，寻找下一个相邻的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然 ThreadLocalMap 采用线性探测的方式解决 Hash 冲突的效率很低，如果有大量不同的 ThreadLocal 对象放入 Map 中时发生冲突，或者发生二次冲突，则效率很低。</p><p>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到 Map 中的 Key 都是相同的 ThreadLocal，如果一个线程要保存多个变量，就需要创建多个 ThreadLocal，多个 ThreadLocal 放入 Map 中时会极大的增加 Hash 冲突的可能。</p><h2 id="如何避免泄漏"><a href="#如何避免泄漏" class="headerlink" title="如何避免泄漏"></a>如何避免泄漏</h2><h3 id="ThreadLocalMap-原理"><a href="#ThreadLocalMap-原理" class="headerlink" title="ThreadLocalMap 原理"></a>ThreadLocalMap 原理</h3><p><img src="/media/15470357637639/7432604-072ea1eed5e63601.jpg" alt="7432604-072ea1eed5e63601"></p><p>ThreadLocal 的原理：每个 Thread 内部维护着一个 ThreadLocalMap（初始容量 16，负载因子 2/3，解决冲突的方法是再 hash 法），它是一个 Map。这个映射表的 Key 是一个弱引用，其实就是 ThreadLocal 本身，Value 是真正存的线程变量 Object。也就是说 ThreadLocal 本身并不真正存储线程的变量值，它只是一个工具，用来维护 Thread 内部的 Map，帮助存和取。注意上图的虚线，它代表一个弱引用类型，而弱引用的生命周期只能存活到下次 GC 前。</p><h3 id="ThreadLocal-为什么会内存泄漏？"><a href="#ThreadLocal-为什么会内存泄漏？" class="headerlink" title="ThreadLocal 为什么会内存泄漏？"></a>ThreadLocal 为什么会内存泄漏？</h3><p>ThreadLocal 在 ThreadLocalMap 中是以一个弱引用身份被 Entry 中的 Key 引用的，因此如果 ThreadLocal 没有外部强引用来引用它，那么 ThreadLocal 会在下次 JVM 垃圾收集时被回收。这个时候就会出现 Entry 中 Key 已经被回收，出现一个 null Key 的情况，外部读取 ThreadLocalMap 中的元素是无法通过 null Key 来找到 Value 的。因此如果当前线程的生命周期很长，一直存在，那么其内部的 ThreadLocalMap 对象也一直生存下来，这些 null Key 就存在一条强引用链的关系一直存在：Thread–&gt;ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致 Entry 不会回收，Value 也不会回收，但 Entry 中的 Key 却已经被回收的情况，造成内存泄漏。</p><p>但是 JVM 团队已经考虑到这样的情况，并做了一些措施来保证 ThreadLocal 尽量不会内存泄漏：在 ThreadLocal 的 get()、set()、remove() 方法调用的时候会清除掉线程 ThreadLocalMap 中所有 Entry 中 Key 为 null 的 Value，并将整个 Entry 设置为 null，利于下次内存回收。</p><p>但这样也并不能保证 ThreadLocal 不会发生内存泄漏，例如：使用 static 的 ThreadLocal，延长了 ThreadLocal 的生命周期，可能导致的内存泄漏。分配使用了 ThreadLocal 又不再调用 get()、set()、remove() 方法，那么就会导致内存泄漏。</p><h3 id="ThreadLocal-如何避免泄漏？"><a href="#ThreadLocal-如何避免泄漏？" class="headerlink" title="ThreadLocal 如何避免泄漏？"></a>ThreadLocal 如何避免泄漏？</h3><p>既然 Key 是弱引用，那么我们要做的事，就是在调用 ThreadLocal 的 get()、set() 方法时完成后再调用 remove() 方法，将 Entry 节点和 Map 的引用关系移除，这样整个 Entry 对象在 GCRoots 分析后就变成不可达了，下次 GC 的时候就可以被回收。如果使用 ThreadLocal 的 set() 方法之后，没有显示的调用 remove() 方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完 ThreadLocal 之后，记得调用 remove() 方法。</p><p>在使用线程池的情况下，没有及时清理 ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用 ThreadLocal 就跟加锁完要解锁一样，用完就清理。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>ThreadLocal 适用于如下两种场景：</p><ul><li><p>每个线程需要有自己单独的实例</p></li><li><p>实例需要在多个方法中共享，但不希望被多线程共享</p></li></ul><p>对于第一点，每个线程拥有自己实例，实现它的方式很多。例如可以在线程内部构建一个单独的实例。ThreadLocal 可以以非常方便的形式满足该需求。</p><p>对于第二点，可以在满足第一点（每个线程有自己的实例）的条件下，通过方法间引用传递的形式实现。ThreadLocal 使得代码耦合度更低，且实现更优雅。</p><p>ThreaLocal 的 JDK 文档中说明：ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread。如果我们希望通过某个类将状态（例如用户 ID、事务 ID）与线程关联起来，那么通常在这个类中定义 private static 类型的 ThreadLocal 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadContext</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long transactionId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;ThreadContext&gt; threadLocal = ThreadLocal.withInitial(ThreadContext::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadContext <span class="title">getThreadContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeThreadContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getTransactionId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionId</span><span class="params">(Long transactionId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionId = transactionId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用。作用：提供一个线程内公共变量（比如本次请求的用户信息），减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度，或者为线程提供一个私有的变量副本，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。</p><p>还记得 Hibernate 的 session 获取场景吗？</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Session</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Session session = threadLocal.<span class="keyword">get</span>();</span><br><span class="line">    <span class="comment">// 判断 Session 是否为空, 如果为空, 将创建一个 session, 并设置到本地线程变量中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="literal">null</span> &amp;&amp; !session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">                rbuildSessionFactory();<span class="comment">// 创建 Hibernate 的 SessionFactory</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                session = sessionFactory.openSession();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.<span class="keyword">set</span>(session);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么？每个线程访问数据库都应当是一个独立的 Session 会话，如果多个线程共享同一个 Session 会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢 Session，提高并发下的安全性。使用 ThreadLocal 的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ThreadLocal 并不解决线程间共享数据的问题</li><li>ThreadLocal 通过隐式的在不同线程内创建独立实例副本避免了实例线程安全的问题</li><li>每个线程持有一个 Map 并维护了 ThreadLocal 对象与具体实例的映射，该 Map 由于只被持有它的线程访问，故不存在线程安全以及锁的问题</li><li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为弱引用，避免了 ThreadLocal 对象无法被回收的问题</li><li>ThreadLocalMap 的 set 方法通过调用 replaceStaleEntry 方法回收键为 null 的 Entry 对象的值（即为具体实例）以及 Entry 对象本身从而防止内存泄漏</li><li>ThreadLocal 适用于变量在线程间隔离且在方法间共享的场景</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">ThreadLocal - 面试必问深度解析</a><br>[2]. <a href="https://www.cnblogs.com/chengxiao/p/6152824.html" target="_blank" rel="noopener">谈谈 Java 中的 ThreadLocal</a><br>[3]. <a href="http://www.jasongj.com/java/threadlocal/" target="_blank" rel="noopener">Java 进阶（七）正确理解 Thread Local 的原理与适用场景</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;想必很多朋友对 ThreadLocal 并不陌生，而本人也在项目中应用到了 ThreadLocal，今天我们就来一起探讨下 ThreadLocal 的使用方法和实现原理。首先，本文先谈一下对 ThreadLocal 的理解，然后根据 ThreadLocal 类的源码分析了其实现原理和使用需要注意的地方，最后给出了 ThreadLocal 应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://blog.maoning.pro/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="ThreadLocal" scheme="http://blog.maoning.pro/tags/ThreadLocal/"/>
    
      <category term="内存泄漏" scheme="http://blog.maoning.pro/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="哈希冲突" scheme="http://blog.maoning.pro/tags/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出集合框架（一）：HashMap 的底层实现原理</title>
    <link href="http://blog.maoning.pro/archives/b0f424b6.html"/>
    <id>http://blog.maoning.pro/archives/b0f424b6.html</id>
    <published>2019-01-21T02:56:12.000Z</published>
    <updated>2019-08-01T05:50:52.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如 memcached）的核心其实就是在内存中维护一张大的哈希表，而 HashMap 的实现原理也常常出现在各类的面试题中，重要性可见一斑。随着 JDK（Java Developmet Kit）版本的更新，JDK 1.8 对 HashMap 底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合 JDK 1.7 和 JDK 1.8 的区别，深入探讨 HashMap 的结构实现和功能原理。</p><a id="more"></a><h2 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希 (Hash）表，函数 f(key) 为哈希 (Hash) 函数。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能。</p><ul><li>数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为 O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为 O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为 O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为 O(n)。</li><li>线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为 O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为 O(n)。</li><li>二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为 O(logn)。</li><li>哈希表：哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为 O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶 O(1)的。</li></ul><h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p>我们知道，数据结构的物理存储结构只有两种：顺序存储结构（数组存储）和链式存储结构（链表存储）。</p><ul><li>数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为 O(1)；数组的特点是：寻址容易，插入和删除困难；</li><li>链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达 O(n)。链表的特点是：寻址困难，插入和删除容易。</li></ul><p>综合这两者的优点，摒弃缺点，哈希表就诞生了，既满足了数据查找方面的特点，占用的空间也不大。比如我们要新增或查找某个元素，我们通过把当前元素的关键字通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。</p><p>数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种：</p><ul><li>开放定址法（当发生地址冲突的时候，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止）</li><li>再散列函数法（同时构造多个不同的哈希函数，当发生冲突时，使用第二个、第三个…… 哈希函数计算地址，直到无冲突时）</li><li>链地址法（将所有关键字为同义词的记录存储在同一线性链表中）</li><li>建立公共溢出区（将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表）</li></ul><p>HashMap 即是采用了链地址法，也就是数组 + 链表的方式。<br><img src="/media/15518872771488/20160918154444663.png" alt="20160918154444663"></p><h2 id="HashMap-实现原理"><a href="#HashMap-实现原理" class="headerlink" title="HashMap 实现原理"></a>HashMap 实现原理</h2><p>Java 为数据结构中的映射定义了一个接口 java.util.Map，此接口主要有四个常用的实现类，分别是 HashMap、Hashtable、LinkedHashMap 和 TreeMap，类继承关系如下图所示：</p><p><img src="/media/15518872771488/06225000_aFeh.png" alt="06225000_aFeh"></p><p>下面针对各个实现类的特点做一些说明：</p><p>(1) HashMap：它根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。</p><p>(2) Hashtable：Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p><p>(3) LinkedHashMap：LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>(4) TreeMap：TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。如果使用排序的映射，建议使用 TreeMap。在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p><p>对于上述四种 Map 类型的类，要求映射中的 key 是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map 对象很可能就定位不到映射的位置了。</p><p>通过上面的比较，我们知道了 HashMap 是 Java 的 Map 家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解 HashMap 的工作原理。</p><h3 id="HashMap-存储结构"><a href="#HashMap-存储结构" class="headerlink" title="HashMap 存储结构"></a>HashMap 存储结构</h3><p>在 JDK1.6、JDK 1.7 中，HashMap 采用数组 + 链表实现，即使用链表处理冲突，同一 hash 值的元素都存储在一个链表里。但是当位于一个桶中的元素较多，即 hash 值相等的元素较多时，通过 key 值依次查找的效率较低。而 JDK 1.8 中，HashMap 采用数组 + 链表 + 红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间；当链表长度小于链表还原阈值（6）时，将红黑树转换为链表。</p><p><img src="/media/15518872771488/1401949-20180703144512965-1820976703.png" alt="1401949-20180703144512965-1820976703"></p><p><u><strong>Node</strong></u>：Node&lt;K, V&gt; 类用来实现数组及链表的数据结构。Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质是就是一个映射(键值对)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 保存节点的 hash　值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// 保存节点的　key　值</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 保存节点的　value 值</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 指向链表结构下的当前节点的　next 节点, 红黑树　TreeNode　节点中也有用到</span></span><br><span class="line">    Node&lt;K, V&gt; next;  </span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K, V&gt; next) &#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><u>TreeNode</u></strong>：TreeNode&lt;K, V&gt; 继承 LinkedHashMap.Entry&lt;K, V&gt;，用来实现红黑树相关的存储结构。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry&lt;K</span>, <span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">    <span class="type">HashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 存储当前节点的左孩子</span></span><br><span class="line">    <span class="type">HashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="comment">// 存储当前节点的右孩子</span></span><br><span class="line">    <span class="type">HashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="comment">// 存储当前节点的前一个节点</span></span><br><span class="line">    <span class="type">HashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">Node</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-各常量、成员变量作用"><a href="#HashMap-各常量、成员变量作用" class="headerlink" title="HashMap 各常量、成员变量作用　"></a>HashMap 各常量、成员变量作用　</h3><p>HashMap 各常量</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 HashMap 时未指定初始容量情况下的默认容量, 即默认的数组长度 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap 默认的装载因子, 当 HashMap 中元素数量超过 容量 * 装载因子 时, 进行　resize()　操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来确定何时将解决 hash 冲突的链表转变为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来确定何时将解决 hash 冲突的红黑树转变为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要将解决 hash 冲突的链表转变为红黑树时, 需要判断下此时数组容量, 若是由于数组容量太小（小于　MIN_TREEIFY_CAPACITY）导致的 hash 冲突太多, 则不进行链表转变为红黑树操作, 转为利用　resize() 函数对　hashMap 扩容[为了避免进行扩容、树形化选择的冲突]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><p>HashMap 各成员变量</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存 Node&lt;K,V &gt; 节点的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由 hashMap 中 Node&lt;K,V&gt;　节点构成的 set</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 hashMap 当前存储的元素的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录　hashMap 发生结构性变化的次数（注意　value 的覆盖不属于结构性变化）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// threshold 的值应等于 table.length * loadFactor, size 超过这个值时进行　resize()扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录 hashMap 装载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="HashMap-构造方法"><a href="#HashMap-构造方法" class="headerlink" title="HashMap 构造方法"></a>HashMap 构造方法</h3><p>构造方法：指定初始容量及装载因子</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法: 指定初始容量及装载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定的初始容量非负  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity:"</span> + initialCapacity);</span><br><span class="line">    <span class="comment">// 如果指定的初始容量大于最大容量, 置为最大容量  </span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">// 填充比为正  </span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor:"</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">　  <span class="comment">/* tableSizeFor(initialCapacity)　方法返回的值是最接近 initialCapacity 的 2 的幂, 若指定初始容量为９, 则实际 hashMap 容量为 16 */</span></span><br><span class="line">　  <span class="comment">// 注意此种方法创建的 hashMap 初始容量的值存在　threshold 中</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tableSizeFor(initialCapacity)　方法返回的值是最接近 initialCapacity 的 2 的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// &gt;&gt;&gt; 代表无符号右移</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h2><h3 id="根据-key-获取哈希桶数组索引位置"><a href="#根据-key-获取哈希桶数组索引位置" class="headerlink" title="根据 key 获取哈希桶数组索引位置"></a>根据 key 获取哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap 定位数组索引位置，直接决定了 hash 方法的离散性能。</p><p>Hash 算法本质上就是三步：取 key 的 hashCode 值、高位运算、取模运算。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算 hash 值[JDK 1.8 &amp; JDK 1.7]</span></span><br><span class="line"><span class="comment"> * 在 JDK 1.8 的实现中, 优化了高位运算的算法, 通过 hashCode()的高 16 位异或低 16 位实现的:(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16),</span></span><br><span class="line"><span class="comment"> * 主要是从速度、功效、质量来考虑的, 这么做可以在数组 table 的 length 比较小的时候, 也能保证考虑到高低 Bit 都参与到 Hash 的计算中, 同时不会有太大的开销。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> hash(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> h;</span><br><span class="line">    <span class="comment">// h = key.hashCode() 为第一步 取 hashCode 值</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = <span class="built_in">key</span>.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取模运算[JDK 1.7 的源码, JDK 1.8 没有这个方法, 但是实现原理一样的]</span></span><br><span class="line"><span class="comment"> * 它通过 h &amp; (table.length -1)来得到该对象的保存位,</span></span><br><span class="line"><span class="comment"> * 而 HashMap 底层数组的长度总是 2 的 n 次方, 这是 HashMap 在速度上的优化。</span></span><br><span class="line"><span class="comment"> * 当 length 总是 2 的 n 次方时, h &amp; (length - 1)运算等价于对 length 取模, 也就是 h%length, 但是 &amp; 比 % 具有更高的效率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> indexFor(<span class="built_in">int</span> h, <span class="built_in">int</span> length) &#123;</span><br><span class="line">    <span class="comment">// 第三步 取模运算</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/15518872771488/15521481837936.jpg" alt="15521481837936"></p><h3 id="HashMap-put-及其相关方法"><a href="#HashMap-put-及其相关方法" class="headerlink" title="HashMap put()及其相关方法"></a>HashMap put()及其相关方法</h3><p>HashMap 的 put 方法执行过程可以通过下图来理解。</p><p><img src="/media/15518872771488/15521465950643.jpg" alt="15521465950643"></p><p>1、判断键值对数组 table[i]是否为空或为 null，否则执行 resize()进行扩容；</p><p>2、根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向步骤六，如果 table[i]不为空，转向步骤三；</p><p>3、判断 table[i]的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向步骤四，这里的相同指的是 hashCode 以及 equals；</p><p>4、判断 table[i]是否为 treeNode，即 table[i]是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向步骤五；</p><p>5、遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p><p>6、插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过，进行扩容。</p><p>JDK 1.8HashMap 的 put 方法源码如下:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="comment">// 对 key 的 hashCode()做 hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(<span class="built_in">key</span>), <span class="built_in">key</span>, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V putVal(<span class="built_in">int</span> hash, K <span class="built_in">key</span>, V value, <span class="built_in">boolean</span> onlyIfAbsent,</span><br><span class="line">               <span class="built_in">boolean</span> evict) &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; p;</span><br><span class="line">    <span class="built_in">int</span> n, i;</span><br><span class="line">    <span class="comment">// 步骤一: tab 为空则创建[如果 table 还未被初始化, 那么初始化它]</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤二: 计算 index, 并对 null 做处理[根据键的 hash 值找到该键对应到数组中存储的索引; 如果为 null, 那么说明此索引位置并没有被占用]</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 不为 null, 说明此处已经被占用, 只需要将构建一个节点插入到这个链表的尾部即可</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line">        <span class="comment">// 步骤三: 节点 key 存在, 直接覆盖 value[当前结点和将要插入的结点的 hash 和 key 相同, 说明这是一次修改操作]</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">            <span class="comment">// 步骤四: 判断该链为红黑树[如果 p 这个头结点是红黑树结点的话, 以红黑树的插入形式进行插入]</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, <span class="built_in">key</span>, value);</span><br><span class="line">            <span class="comment">// 步骤五: 该链为链表[遍历此条链表, 将构建一个节点插入到该链表的尾部]</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, <span class="built_in">key</span>, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 链表长度大于 8 转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// key 已经存在直接覆盖 value[遍历的过程中, 如果发现与某个结点的 hash 和 key, 这依然是一次修改操作 ]</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e 不是 null, 说明当前的 put 操作是一次修改操作并且 e 指向的就是需要被修改的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤六: 超过最大容量就扩容[如果添加后, 数组容量达到阈值, 进行扩容]</span></span><br><span class="line">    <span class="keyword">if</span> (++<span class="built_in">size</span> &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-扩容方法-resize-及其相关方法"><a href="#HashMap-扩容方法-resize-及其相关方法" class="headerlink" title="HashMap 扩容方法 resize()及其相关方法"></a>HashMap 扩容方法 resize()及其相关方法</h3><p>扩容 (resize) 就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下 resize()的源码，鉴于 JDK 1.8 融入了红黑树，较复杂，为了便于理解我们仍然使用 JDK 1.7 的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入新的容量</span></span><br><span class="line">void resize(int <span class="keyword">new</span><span class="type">Capacity</span>) &#123;</span><br><span class="line">    <span class="comment">// 引用扩容前的 Entry 数组</span></span><br><span class="line">    Entry[] oldTable = table;    </span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 扩容前的数组大小如果已经达到最大 (2^30) 了</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 修改阈值为 int 的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个新的 Entry 数组</span></span><br><span class="line">    Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    <span class="comment">// 将数据转移到新的 Entry 数组里</span></span><br><span class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>);</span><br><span class="line">    <span class="comment">// HashMap 的 table 属性引用新的 Entry 数组</span></span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">    <span class="comment">// 修改阈值</span></span><br><span class="line">    threshold = (int)(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] <span class="keyword">new</span><span class="type">Table</span>) &#123;</span><br><span class="line">    <span class="comment">// src 引用了旧的 Entry 数组</span></span><br><span class="line">    Entry[] src = table;                   </span><br><span class="line">    int <span class="keyword">new</span><span class="type">Capacity</span> = <span class="keyword">new</span><span class="type">Table</span>.length;</span><br><span class="line">    <span class="comment">// 遍历旧的 Entry 数组</span></span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 取得旧 Entry 数组的每个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 释放旧 Entry 数组的对象引用（for 循环后，旧的 Entry 数组不再引用任何对象）</span></span><br><span class="line">            src[j] = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                int i = indexFor(e.hash, <span class="keyword">new</span><span class="type">Capacity</span>);</span><br><span class="line">                <span class="comment">// 标记[1]</span></span><br><span class="line">                e.next = <span class="keyword">new</span><span class="type">Table</span>[i];</span><br><span class="line">                <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                <span class="keyword">new</span><span class="type">Table</span>[i] = e;</span><br><span class="line">                <span class="comment">// 访问下一个 Entry 链上的元素</span></span><br><span class="line">                e = next;            </span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable[i]的引用赋给了 e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部(如果发生了 hash 冲突的话），这一点和 JDK 1.8 有区别，下文详解。在旧数组中同一条 Entry 链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的 hash 算法就是简单的用 key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组 table 的 size=2， 所以 key = 3、7、5，put 顺序依次为 5、7、3。在 mod 2 以后都冲突在 table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p><p><img src="/media/15518872771488/15522981009735.jpg" alt="15522981009735"></p><p>下面我们讲解下 JDK 1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展(指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="/media/15518872771488/15522982263383.jpg" alt="15522982263383"></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p><p><img src="/media/15518872771488/15522982496398.jpg" alt="15522982496398"></p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK 1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引 + oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p><p><img src="/media/15518872771488/15522982662445.jpg" alt="15522982662445"></p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK 1.8 新增的优化点。有一点注意区别，JDK 1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK 1.8 不会倒置。有兴趣的同学可以研究下 JDK 1.8 的 resize 源码，写的很赞，如下:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : <span class="type">oldTab</span>.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int <span class="keyword">new</span><span class="type">Cap</span>, <span class="keyword">new</span><span class="type">Thr</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了, 就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值, 就扩充为原来的 2 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Cap</span> = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="keyword">new</span><span class="type">Thr</span> = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">Cap</span> = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Thr</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        float ft = (float) <span class="keyword">new</span><span class="type">Cap</span> * loadFactor;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Thr</span> = (<span class="keyword">new</span><span class="type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</span><br><span class="line">                (int) ft : <span class="type">Integer</span>.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = <span class="keyword">new</span><span class="type">Thr</span>;</span><br><span class="line">    @SuppressWarnings(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K, V&gt;[] <span class="keyword">new</span><span class="type">Tab</span> = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> <span class="type">Node</span>[<span class="keyword">new</span><span class="type">Cap</span>];</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个 bucket 都移动到新的 buckets 中</span></span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">new</span><span class="type">Tab</span>[e.hash &amp; (<span class="keyword">new</span><span class="type">Cap</span> - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K, V&gt;) e).split(<span class="built_in">this</span>, <span class="keyword">new</span><span class="type">Tab</span>, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重 hash 的代码块</span></span><br><span class="line">                    Node&lt;K, V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K, V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K, V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到 bucket 里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap 放到 bucket 里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">new</span><span class="type">Tab</span>[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-线程安全性"><a href="#HashMap-线程安全性" class="headerlink" title="HashMap 线程安全性"></a>HashMap 线程安全性</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下(便于理解，仍然使用 JDK 1.7 的环境)：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class HashMapInfiniteLoop &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>, <span class="number">0.75</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">5</span>, <span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">7</span>, <span class="string">"B"</span>);</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="built_in">map</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="built_in">map</span>.<span class="built_in">put</span>(<span class="number">3</span>, <span class="string">"A"</span>);</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="built_in">map</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，map 初始化为一个长度为 2 的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当 put 第二个 key 的时候，map 就需要进行 resize。</p><p>通过设置断点让线程 1 和线程 2 同时 debug 到 transfer 方法 (3.3 小节代码块) 的首行。注意此时两个线程已经成功添加数据。放开 thread1 的断点至 transfer 方法的“Entry next = e.next;” 这一行；然后放开线程 2 的的断点，让线程 2 进行 resize。结果如下图。</p><p><img src="/media/15518872771488/15523051562584.jpg" alt="15523051562584"></p><p>注意，Thread1 的 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是 e = next，导致了 e 指向了 key(7)，而下一次循环的 next = e.next 导致了 next 指向了 key(3)。</p><p><img src="/media/15518872771488/15523052064474.jpg" alt="15523052064474"></p><p><img src="/media/15518872771488/15523051977801.jpg" alt="15523051977801"></p><p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的 key(7).next 已经指向了 key(3)， 环形链表就这样出现了。</p><p><img src="/media/15518872771488/15523053716640.jpg" alt="15523053716640"></p><p>于是，当我们用线程一调用 map.get(11)时，悲剧就出现了—— Infinite Loop。</p><h3 id="JDK-1-7-中-HashMap-和-JDK-1-8-中-HashMap-的实现区別？"><a href="#JDK-1-7-中-HashMap-和-JDK-1-8-中-HashMap-的实现区別？" class="headerlink" title="JDK 1.7 中 HashMap 和 JDK 1.8 中 HashMap 的实现区別？"></a>JDK 1.7 中 HashMap 和 JDK 1.8 中 HashMap 的实现区別？</h3><p>JDK 1.8 针对 HashMap 主要优化是减少了 Hash 冲突，提高哈希表的存、取效率。</p><ul><li><strong>底层数据结构不一样</strong>：JDK 1.7 中，HashMap 采用数组 + 链表形式实现，即使用链表处理冲突，同一 hash 值的键值对会被放在同一个链表里，当链表中元素较多时，通过 key 值查找的效率较低。而 JDK 1.8 中，HashMap 采用数组 + 链表 + 红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，来把时间复杂度从 O（n）变成 O（logN），这样大大减少了查找时间。</li><li><strong>初始化方式不一样</strong>：JDK 1.7 中 HashMap 的 resize()方法负责扩容，inflateTable()负责创建表；而 JDK 1.8 中 HashMap 的 resize()方法在表为空时，创建表；在表不为空时，则负责扩容。</li><li><strong>插入数据方式不一样</strong>：JDK 1.7 中 HashMap 新增节点采用头插法，先将原位置的数据移到后 1 位，再插入数据到该位置；而 JDK 1.8 中 HashMap 新增节点采用尾插法。因为 JDK 1.7 中 HashMap 是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在 JDK 1.8 中 HashMap 是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</li><li><strong>扩容后存储位置的计算方式不一样</strong>：在 JDK 1.7 中 HashMap 扩容时全部按照原来方式进行计算，直接用 hash 值和需要扩容的二进制数进行 &amp;（hash 值 &amp; length-1），这里就是为什么扩容的时候为啥一定必须是 2 的多少次幂的原因所在，因为如果只有 2 的 n 次幂的情况时最后一位二进制数才一定是 1，这样能最大程度减少 hash 碰撞；而在 JDK 1.8 中 HashMap 扩容时按照扩容后的规则计算，即扩容后的位置 = 扩容前的原始位置 or 扩容前的原始位置 + 旧容量的大小值。</li><li><strong>扩容时插入数据的插入时机不一样</strong>：JDK 1.7 中 HashMap 在扩容后插入数据，而 JDK 1.8 中 HashMap 在扩容前插入数据。</li><li><strong>hash 值计算方式不一样</strong>：在计算 hash 值的时候，JDK 1.7 中 HashMap 用了 9 次扰动处理 = 4 次位运算 + 5 次异或，而 JDK 1.8 中 HashMap 只用了 2 次扰动处理 = 1 次位运算 + 1 次异或。   </li></ul><p><img src="/media/15518872771488/15523088570775.jpg" alt="15523088570775"></p><p>扩容流程对比图：<br><img src="/media/15518872771488/15523088275737.jpg" alt="15523088275737"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap 的时候，估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于 1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap 是线程不安全的，不要在并发的环境中同时操作 HashMap，建议使用 ConcurrentHashMap。</p><p>(4) JDK 1.8 引入红黑树大程度优化了 HashMap 的性能。</p><p>简单来说，HashMap 由数组 + 链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前 entry 的 next 指向 null），那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为 O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过 key 对象的 equals()方法逐一比对查找。所以，性能考虑，HashMap 中的链表出现越少，性能才会越好。</p><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>特别感谢 “<a href="https://tech.meituan.com/" target="_blank" rel="noopener">美团技术团队</a>” 的知识奉献，为我解惑。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://my.oschina.net/u/2307589/blog/1800587" target="_blank" rel="noopener">深入理解 HashMap 底层原理剖析(JDK 1.8)</a><br>[2]. <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8 系列之重新认识 HashMap</a><br>[3]. <a href="http://www.importnew.com/27043.html" target="_blank" rel="noopener">HashMap 实现原理</a></p><hr><h2 id="深入浅出集合框架系列"><a href="#深入浅出集合框架系列" class="headerlink" title="深入浅出集合框架系列"></a>深入浅出集合框架系列</h2><ul><li><a href="b0f424b6.html">深入浅出集合框架（一）：HashMap 的底层实现原理</a></li><li><a href="91027543.html">深入浅出集合框架（二）：为并发而生的 ConcurrentHashMap</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如 memcached）的核心其实就是在内存中维护一张大的哈希表，而 HashMap 的实现原理也常常出现在各类的面试题中，重要性可见一斑。随着 JDK（Java Developmet Kit）版本的更新，JDK 1.8 对 HashMap 底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合 JDK 1.7 和 JDK 1.8 的区别，深入探讨 HashMap 的结构实现和功能原理。&lt;/p&gt;
    
    </summary>
    
      <category term="集合" scheme="http://blog.maoning.pro/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java8" scheme="http://blog.maoning.pro/tags/Java8/"/>
    
      <category term="HashMap" scheme="http://blog.maoning.pro/tags/HashMap/"/>
    
      <category term="集合" scheme="http://blog.maoning.pro/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="Java7" scheme="http://blog.maoning.pro/tags/Java7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 进阶讲解（一）：MySQL 索引原理</title>
    <link href="http://blog.maoning.pro/archives/c2d5e679.html"/>
    <id>http://blog.maoning.pro/archives/c2d5e679.html</id>
    <published>2018-12-21T07:56:12.000Z</published>
    <updated>2019-08-16T02:14:07.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引在 MySQL 中也叫做“键”，存储引擎用于快速查找记录的一种数据结构，通过合理的使用数据库索引可以大大提高系统的访问性能。关于 MySQL 索引的好处，如果正确合理设计并且使用索引的 MySQL 是一辆兰博基尼的话，那么没有设计和使用索引的 MySQL 就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。接下来主要介绍在 MySQL 数据库中索引类型，以及如何创建出更加合理且高效的索引技巧。</p><a id="more"></a><h2 id="MySQL-索引的概念"><a href="#MySQL-索引的概念" class="headerlink" title="MySQL 索引的概念"></a>MySQL 索引的概念</h2><p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><ul><li>优势：可以快速检索，减少 I/O 次数，加快检索速度；根据索引分组和排序，可以加快分组和排序；</li><li>劣势：索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的 1.5 倍；索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</li></ul><h2 id="MySQL-索引的类型"><a href="#MySQL-索引的类型" class="headerlink" title="MySQL 索引的类型"></a>MySQL 索引的类型</h2><p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引。</p><p>阿里巴巴的 Java 开发手册中提到：</p><blockquote><p>【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。 说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显示索引信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="PRIMARY-主键索引"><a href="#PRIMARY-主键索引" class="headerlink" title="PRIMARY - 主键索引"></a>PRIMARY - 主键索引</h3><p>即主索引，根据主键 pk_clolum（length）建立索引，不允许重复，不允许空值；</p><h3 id="UNIQUE-唯一索引"><a href="#UNIQUE-唯一索引" class="headerlink" title="UNIQUE - 唯一索引"></a>UNIQUE - 唯一索引</h3><p>与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建唯一索引[唯一索引名为 uk_字段名]</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> uk_column_name <span class="keyword">ON</span> table_name (column_name(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> uk_column_name <span class="keyword">ON</span> (column_name(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表的时候直接指定</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">CHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`time`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> uk_title (title(<span class="keyword">length</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="INDEX-普通索引"><a href="#INDEX-普通索引" class="headerlink" title="INDEX - 普通索引"></a>INDEX - 普通索引</h3><p>这是最基本的索引，它没有任何限制，MyIASM 中默认的 BTREE 类型的索引，也是我们大多数情况下用到的索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接创建索引[如果是 CHAR,VARCHAR 类型, length 可以小于字段实际长度；如果是 BLOB 和 TEXT 类型, 必须指定 length.]</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_column_name <span class="keyword">ON</span> table_name (column_name(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构的方式添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_column_name <span class="keyword">ON</span> (column_name(<span class="keyword">length</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表的时候同时创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`title`</span> <span class="built_in">CHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`content`</span> <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`time`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">INDEX</span> idx_title (title(<span class="keyword">length</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="FULLTEXT-全文索引"><a href="#FULLTEXT-全文索引" class="headerlink" title="FULLTEXT - 全文索引"></a>FULLTEXT - 全文索引</h3><p>全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接索引中的值。全文搜索和其他几类索引的匹配方式完全不一样。它有很多需要注意的，如停用词、词干、复数、布尔搜索等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> ft_column_name <span class="keyword">ON</span> table_name (<span class="keyword">content</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表结构添加全文索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> FULLTEXT ft_column_name <span class="keyword">ON</span> (column_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表的适合添加全文索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">CHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`time`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">FULLTEXT (<span class="keyword">content</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>一个表中含有多个单列索引不代表是组合索引，通俗一点讲组合索引是：包含多个字段但是只有索引名称。　在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改表结构的方式添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> idx_column_name_1_column_name_2 (column_name_1, column_name_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_column_name_1_column_name_2 <span class="keyword">ON</span> table_name (column_name_1, column_name_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表的时候同时创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`table`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`title`</span> <span class="built_in">CHAR</span> (<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`content`</span> <span class="built_in">text</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`time`</span> <span class="built_in">INT</span> (<span class="number">10</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">INDEX</span> idx_title_time (<span class="string">`title`</span>, <span class="string">`time`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="MySQL-索引的方法"><a href="#MySQL-索引的方法" class="headerlink" title="MySQL 索引的方法"></a>MySQL 索引的方法</h2><p>不同的存储引擎对于索引有不同的支持：Innodb 和 MyISAM 默认的索引是 Btree 索引；而 MEMORY 默认的索引是 Hash 索引。</p><p><img src="/media/15505006153889/15528783804958.jpg" alt></p><h3 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h3><p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像 Btree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 IO 访问，所以 Hash 索引的查询效率要远高于 Btree 索引。</p><p>可能很多人又有疑问了，既然 Hash 索引的效率要比 Btree 高很多，为什么大家不都用 Hash 索引而还要使用 Btree 索引呢？任何事物都是有两面性的，Hash 索引也一样，虽然 Hash 索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些：</p><p>（1）Hash 索引仅仅能满足 “=”,”IN” 和 “&lt;=&gt;” 查询，不能使用范围查询。</p><p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样。</p><p>（2）Hash 索引无法被用来避免数据的排序操作。</p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。</p><p>（3）Hash 索引不能利用部分索引键查询。</p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><p>（4）Hash 索引在任何时候都不能避免表扫描。</p><p>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash 运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p><p>（5）Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 Btree 索引高。</p><p>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p><h3 id="Btree-索引"><a href="#Btree-索引" class="headerlink" title="Btree 索引"></a>Btree 索引</h3><p>Btree 索引是 MySQL 数据库中使用最为频繁的索引类型，除了 ARCHIVE 存储引擎之外的其他所有的存储引擎都支持 Btree 索引。不仅仅在 MySQL 中是如此，实际上在其他的很多数据库管理系统中 Btree 索引也同样是作为最主要的索引类型，这主要是因为 Btree 索引的存储结构在数据库的数据检索中有非常优异的表现。</p><p>一般来说，MySQL 中的 Btree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，也就是所有实际需要的数据都存放于 Tree 的 Leaf Node，而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，所以我们大家都称之为 Btree 索引。当然，可能各种数据库（或 MySQL 的各种存储引擎）在存放自己的 Btree 索引的时候会对存储结构稍作改造。如 Innodb 存储引擎的 Btree 索引实际使用的存储结构实际上是 B+Tree，也就是在 Btree 数据结构的基础上做了很小的改造，在每一个 Leaf Node 上面除了存放索引键的相关信息之外，还存储了指向与该 Leaf Node 相邻的后一个 Leaf Node 的指针信息，这主要是为了加快检索多个相邻 Leaf Node 的效率考虑。</p><p>MYSQL 使用 B+Tree 做索引：<br><img src="/media/15505006153889/15528794064551.jpg" alt></p><p>（1）所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的。（只有根节点存储关键字最后树的末梢才有值)</p><p>（2）非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层。（非根节点，存储的其实是指向根节点的索引）</p><p>（3） 不可能在非叶子结点存数据。</p><p>（4）根节点横向也有链指针。(方便快速顺藤摸瓜嘛，没这个指针，就算下一个取的值是挨着的邻居，也得跑个圈才能拿到)</p><p>综合起来，B+Tree 比 B - 树优势有三个：1、IO 次数更少；2、查询性能稳定；3、范围查询简便。</p><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p>当数据库一条记录里包含多个字段时，一棵 B+Tree 就只能存储主键，如果检索的是非主键字段，则主键索引失去作用，又变成顺序查找了。这时应该在第二个要检索的列上建立第二套索引。这个索引由独立的 B+Tree 来组织。有两种常见的方法可以解决多个 B+Tree 访问同一套表数据的问题，一种叫做聚簇索引（clustered index），一种叫做非聚簇索引（secondary index）。这两个名字虽然都叫做索引，但这并不是一种单独的索引类型，而是一种数据存储方式。对于聚簇索引存储来说，行数据和主键 B+Tree 存储在一起，辅助键 B+Tree 只存储辅助键和主键，主键和非主键 B+Tree 几乎是两种类型的树。对于非聚簇索引存储来说，主键 B+Tree 在叶子节点存储指向真正数据行的指针，而非主键。</p><p><strong> 非聚簇索引 </strong></p><ul><li>非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的 key 都存储指向键值对应的数据的物理地址。</li><li>非聚簇索引的数据表和索引表是分开存储的。</li><li>非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合单个数据的查询。插入顺序不受键值影响。</li><li>只有在 MyISAM 中才能使用 FULLTEXT 索引。</li></ul><p><strong> 聚簇索引 </strong></p><ul><li>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是键值对应的数据的主键键值。因此主键的值长度越小越好，类型越简单越好。</li><li>聚簇索引的数据和主键索引存储在一起。</li><li>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘 I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂，严重影响性能。</li><li>在 InnoDB 中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</li></ul><h4 id="MyISAM-Btree-索引实现"><a href="#MyISAM-Btree-索引实现" class="headerlink" title="MyISAM Btree 索引实现"></a>MyISAM Btree 索引实现</h4><p>MyISAM 使用的是非聚簇索引，非聚簇索引的两棵 B+Tree 看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引 B+Tree 的节点存储了主键，辅助键索引 B+Tree 存储了辅助键。表数据存储在独立的地方，这两颗 B+Tree 的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p><p>MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。</p><p><img src="/media/15505006153889/15528918443746.jpg" alt></p><h4 id="InnoDB-Btree-索引实现"><a href="#InnoDB-Btree-索引实现" class="headerlink" title="InnoDB Btree 索引实现"></a>InnoDB Btree 索引实现</h4><p>InnoDB 使用的是聚簇索引，将主键组织到一棵 B+Tree 中，而行数据就储存在叶子节点上，若使用 “where id = 14” 这样的条件查找主键，则按照 B+Tree 的检索算法即可查找到对应的叶节点，之后获得行数据。若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+Tree 中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+Tree 种再执行一次 B+Tree 检索操作，最终到达叶子节点即可获取整行数据。</p><p>InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶结点 data 域保存了完整的数据记录。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。</p><p><img src="/media/15505006153889/15528918628071.jpg" alt></p><p><img src="/media/15505006153889/15528918928154.jpg" alt></p><p>为了更形象说明这两种索引的区别，我们假想一个表如下图存储了 4 行数据。其中 Id 作为主索引，Name 作为辅助索引。图示清晰的显示了聚簇索引和非聚簇索引的差异。<br>　　<br><img src="/media/15505006153889/15528800590485.jpg" alt></p><p><img src="/media/15505006153889/15528800628687.jpg" alt><br>　<br>我们重点关注聚簇索引，看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次 B+Tree 查找，这不是多此一举吗？聚簇索引的优势在哪？</p><p>（1）由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键 Id 来组织数据，获得数据更快。</p><p>（2）辅助索引使用主键作为“指针”，而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是 InnoDB 在移动行时无须更新辅助索引中的这个“指针”。也就是说行的位置会随着数据库里数据的修改而发生变化，使用聚簇索引就可以保证不管这个主键 B+Tree 的节点如何变化，辅助索引树都不受影响。</p><h2 id="建立索引的规则"><a href="#建立索引的规则" class="headerlink" title="建立索引的规则"></a>建立索引的规则</h2><p>1、选择唯一性索引：唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><p>2、为经常需要排序、分组和联合操作的字段建立索引：经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p><p>3、为常作为查询条件的字段建立索引：如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p><p>4、限制索引的数目：索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p><p>5、尽量使用数据量少的索引：如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR(100)类型的字段进行全文检索需要的时间肯定要比对 CHAR(10)类型的字段需要的时间要多。</p><p>6、尽量使用前缀来索引：如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p><p>7、删除不再使用或者很少使用的索引：表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><p>8、最左前缀匹配原则，非常重要的原则：Mysql 会一直向右查找直到遇到范围操作（&gt;，&lt;，like、between）就停止匹配。比如 a=1 and b=2 and c&gt;3 and d=6；此时如果建立了（a,b,c,d）索引，那么后面的 d 索引是完全没有用到，当换成了（a,b,d,c）就可以用到。</p><p>9、= 和 in 可以乱序：比如 a = 1 and b = 2 and c = 3 建立 (a,b,c) 索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。</p><p>10、尽量选择区分度高的列作为索引：区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就 是 0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要 join 的字段我们都要求是 0.1 以上，即平均 1 条扫描 10 条记录。</p><p>11、尽量的扩展索引，不要新建索引：比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。</p><p>注意：选择索引的最终目的是为了使查询的速度变快。上面给出的原则是最基本的准则，但不能拘泥于上面的准则。读者要在以后的学习和工作中进行不断的实践。根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://blog.csdn.net/voidccc/article/details/40077329" target="_blank" rel="noopener">剖析 Mysql 的 InnoDB 索引</a><br>[2]. <a href="https://uule.iteye.com/blog/2429508" target="_blank" rel="noopener">数据库索引 B 树、B+Tree、Hash 索引</a></p><hr><h2 id="MySQL-进阶讲解系列"><a href="#MySQL-进阶讲解系列" class="headerlink" title="MySQL 进阶讲解系列"></a>MySQL 进阶讲解系列</h2><ul><li><a href="c2d5e679.html">MySQL 进阶讲解（一）：MySQL 索引原理</a></li><li><a href="46faebc7.html">MySQL 进阶讲解（二）：快速生成测试数据以及 EXPLAIN 详解</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。索引在 MySQL 中也叫做“键”，存储引擎用于快速查找记录的一种数据结构，通过合理的使用数据库索引可以大大提高系统的访问性能。关于 MySQL 索引的好处，如果正确合理设计并且使用索引的 MySQL 是一辆兰博基尼的话，那么没有设计和使用索引的 MySQL 就是一个人力三轮车。对于没有索引的表，单表查询可能几十万数据就是瓶颈，而通常大型网站单日就可能会产生几十万甚至几百万的数据，没有索引查询会变的非常缓慢。接下来主要介绍在 MySQL 数据库中索引类型，以及如何创建出更加合理且高效的索引技巧。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.maoning.pro/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.maoning.pro/tags/MySQL/"/>
    
      <category term="索引" scheme="http://blog.maoning.pro/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Btree" scheme="http://blog.maoning.pro/tags/Btree/"/>
    
      <category term="Hash" scheme="http://blog.maoning.pro/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Java8 那些事儿（四）：增强的 Map 集合</title>
    <link href="http://blog.maoning.pro/archives/139a123e.html"/>
    <id>http://blog.maoning.pro/archives/139a123e.html</id>
    <published>2018-11-23T11:51:12.000Z</published>
    <updated>2019-10-31T07:26:03.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Jdk 8 中 Map 接口提供了一些新的便利的方法。因为在本文中我所提到的所有 Map 方法都是以默认值方法的方式实现的，所以现有的 Map 接口的实现可以直接拥有这些在默认值方法中定义的默认行为，而不需要新增一行代码。本文涵盖的 Jdk 8 中引进的 Map 方法有：getOrDefault(Object, V)，putIfAbsent(K, V)，remove(Object, Object)，replace(K, V)，andreplace(K, V, V）。</p><a id="more"></a><h2 id="Map-范例"><a href="#Map-范例" class="headerlink" title="Map 范例"></a>Map 范例</h2><h3 id="Map-getOrDefault-Object-key-V-defaultValue"><a href="#Map-getOrDefault-Object-key-V-defaultValue" class="headerlink" title="Map.getOrDefault(Object key, V defaultValue)"></a>Map.getOrDefault(Object key, V defaultValue)</h3><p>Map 的新方法 getOrDefault(Object key, V defaultValue) 允许调用者在代码语句中规定获得在 map 中符合提供的键的值，否则在没有找到提供的键的匹配项的时候返回一个 “默认值”。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V getOrDefault(<span class="keyword">Object</span> <span class="built_in">key</span>, V defaultValue) &#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (((v = <span class="built_in">get</span>(<span class="built_in">key</span>)) != <span class="keyword">null</span>) || containsKey(<span class="built_in">key</span>))</span><br><span class="line">        ? v</span><br><span class="line">        : defaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-putIfAbsent-K-key-V-value"><a href="#Map-putIfAbsent-K-key-V-value" class="headerlink" title="Map.putIfAbsent(K key, V value)"></a>Map.putIfAbsent(K key, V value)</h3><p>Map 的新方法 putIfAbsent(K key, V value) 允许调用者在代码语句中规定添加在 map 中符合提供的键的值，若 map 中有对应 K 映射的 V 且不为 null 则直接返回，否则执行 put。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">putIfAbsent</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    V v = <span class="keyword">get</span>(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">        v = put(key, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-computeIfAbsent-K-key-Function-lt-super-K-extends-V-gt-mappingFunction"><a href="#Map-computeIfAbsent-K-key-Function-lt-super-K-extends-V-gt-mappingFunction" class="headerlink" title="Map.computeIfAbsent(K key, Function&lt; ? super K, ? extends V&gt; mappingFunction)"></a>Map.computeIfAbsent(K key, Function&lt; ? super K, ? extends V&gt; mappingFunction)</h3><p>Map.computeIfAbsent 方法原型 V computeIfAbsent(K key, Function&lt; ? super K, ? extends V&gt; mappingFunction)，如果指定的 key 不存在或相关的 value 为 null 时，设置 key 与关联一个计算出的非 null 值，计算出的值为 null 的话什么也不做(不会去删除相应的 key)。如果 key 存在并且对应 value 不为 null 的话什么也不做。同样，方法的返回值也是最终的 map.get(key)。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V computeIfAbsent(K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(mappingFunction);</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">if</span> ((v = <span class="keyword">get</span>(key)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        V <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">new</span><span class="type">Value</span> = mappingFunction.apply(key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(key, <span class="keyword">new</span><span class="type">Value</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-computeIfPresent-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction"><a href="#Map-computeIfPresent-K-key-BiFunction-lt-super-K-super-V-extends-V-gt-remappingFunction" class="headerlink" title="Map.computeIfPresent(K key, BiFunction&lt; ? super K, ? super V, ? extends V&gt; remappingFunction)"></a>Map.computeIfPresent(K key, BiFunction&lt; ? super K, ? super V, ? extends V&gt; remappingFunction)</h3><p>Map.computeIfPresent 方法原型 V computeIfPresent(K key, BiFunction&lt; ? super K, ? super V, ? extends V&gt; remappingFunction)，如果指定的 key 存在并且相关联的 value 不为 null 时，根据旧的 key 和 value 计算 newValue 替换旧值，newValue 为 null 则从 map 中删除该 key；key 不存在或相应的值为 null 时则什么也不做，方法的返回值为最终的 map.get(key)。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V computeIfPresent(K key,</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">if</span> ((oldValue = <span class="keyword">get</span>(key)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        V <span class="keyword">new</span><span class="type">Value</span> = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Value</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">            put(key, <span class="keyword">new</span><span class="type">Value</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-remove-Object-key-Object-value"><a href="#Map-remove-Object-key-Object-value" class="headerlink" title="Map.remove(Object key, Object value)"></a>Map.remove(Object key, Object value)</h3><p>Map 的新方法 remove(Object key, Object value) 超越了长期有效的 Map.remove(Object key)方法，只有在提供的键和值都匹配的时候才会删除该 map 项（之前的有效版本只是查找 “键” 的匹配来删除）。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="built_in">boolean</span> remove(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">    <span class="keyword">Object</span> curValue = <span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(curValue, value) ||</span><br><span class="line">        (curValue == <span class="keyword">null</span> &amp;&amp; !containsKey(<span class="built_in">key</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-replace-K-key-V-value-Map-replace-K-key-V-oldValue-V-newValue"><a href="#Map-replace-K-key-V-value-Map-replace-K-key-V-oldValue-V-newValue" class="headerlink" title="Map.replace(K key, V value)  / Map.replace(K key, V oldValue, V newValue)"></a>Map.replace(K key, V value)  / Map.replace(K key, V oldValue, V newValue)</h3><p>Map.replace(K key, V value)  方法只有在指定的键已经存在并且有与之相关的映射值时才会将指定的键映射到指定的值（新值）。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V<span class="built_in"> replace</span>(K<span class="built_in"> key</span>, V <span class="keyword">value</span>) &#123;</span><br><span class="line">    V curValue;</span><br><span class="line">    <span class="keyword">if</span> (((curValue = get<span class="built_in">(key</span>)) != null) || containsKey<span class="built_in">(key</span>)) &#123;</span><br><span class="line">        curValue = put<span class="built_in">(key</span>, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map.replace(K key, V oldValue, V newValue) 方法接受一个额外的（第三个）参数，只有在指定的键和值都匹配的情况下才会替换。 </p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="built_in">boolean</span> replace(K <span class="built_in">key</span>, V oldValue, V newValue) &#123;</span><br><span class="line">    <span class="keyword">Object</span> curValue = <span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(curValue, oldValue) ||</span><br><span class="line">        (curValue == <span class="keyword">null</span> &amp;&amp; !containsKey(<span class="built_in">key</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    put(<span class="built_in">key</span>, newValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-merge-K-key-V-value-BiFunction-lt-super-V-super-V-extends-V-gt-remappingFunction"><a href="#Map-merge-K-key-V-value-BiFunction-lt-super-V-super-V-extends-V-gt-remappingFunction" class="headerlink" title="Map.merge(K key, V value, BiFunction&lt; ? super V, ? super V, ? extends V&gt; remappingFunction)"></a>Map.merge(K key, V value, BiFunction&lt; ? super V, ? super V, ? extends V&gt; remappingFunction)</h3><p>Map.merge(K key, V value, BiFunction&lt; ? super V, ? super V, ? extends V&gt; remappingFunction) 方法，如果指定的 key 不存在，或相应的值为 null 时，则设置 value 为相关联的值。否则根据 key 对应的旧值和 value 计算出新的值 newValue，newValue 为 null 时，删除该 key，否则设置 key 对应的值为 newValue。方法的返回值也是最终的 map.get(key) 值。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V merge(K key, V value,</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    V oldValue = <span class="keyword">get</span>(key);</span><br><span class="line">    V <span class="keyword">new</span><span class="type">Value</span> = (oldValue == <span class="literal">null</span>) ? value :<span class="type"></span></span><br><span class="line"><span class="type">               remappingFunction</span>.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, <span class="keyword">new</span><span class="type">Value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-forEach-BiConsumer-lt-super-K-super-V-gt-action"><a href="#Map-forEach-BiConsumer-lt-super-K-super-V-gt-action" class="headerlink" title="Map.forEach(BiConsumer&lt; ? super K, ? super V&gt; action)"></a>Map.forEach(BiConsumer&lt; ? super K, ? super V&gt; action)</h3><p>Map.forEach(BiConsumer&lt; ? super K, ? super V&gt; action) 方法用于遍历 map。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK8 之前的实现方式 方式一 这是最常见的并且在大多数情况下也是最可取的遍历方式</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; entry : statesAndCapitals.entrySet()) &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Key ="</span> + entry.getKey() + <span class="string">", Value ="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 之前的实现方式 方法二 在 for-each 循环中遍历 keys 或 values</span></span><br><span class="line"><span class="comment">// 遍历 map 中的键</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> : statesAndCapitals.keySet()) &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Key ="</span> + <span class="built_in">key</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 map 中的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> value : statesAndCapitals.values()) &#123;</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Value ="</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 之前的实现方式 方法三使用 Iterator 遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;&gt; entries = statesAndCapitals.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; entry = entries.next();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Key ="</span> + entry.getKey() + <span class="string">", Value ="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 之前的实现方式 通过键找值遍历（效率低）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">String</span> <span class="built_in">key</span> : statesAndCapitals.keySet()) &#123;</span><br><span class="line">    <span class="keyword">String</span> value = statesAndCapitals.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Key ="</span> + <span class="built_in">key</span> + <span class="string">", Value ="</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK8 的实现方式</span></span><br><span class="line">statesAndCapitals.forEach((s, s2) -&gt; System.out.<span class="built_in">println</span>(<span class="string">"Key ="</span> + s + <span class="string">", Value ="</span> + s2));</span><br></pre></td></tr></table></figure><h3 id="Map-sorted"><a href="#Map-sorted" class="headerlink" title="Map.sorted"></a>Map.sorted</h3><p>Map.sorted 方法用于排序 map。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)</span></span><br><span class="line"><span class="comment"> * 2. 第二层括弧实际上是一个实例初始化块 (instance initializer block), 这个块在内部匿名类构造时被执行, 这个块之所以被叫做 “实例初始化块” 是因为它们被定义在了一个类的实例范围内</span></span><br><span class="line"><span class="comment"> * 3. 如果 value 为 java 对象, 则需要实现 Comparable 接口, 重写 compareTo 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; <span class="built_in">map</span> = <span class="literal">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        put(<span class="string">"A"</span>, <span class="number">3</span>);</span><br><span class="line">        put(<span class="string">"B"</span>, <span class="number">5</span>);</span><br><span class="line">        put(<span class="string">"C"</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">"D"</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">"E"</span>, <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 根据 value 对 map 进行 ASC 排序</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; sortedMap = <span class="literal">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="built_in">map</span>.entrySet()</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted(<span class="built_in">Map</span>.Entry.comparingByValue())</span><br><span class="line">        .forEachOrdered(x -&gt; sortedMap.put(x.getKey(), x.getValue()));</span><br><span class="line">System.out.println(sortedMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据 value 对 map 进行 DESC 排序</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; sortedMap2 = <span class="literal">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="built_in">map</span>.entrySet()</span><br><span class="line">        .stream()</span><br><span class="line">        <span class="comment">// DESC .sorted(Map.Entry.&lt;String, Integer&gt;comparingByValue().reversed())</span></span><br><span class="line">        .sorted(Collections.reverseOrder(<span class="built_in">Map</span>.Entry.comparingByValue()))</span><br><span class="line">        .forEachOrdered(x -&gt; sortedMap2.put(x.getKey(), x.getValue()));</span><br><span class="line">System.out.println(sortedMap2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Collectors.toMap 直接返回排好序的 map</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt; sortedMap3;</span><br><span class="line">sortedMap3 = <span class="built_in">map</span>.entrySet()</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted(<span class="built_in">Map</span>.Entry.&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt;comparingByValue().reversed())</span><br><span class="line">        <span class="comment">// .collect(Collectors.toMap(x -&gt; x.getKey(), x -&gt; x.getValue(), (x1, x2) -&gt; x2, LinkedHashMap::new));</span></span><br><span class="line">        .collect(Collectors.toMap(<span class="built_in">Map</span>.Entry<span class="type">::getKey</span>, <span class="built_in">Map</span>.Entry<span class="type">::getValue</span>, (x1, x2) -&gt; x2, LinkedHashMap<span class="type">::new</span>));</span><br><span class="line">System.out.println(sortedMap3);</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.javacodegeeks.com/2014/04/handy-new-map-default-methods-in-jdk-8.html" target="_blank" rel="noopener">Handy New Map Default Methods in JDK 8</a><br>[2]. <a href="http://www.cnblogs.com/qdwyg2013/p/5631057.html" target="_blank" rel="noopener">Java8 之 Stream/Map</a><br>[3]. <a href="https://www.jb51.net/article/149944.htm" target="_blank" rel="noopener">Java8 Map 中新增的方法使用总结</a></p><hr><h2 id="Java8-那些事儿系列"><a href="#Java8-那些事儿系列" class="headerlink" title="Java8 那些事儿系列"></a>Java8 那些事儿系列</h2><ul><li><a href="8cef11db.html">Java8 那些事儿（一）：Stream 函数式编程</a></li><li><a href="8eb6feba.html">Java8 那些事儿（二）：Optional 类解决空指针异常</a></li><li><a href="d66032e3.html">Java8 那些事儿（三）：Date/Time API(JSR 310)</a></li><li><a href="139a123e.html">Java8 那些事儿（四）：增强的 Map 集合</a></li><li><a href="43810ae.html">Java8 那些事儿（五）：函数式接口</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Jdk 8 中 Map 接口提供了一些新的便利的方法。因为在本文中我所提到的所有 Map 方法都是以默认值方法的方式实现的，所以现有的 Map 接口的实现可以直接拥有这些在默认值方法中定义的默认行为，而不需要新增一行代码。本文涵盖的 Jdk 8 中引进的 Map 方法有：getOrDefault(Object, V)，putIfAbsent(K, V)，remove(Object, Object)，replace(K, V)，andreplace(K, V, V）。&lt;/p&gt;
    
    </summary>
    
      <category term="Java8" scheme="http://blog.maoning.pro/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://blog.maoning.pro/tags/Java8/"/>
    
      <category term="Map" scheme="http://blog.maoning.pro/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（三）：异步执行框架 Eexecutor</title>
    <link href="http://blog.maoning.pro/archives/q1e3r5t42.html"/>
    <id>http://blog.maoning.pro/archives/q1e3r5t42.html</id>
    <published>2018-10-09T07:43:12.000Z</published>
    <updated>2019-08-13T11:36:25.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Java5 之后，并发编程引入了一堆新的启动、调度和管理线程的 API。Executor 框架便是 Java5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。Eexecutor 作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者 - 消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用 Runnable 来表示任务，Executor 的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。</p><p>Executor 包括：ThreadPoolExecutor，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等。</p><a id="more"></a><h2 id="Executor-简介"><a href="#Executor-简介" class="headerlink" title="Executor 简介"></a>Executor 简介</h2><p>Executor 的 UML 图：（常用的几个接口和子类）</p><p><img src="/media/15470357563650/776259-20160426201537486-1323529733.png" alt="776259-20160426201537486-1323529733"></p><ul><li>Executor：一个接口，其定义了一个接收 Runnable 对象的方法 executor，其方法签名为 executor(Runnable command)。</li><li>ExecutorService：是一个比 Executor 使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回 Future 的方法；ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如：ExecutorService 提供了关闭自己的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。可以调用 ExecutorService 的 shutdown()方法来平滑地关闭 ExecutorService，调用该方法后，将导致 ExecutorService 停止接受任何新的任务且等待已经提交的任务执行完成(已经提交的任务会分两类：一类是已经在执行的，另一类是还没有开始执行的)，当所有已经提交的任务执行完毕后将会关闭 ExecutorService。因此我们一般用该接口来实现和管理多线程。</li><li>AbstractExecutorService：ExecutorService 执行方法的默认实现。</li><li>ScheduledExecutorService：一个可定时调度任务的接口。</li><li>ScheduledThreadPoolExecutor：ScheduledExecutorService 的实现，一个可定时调度任务的线程池。</li><li>ThreadPoolExecutor：线程池，是线程池的核心实现类，用来执行被提交的任务。可以通过调用 Executors 以下静态工厂方法来创建线程池并返回一个 ExecutorService 对象。</li><li>Executors：提供了一系列静态工厂方法用于创建各种线程池。</li></ul><h2 id="Executors-简介"><a href="#Executors-简介" class="headerlink" title="Executors 简介"></a>Executors 简介</h2><p>Executors：提供了一系列静态工厂方法用于创建各种线程池。</p><h3 id="Executors-提供的线程池配置方案"><a href="#Executors-提供的线程池配置方案" class="headerlink" title="Executors 提供的线程池配置方案"></a>Executors 提供的线程池配置方案</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>构造一个固定线程数目的线程池，配置的 corePoolSize 与 maximumPoolSize 大小相同，同时使用了一个无界 LinkedBlockingQueue 存放阻塞任务，因此多余的任务将存放在阻塞队列，不会由 RejectedExecutionHandler 处理。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p>方法签名：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">FixedThreadPool</span>(int nThreads) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">            <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>构造一个缓冲功能的线程池，配置 corePoolSize=0，maximumPoolSize=Integer.MAX_VALUE，keepAliveTime=60s，以及一个无容量的阻塞队列 SynchronousQueue，因此任务提交之后，将会创建新的线程执行；线程空闲超过 60s 将会销毁。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。</p><p>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小，极端情况下会因为创建过多线程而耗尽系统资源。这里虽然指定 maximumPool 为 Integer.MAX_VALUE，但没什么意义，如果不能满足任务执行需求，CachedThreadPool 还会继续创建新的线程。</p><p>方法签名：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">CachedThreadPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60</span>L, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="type">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>构造一个只支持一个线程的线程池，配置 corePoolSize=maximumPoolSize=1，无界阻塞队列 LinkedBlockingQueue；保证任务由一个线程串行执行；如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>方法签名：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">SingleThreadExecutor</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Executors</span>.FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">0</span>L, TimeUnit.MILLISECONDS,</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.schedule: 初始化延迟 3s 开始执行.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.schedule<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"delay 3 seconds"</span>), <span class="number">3</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        /**</span></span><br><span class="line"><span class="function">         * 2.<span class="title">scheduleAtFixedRate</span>: 按指定频率周期执行某个任务;</span></span><br><span class="line"><span class="function">         * 初始化延迟 3<span class="title">s</span> 开始执行, 每隔 3<span class="title">s</span> 重新执行一次任务[以第一个任务开始计时].</span></span><br><span class="line"><span class="function">         * 以第一个任务开始的时间计时, 3 秒过去后, 检测上一个任务是否执行完毕, 如果上一个任务执行完毕, 则当前任务立即执行, 如果上一个任务没有执行完毕, 则需要等上一个任务执行完毕后立即执行.</span></span><br><span class="line"><span class="function">         */</span></span><br><span class="line"><span class="function">        <span class="title">scheduledThreadPool</span>.<span class="title">scheduleAtFixedRate</span><span class="params">(() -&gt; System.out.println(<span class="string">"delay 3 seconds, and scheduleAtFixedRate every 3 seconds"</span>), <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        /**</span></span><br><span class="line"><span class="function">         * 3.<span class="title">scheduleAtFixedRate</span>: 按指定频率间隔执行某个任务;</span></span><br><span class="line"><span class="function">         * 初始化时延时 3<span class="title">s</span> 开始执行, 本次执行结束后延迟 3<span class="title">s</span> 开始下次执行.</span></span><br><span class="line"><span class="function">         */</span></span><br><span class="line"><span class="function">        <span class="title">scheduledThreadPool</span>.<span class="title">scheduleWithFixedDelay</span><span class="params">(() -&gt; System.out.println(<span class="string">"delay 3 seconds, and scheduleWithFixedDelay every 3 seconds"</span>), <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS)</span>;</span></span><br></pre></td></tr></table></figure><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>构造一个有定时功能的线程池，配置 corePoolSize，无界延迟阻塞队列 DelayedWorkQueue；有意思的是：maximumPoolSize=Integer.MAX_VALUE，由于 DelayedWorkQueue 是无界队列，所以这个值是没有意义的。</p><p>方法签名：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h4><p>newWorkStealingPool 是 Jdk1.8 新增一个线程池，会根据所需的并行层次来动态创建和关闭线程，通过使用多个队列减少竞争，底层用的 ForkJoinPool 来实现的。ForkJoinPool 的优势在于，可以充分利用多 CPU，多核 CPU 的优势，把一个任务拆分成多个 “小任务”，把多个“小任务” 放到多个处理器核心上并行执行；当多个 “小任务” 执行完成之后，再将这些执行结果合并起来即可。</p><p>方法签名：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="keyword">new</span><span class="type">WorkStealingPool</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ForkJoinPool</span></span><br><span class="line"><span class="type"></span>            (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">                    ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">                    <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五种线程池的使用场景"><a href="#五种线程池的使用场景" class="headerlink" title="五种线程池的使用场景"></a>五种线程池的使用场景</h3><ul><li>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li><li>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。FixedThreadPool 满足了资源管理的需求，可以限制当前线程数量。适用于负载较重的服务器环境。</li><li>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。CachedThreadPool 适用于执行很多短期异步任务的小程序，适用于负载较轻的服务器。</li><li>newScheduledThreadPool：一个有定时功能的线程池，适用于需要多个后台线程执行周期任务的场景，并且为了满足资源管理需求而限制后台线程数量的场景。</li><li>newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 CPU 数量的线程来并行执行。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://www.cnblogs.com/MOBIN/p/5436482.html" target="_blank" rel="noopener">java 并发编程 –Executor 框架</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Java5 之后，并发编程引入了一堆新的启动、调度和管理线程的 API。Executor 框架便是 Java5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。Eexecutor 作为灵活且强大的异步执行框架，其支持多种不同类型的任务执行策略，提供了一种标准的方法将任务的提交过程和执行过程解耦开发，基于生产者 - 消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者，并用 Runnable 来表示任务，Executor 的实现还提供了对生命周期的支持，以及统计信息收集，应用程序管理机制和性能监视等机制。&lt;/p&gt;
&lt;p&gt;Executor 包括：ThreadPoolExecutor，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://blog.maoning.pro/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Eexecutor" scheme="http://blog.maoning.pro/tags/Eexecutor/"/>
    
      <category term="Executors" scheme="http://blog.maoning.pro/tags/Executors/"/>
    
  </entry>
  
  <entry>
    <title>Linux 工匠精神（二）：理解 Linux 的处理器负载均值</title>
    <link href="http://blog.maoning.pro/archives/275d83e6.html"/>
    <id>http://blog.maoning.pro/archives/275d83e6.html</id>
    <published>2018-09-01T13:56:12.000Z</published>
    <updated>2019-07-26T09:19:41.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Linux 系统中，当系统响应缓慢时，一般会用 uptime 命令查看系统负载是否过高（w 命令和 top 命令也行）。而系统负载（System Load）也作为我们判断系统运行是否正常的一个非常重要的指标。</p><a id="more"></a><h2 id="什么是-Load-Average？"><a href="#什么是-Load-Average？" class="headerlink" title="什么是 Load Average？"></a>什么是 Load Average？</h2><p>系统负载（System Load）是系统 CPU 繁忙程度的度量，即有多少进程在等待被 CPU 调度（进程等待队列的长度）。系统负载表示每分钟处于可运行状态 (运行态和就绪态) 以及不可中断状态 (等待 io) 的进程数目，且没有做归一化处理。</p><p>平均负载（Load Average）是一段时间内系统的平均负载，这个一段时间一般取 1 分钟、5 分钟、15 分钟。</p><h2 id="如何查看-LoadAverage？"><a href="#如何查看-LoadAverage？" class="headerlink" title="如何查看 LoadAverage？"></a>如何查看 LoadAverage？</h2><p>top 命令，w 命令，uptime 等命令都可以查看系统负载；</p><p><img src="/media/15501365245294/15501372452501.jpg" alt="-w564"></p><p>很多人会这样理解负载均值：三个数分别代表不同时间段的系统平均负载（一分钟、五分钟、以及十五分钟），它们的数字当然是越小越好。数字越高，说明服务器的负载越大，这也可能是服务器出现某种问题的信号。</p><p>而事实不完全如此，是什么因素构成了负载均值的大小，以及如何区分它们目前的状况是「好」还是「糟糕」？什么时候应该注意哪些不正常的数值？</p><p>回答这些问题之前，首先需要了解下这些数值背后的些知识。我们先用最简单的例子说明，一台只配备一块单核处理器的服务器。</p><h2 id="行车过桥"><a href="#行车过桥" class="headerlink" title="行车过桥"></a>行车过桥</h2><p>一只单核的处理器可以形象得比喻成一条单车道。设想下，你现在需要收取这条道路的过桥费 – 忙于处理那些将要过桥的车辆。你首先当然需要了解些信息，例如车辆的载重、以及还有多少车辆正在等待过桥。如果前面没有车辆在等待，那么你可以告诉后面的司机通过。如果车辆众多，那么需要告知他们可能需要稍等一会。</p><p><img src="/media/15501365245294/890367db9819.jpg" alt="890367db9819"></p><p>因此，需要些特定的代号表示目前的车流情况，例如：</p><ul><li>0.00 表示目前桥面上没有任何的车流。实际上这种情况与 0.00 和 1.00 之间是相同的，总而言之很通畅，过往的车辆可以丝毫不用等待的通过。</li><li>1.00 表示刚好是在这座桥的承受范围内。这种情况不算糟糕，只是车流会有些堵，不过这种情况可能会造成交通越来越慢。</li><li>超过 1.00，那么说明这座桥已经超出负荷，交通严重的拥堵。那么情况有多糟糕？例如 2.00 的情况说明车流已经超出了桥所能承受的一倍，那么将有多余过桥一倍的车辆正在焦急的等待。3.00 的话情况就更不妙了，说明这座桥基本上已经快承受不了，还有超出桥负载两倍多的车辆正在等待。</li></ul><p>上面的情况和处理器的负载情况非常相似。一辆汽车的过桥时间就好比是处理器处理某线程的实际时间。Unix 系统定义的进程运行时长为所有处理器内核的处理时间加上线程在队列中等待的时间。</p><p>和收过桥费的管理员一样，你当然希望你的汽车（操作）不会被焦急的等待。所以，理想状态下，都希望负载平均值小于 1.00。当然不排除部分峰值会超过 1.00，但长此以往保持这个状态，就说明会有问题，这时候你应该会很焦急。</p><h2 id="系统负荷的经验法则"><a href="#系统负荷的经验法则" class="headerlink" title="系统负荷的经验法则"></a>系统负荷的经验法则</h2><p>所以你说的理想负荷为 1.00？</p><p>嗯，这种情况其实并不完全正确。负荷 1.00 说明系统已经没有剩余的资源了。在实际情况中，有经验的系统管理员都会将这条线划在 0.70：</p><ul><li>「需要进行调查法则」：如果长期你的系统负载在 0.70 上下，那么你需要在事情变得更糟糕之前，花些时间了解其原因。</li><li>「现在就要修复法则」：1.00。如果你的服务器系统负载长期徘徊于 1.00，那么就应该马上解决这个问题。否则，你将半夜接到你上司的电话，这可不是件令人愉快的事情。</li><li>「凌晨三点半锻炼身体法则」：5.00。如果你的服务器负载超过了 5.00 这个数字，那么你将失去你的睡眠，还得在会议中说明这情况发生的原因，总之千万不要让它发生。</li></ul><h2 id="多处理器"><a href="#多处理器" class="headerlink" title="多处理器"></a>多处理器</h2><p>那么多个处理器呢？我的均值是 3.00，但是系统运行正常！</p><p>在多处理器系统中，负载均值是基于内核的数量决定的。以 100% 负载计算，1.00 表示单个处理器，而 2.00 则说明有两个双处理器，那么 4.00 就说明主机具有四个处理器。</p><p><img src="/media/15501365245294/556217db9819.jpg" alt="556217db9819"></p><p>所以，2 个 CPU 表明系统负荷可以达到 2.0，此时每个 CPU 都达到 100% 的工作量。推广开来，n 个 CPU 的电脑，可接受的系统负荷最大为 n.0。</p><h2 id="多核与多处理器"><a href="#多核与多处理器" class="headerlink" title="多核与多处理器"></a>多核与多处理器</h2><p>先脱离下主题，我们来讨论下多核心处理器与多处理器的区别。从性能的角度上理解，一台主机拥有多核心的处理器与另台拥有同样数目的处理性能基本上可以认为是相差无几。当然实际情况会复杂得多，不同数量的缓存、处理器的频率等因素都可能造成性能的差异。</p><p>但即便这些因素造成的实际性能稍有不同，其实系统还是以处理器的核心数量计算负载均值。这使我们有了两个新的法则：<br><em>「有多少核心即为有多少负荷」法则：在多核处理中，你的系统均值不应该高于处理器核心的总数量。</em>「核心的核心」法则：核心分布在分别几个单个物理处理中并不重要，其实两颗四核的处理器等于四个双核处理器等于八个单处理器。所以，它应该有八个处理器内核。</p><p>在 Linux 下，可以使用</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cat</span>/<span class="meta">proc</span>/cpuinfo</span><br></pre></td></tr></table></figure><p>获取你系统上的每个处理器的信息。如果你只想得到数字，那么就使用下面的命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span><span class="string">'modelname'</span><span class="regexp">/proc/</span>cpuinfo|wc-l</span><br></pre></td></tr></table></figure><h2 id="最佳观察时长"><a href="#最佳观察时长" class="headerlink" title="最佳观察时长"></a>最佳观察时长</h2><p>“load average” 一共返回三个平均值 —1 分钟系统负荷、5 分钟系统负荷，15 分钟系统负荷，应该参考哪个值？</p><p>如果只有 1 分钟的系统负荷大于 1.0，其他两个时间段都小于 1.0，这表明只是暂时现象，问题不大。</p><p>如果 15 分钟内，平均系统负荷大于 1.0（调整 CPU 核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察 “15 分钟系统负荷”，将它作为电脑正常运行的指标。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">理解 Linux 系统负荷</a><br>[2]. <a href="https://scoutapp.com/blog/understanding-load-averages" target="_blank" rel="noopener">Understanding Linux CPU Load - when should you be worried?</a></p><hr><h2 id="Linux-工匠精神系列"><a href="#Linux-工匠精神系列" class="headerlink" title="Linux 工匠精神系列"></a>Linux 工匠精神系列</h2><ul><li><a href="f22a09ab.html">Linux 工匠精神（一）：Systemd 命令完全指南</a></li><li><a href="275d83e6.html">Linux 工匠精神（二）：理解 Linux 的处理器负载均值</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Linux 系统中，当系统响应缓慢时，一般会用 uptime 命令查看系统负载是否过高（w 命令和 top 命令也行）。而系统负载（System Load）也作为我们判断系统运行是否正常的一个非常重要的指标。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://blog.maoning.pro/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.maoning.pro/tags/Linux/"/>
    
      <category term="系统负载" scheme="http://blog.maoning.pro/tags/%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD/"/>
    
      <category term="uptime" scheme="http://blog.maoning.pro/tags/uptime/"/>
    
  </entry>
  
</feed>
