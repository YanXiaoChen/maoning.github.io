<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猫宁i</title>
  
  <subtitle>趁着年轻，好好生活，用心折腾。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.maoning.vip/"/>
  <updated>2020-10-12T08:08:10.660Z</updated>
  <id>https://blog.maoning.vip/</id>
  
  <author>
    <name>猫宁i</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 并发编程之美（八）：循序渐进学习 Java 锁机制</title>
    <link href="https://blog.maoning.vip/archives/c0108a7c.html"/>
    <id>https://blog.maoning.vip/archives/c0108a7c.html</id>
    <published>2020-06-12T07:24:02.000Z</published>
    <updated>2020-10-12T08:08:10.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间高效地共享数据，以及解决竞争问题，从而提交程序的执行效率。</p><p>上一篇文章中，我们针对 Java 并发编程进行了了解，如线程以及线程安全概念、Java 内存模型等基础性知识。本章，我们针对 Java 提供的种类丰富的锁，为读者介绍主流锁的知识点，以及不同的锁的适用场景。</p><a id="more"></a><h2 id="Java-主流锁"><a href="#Java-主流锁" class="headerlink" title="Java 主流锁"></a>Java 主流锁</h2><p><img src="/media/15947140029082/7f749fc8.png" alt="Java 主流锁"></p><h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3><p>悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，synchronized 关键字和 Lock 的实现类都是悲观锁。因此，悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p><p>乐观锁：对于同一个数据的并发操作，乐观锁认为在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。乐观锁在 Java 中是通过使用无锁编程来实现，最常采用的是 CAS 算法，Java 原子类中的递增操作就通过 CAS 自旋实现的。因此，乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><p><img src="/media/15947140029082/c8703cd9.png" alt="乐观锁 VS 悲观锁"></p><p>通过上图的流程图，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。</p><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p><p>在 JDK 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 conpareAndSwapInt() 和 conpareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法调用的过程，或者可以认为是无条件内联进去了。</p><p>CAS 虽然很高效，但是它也存在三大问题：</p><ul><li><p>ABA 问题。CAS 需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是 A，后来变成了 B，然后又变成了 A，那么 CAS 进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA 问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从 “A－B－A” 变成了“1A－2B－3A”。JDK 从 1.5 开始提供了 AtomicStampedReference 类来解决 ABA 问题，具体操作封装在 compareAndSet() 中。compareAndSet() 首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。不过目前来说这个类比较鸡肋，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步的可能会比原子类更高效。</p></li><li><p>循环时间长开销大。CAS 操作如果长时间不成功，会导致其一直自旋，给 CPU 带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS 能够保证原子操作，但是对多个共享变量操作时，CAS 是无法保证操作的原子性的。<br>Java 从 1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ul><h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><p>我们知道互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程 “稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋锁的实现原理同样是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="/media/15947140029082/452a3363.png" alt="自旋锁 VS 适应性自旋锁"></p><p>自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是 10 次，用户可以使用参数 -XX:PreBlockSpin 来更改。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越准确。</p><h3 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><p>无锁、偏向锁、轻量级锁、重量级锁，这四种锁是指锁的状态，专门针对 Synchronized 的。在介绍这四种锁状态之前还需要介绍一些额外的知识。首先为什么 Synchronized 能实现线程同步？在回答这个问题之前我们需要了解两个重要的概念：“Java 对象头”、“Monitor”。</p><p><strong>Java 对象头：</strong>Synchronized 是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在 Java 对象头里的，而 Java 对象头又是什么呢？我们以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p><ul><li>Mark Word（标记字段）：默认存储对象的 HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以 Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。</li></ul><p><img src="/media/15947140029082/Snipaste_2020-10-10_11-17-40.png" alt="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 存储内容对比"></p><ul><li>Klass Pointer（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ul><p><strong>Monitor：</strong>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内部锁或者 Monitor 锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p><p>现在话题回到 Synchronized，Synchronized 通过 Monitor 来实现线程同步，Monitor 是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。Synchronized 最初实现同步的方式，就是这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”，JDK 1.6 中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁” 和“轻量级锁”。所以目前锁一共有 4 种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的 CAS 原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是 JDK 1.6 中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。</p><p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为 “01”，即偏向模式。同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 之中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机 都可以不再进行任何同步操作（例如 Locking、Unlocking 以及对 Mark Word 的 Update 等）。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定（标志位为“01”）或者轻量级锁定（标志位为“00”）。</p><p>偏向锁在 JDK 1.6 及以后的 JVM 里是默认启用的。可以通过 JVM 参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是 JDK 1.6 中引入的一项锁优化，它的目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统 互斥产生的性能消耗。</p><p>轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p>轻量级锁流程：</p><ul><li>在代码进入同步块的时候，如果同步对象锁没有被锁定（锁标志位为 “01” 状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，然后拷贝对象头中的 Mark Word 复制到锁记录中。</li><li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象 Mark Word 的锁标志位设置为 “00”，表示此对象处于轻量级锁定状态。</li><li>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其它线程抢占了。</li><li>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li></ul><p>轻量级锁能提升程序同步性能的依据是 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了 CAS 操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是依赖对象内部的 Monitor 锁来实现的，而 Monitor 又依赖操作系统的 MutexLock(互斥锁) 来实现的，所以重量级锁也称为互斥锁。升级为重量级锁时，锁标志的状态值变为“10”，此时 Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><p>升级为重量级锁，就会向操作系统申请资源，线程挂起，进入到操作系统内核态的等待队列中，等待操作系统调度，然后映射回用户态。重量级锁中，由于需要做内核态到用户态的转换，而这个过程中需要消耗较多时间，也就是“重”的原因之一。</p><h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>对于 Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p><p>对于 Synchronized 而言，也是一种非公平锁。由于其并不像 ReentrantLock 是通过 AQS 的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><p>接下来我们通过 ReentrantLock 的源码来讲解公平锁和非公平锁。</p><p><img src="/media/15947140029082/6edea205.png" alt="ReentrantLock 源码"></p><p>根据代码可知，ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。它有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。ReentrantLock 默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><p><img src="/media/15947140029082/bc6fe583.png" alt="ReentrantLock 公平锁 VS 非公平锁 源码"></p><p>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的 lock() 方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。hasQueuedPredecessors() 方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回 true，否则返回 false。</p><p>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h3 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h3><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中 ReentrantLock 和 synchronized 都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><p>之前我们说过 ReentrantLock 和 synchronized 都是重入锁，那么我们通过重入锁 ReentrantLock 以及非可重入锁 NonReentrantLock 的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁：</p><ul><li><p>首先 ReentrantLock 和 NonReentrantLock 都继承父类 AQS，其父类 AQS 中维护了一个同步状态 status 来计数重入次数，status 初始值为 0。</p></li><li><p>当线程尝试获取锁时，可重入锁先尝试获取并更新 status 值，如果 status == 0 表示没有其他线程在执行同步代码，则把 status 置为 1，当前线程开始执行。如果 status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行 status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前 status 的值，如果 status != 0 的话会导致其获取锁失败，当前线程阻塞。</p></li><li><p>释放锁时，可重入锁同样先获取当前 status 的值，在当前线程是持有锁的线程的前提下。如果 status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将 status 置为 0，将锁释放。</p></li></ul><h3 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h3><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK 中的 synchronized 和 JUC 中 Lock 的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>接下来我们通过 ReentrantReadWriteLock 的源码来介绍独享锁和共享锁。</p><p>ReentrantReadWriteLock 有两把锁：ReadLock 和 WriteLock，由词知意，一个读锁一个写锁，合称 “读写锁”。再进一步观察可以发现 ReadLock 和 WriteLock 是靠内部类 Sync 实现的锁。Sync 是 AQS 的一个子类，这种结构在 CountDownLatch、ReentrantLock、Semaphore 里面也都存在。在 ReentrantReadWriteLock 里面，读锁和写锁的锁主体都是 Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以 ReentrantReadWriteLock 的并发性相比一般的互斥锁有了很大提升。</p><p>我们知道，AQS 类中 state 字段（int 类型，32 位），该字段用来描述有多少线程获持有锁。在独享锁中这个值通常是 0 或者 1（如果是重入锁的话 state 值就是重入的次数），在共享锁中 state 就是持有锁的数量。但是在 ReentrantReadWriteLock 中有读、写两把锁，所以需要在一个整型变量 state 上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将 state 变量 “按位切割” 切分成了两个部分，高 16 位表示读锁状态（读锁个数），低 16 位表示写锁状态（写锁个数）。</p><p>了解了概念之后我们再来看代码，先看写锁的加锁源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 取到当前锁的个数</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 取写锁的个数w</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// 如果已经有线程持有了锁(c!=0)</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果c=0，w=0或者c&gt;0，w&gt;0（重入），则设置当前线程为锁的拥有者</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire() 除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果存在读锁，则写锁不能被获取，原因在于：必须确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。写锁的释放与 ReentrantLock 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁已被释放，然后等待的读写线程才能够继续访问读写锁，同时前次写线程的修改对后续的读写线程可见。</p><p>接下来我们再看看读锁的加锁源码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="keyword">final</span> int tryAcquireShared(int unused) &#123;</span><br><span class="line">    <span class="type">Thread</span> current = <span class="type">Thread</span>.currentThread();</span><br><span class="line">    int <span class="built_in">c</span> = getState();</span><br><span class="line">    <span class="comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(<span class="built_in">c</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                                  </span><br><span class="line">    int r = sharedCount(<span class="built_in">c</span>);</span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; <span class="type">MAX_COUNT</span> &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="built_in">c</span>, <span class="built_in">c</span> + <span class="type">SHARED_UNIT</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">HoldCounter</span> rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.<span class="keyword">get</span>();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">                readHolds.<span class="keyword">set</span>(rh);</span><br><span class="line">            rh.<span class="built_in">count</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 tryAcquireShared(int unused) 方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠 CAS 保证）增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是 “1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p><h3 id="锁消除-VS-锁粗化"><a href="#锁消除-VS-锁粗化" class="headerlink" title="锁消除 VS 锁粗化"></a>锁消除 VS 锁粗化</h3><p>锁消除：指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其它线程访问到，就可以把它们当做栈上数据对待，认为它们是线程私有的而无须同步。</p><p>锁粗化：原则上，我们在编写代码的时候，需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，即使没有线程竞争也会导致不必要的性能消耗。因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a><br>[2]. <a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机：JVM高级特性与最佳实践》，第五部分 高效并发</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li><li><a href="bdbfedfb.html">Java 并发编程之美（七）：透彻理解 Java 并发编程</a></li><li><a href="c0108a7c.html">Java 并发编程之美（八）：循序渐进学习 Java 锁机制</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;高效并发是从 JDK 1.5 到 JDK 1.6 的一个重要改进，HotSpot 虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，这些技术都是为了在线程之间高效地共享数据，以及解决竞争问题，从而提交程序的执行效率。&lt;/p&gt;
&lt;p&gt;上一篇文章中，我们针对 Java 并发编程进行了了解，如线程以及线程安全概念、Java 内存模型等基础性知识。本章，我们针对 Java 提供的种类丰富的锁，为读者介绍主流锁的知识点，以及不同的锁的适用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.maoning.vip/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 主流锁" scheme="https://blog.maoning.vip/tags/Java-%E4%B8%BB%E6%B5%81%E9%94%81/"/>
    
      <category term="乐观锁" scheme="https://blog.maoning.vip/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
      <category term="自旋锁" scheme="https://blog.maoning.vip/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
      <category term="轻量级锁" scheme="https://blog.maoning.vip/tags/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/"/>
    
      <category term="公平锁" scheme="https://blog.maoning.vip/tags/%E5%85%AC%E5%B9%B3%E9%94%81/"/>
    
      <category term="可重入锁" scheme="https://blog.maoning.vip/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/"/>
    
      <category term="独享锁" scheme="https://blog.maoning.vip/tags/%E7%8B%AC%E4%BA%AB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>了不起的消息队列（二）：啊哈！RabbitMQ</title>
    <link href="https://blog.maoning.vip/archives/f99da47b.html"/>
    <id>https://blog.maoning.vip/archives/f99da47b.html</id>
    <published>2020-05-05T12:56:51.000Z</published>
    <updated>2020-10-12T07:26:55.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在本系列的前一篇博文中，笔者对消息队列的概述、特点等进行讲解，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。</p><p>经过上一篇博客介绍，相信大家对消息队列已经有了一个大致了解。RabbitMQ 是 MQ 产品的典型代表，是一款基于 AMQP 协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。本文意在介绍 RabbitMQ 的基本原理，包括 RabbitMQ 基本框架、概念、通信过程等，介绍一下 RabbitMQ 安装教程，最后介绍一下 RabbitMQ 在项目中实际应用场景。</p><a id="more"></a><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是采用 Erlang 语言实现的 AMQP<sup>[1]</sup> 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。RabbitMQ 实现了 AQMP 协议，AQMP 协议定义了消息路由规则和方式。生产端通过路由规则发送消息到不同 queue，消费端根据 queue 名称消费消息。此外 RabbitMQ 是向消费端推送消息，订阅关系和消费状态保存在服务端。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到消息队列时会有三个概念：生产者、队列、消费者，RabbitMQ 在这个基本概念之上，多做了一层抽象，在生产者和队列之间，加入了交换器（Exchange）。这样生产者和队列就没有直接联系，转而变成发生产者把消息给交换器，交换器根据调度策略再把消息再给队列。因此在 RabbitMQ 的消息传递模型中，他的核心思想是生产者永远不会将任何消息直接发送到队列上，甚至不知道消息是否被传递到任何队列。生产者向 Exchanges 发送消息。 Exchanges 负责生产者消息的接收，将消息推送到队列。Exchanges 通过 exchange type 指定的类型明确要如何处理消息，比如附加到特定队列或者所有队列，或者将消息丢弃。</p><p><img src="/media/15789869946673/20200114163003.png" alt="RabbitMQ 相关概念"></p><ul><li><strong>Message：</strong>消息，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、 priority（相对于其他消息的优先权）、 delivery-mode（指出该消息可能需要持久性存储）等。</li><li><strong>Publisher：</strong>消息生产者，也是一个向交换器发布消息的客户端应用程序。</li><li><strong>Exchange：</strong>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange 有 4 种类型： direct（默认）、 fanout、topic 和 headers ，不同类型的 Exchange 转发消息的策略有所区别。</li><li><strong>Queue：</strong>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li><strong>Binding：</strong>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</li><li><strong>Connection：</strong>网络连接，比如一个 TCP 连接。</li><li><strong>Channel：</strong>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内的虚拟连接， AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li><strong>Consumer：</strong>消息消费者，表示一个从消息队列中取得消息的客户端应用程序。</li><li><strong>Virtual Host：</strong>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。 vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li></ul><h4 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h4><p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。当我们发送一条消息时，首先会发给交换器（exchange），交换器根据规则（路由键：routing_key）将会确定消息投递到那个队列（queue）。交换机不存储消息，如果没有 Queue Binding 到 Exchange 的话，它会直接丢弃掉 Publisher 发送过来的消息；在启用 ack 模式后，交换机找不到队列会返回错误。Exchange 有 4 种类型： direct（默认）、fanout、topic 和 headers ，不同类型的 Exchange 转发消息的策略有所区别。</p><p><strong>1、Direct Exchange</strong></p><p>Direct Exchange：直接交换器，Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的交换机模式，根据 ROUTING_KEY 全文匹配去寻找队列。其工作方式类似于单播，Exchange 会将消息发送完全匹配 ROUTING_KEY 的 Queue。</p><p>Direct 模式，可以使用 RabbitMQ 自带的 Exchange：default Exchange 。所以不需要将 Exchange 进行任何绑定（binding）操作 。消息传递时，ROUTING_KEY 必须完全匹配，才会被队列接收，否则该消息会被抛弃。</p><p><img src="/media/15789869946673/306976-20160728104255372-2049742072.png" alt="Direct Exchange"></p><p><strong>2、Fanout Exchange</strong></p><p>Fanout Exchange：扇形交换器，所有发送到 Fanout Exchange 的消息都会被转发到与该 Exchange 绑定 （Binding） 的所有 Queue 上。</p><p>Fanout 模式，Fanout Exchange 不需要处理 ROUTING_KEY。只需要简单的将队列绑定到 Exchange 上，这样发送到 Exchange 的消息都会被转发到与该交换机绑定的所有队列上。类似子网广播，每台子网内的主机都获得了一份复制的消息。所以，Fanout Exchange 转发消息是最快的。</p><p><img src="/media/15789869946673/306976-20160728104237622-1486261669.png" alt="Fanout Exchange"></p><p><strong>3、Topic Exchange</strong></p><p>Topic Exchange：主题交换器，工作方式类似于组播，Exchange 会将消息转发和 ROUTING_KEY 匹配模式相同的所有队列。</p><p>Topic 模式，Exchange 将 ROUTING_KEY 和某 Topic 进行模糊匹配。此时队列需要绑定一个 Topic，可以使用通配符进行模糊匹配，符号 “#” 匹配一个或多个词，符号 “<em>” 匹配不多不少一个词。因此 “log.#” 能够匹配到“log.info.oa”，但是“log.</em>” 只会匹配到“log.error”。所以，Topic Exchange 使用非常灵活。</p><p><img src="/media/15789869946673/306976-20160728104309934-1385658660.png" alt="Topic Exchange"></p><p><strong>4、Headers Exchange</strong></p><p>Headers Exchange：首部交换器和扇形交换器都不需要路由键 ROUTING_KEY，首部交换器和主题交换机有点相似，但是不同于主题交换机的路由是基于路由键，头交换机的路由值基于消息的 header 数据，主题交换机路由键只有是字符串，而头交换机可以是整型和哈希值。</p><p>Headers 模式，Headers 是一个键值对，可以定义成 Hashtable。发送者在发送的时候定义一些键值对，接收者也可以再绑定时候传入一些键值对，两者匹配的话，则对应的队列就可以收到消息。匹配有两种方式 all 和 any。这两种方式是在接收端必须要用键值 “x-mactch” 来定义。all 代表定义的多个键值对都要满足，而 any 则代码只要满足一个就可以了。fanout，direct，topic exchange 的 ROUTING_KEY 都需要要字符串形式的，而 headers exchange 则没有这个要求，因为键值对的值可以是任何类型。</p><p><img src="/media/15789869946673/1348888-41575fd1aca2a170.jpg" alt="Headers Exchange"></p><h2 id="RabbitMQ-安装以及环境配置"><a href="#RabbitMQ-安装以及环境配置" class="headerlink" title="RabbitMQ 安装以及环境配置"></a>RabbitMQ 安装以及环境配置</h2><p>本文统一使用软件包管理器的方式安装 RabbitMQ，减少环境变量的配置，更加方便快捷。RabbitMQ 官网也有详细的安装教程，感兴趣的同学，可以参考下。<a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">Downloading and Installing RabbitMQ</a></p><h3 id="Linux-安装-RabbitMQ"><a href="#Linux-安装-RabbitMQ" class="headerlink" title="Linux 安装 RabbitMQ"></a>Linux 安装 RabbitMQ</h3><p>CentOS7 中使用 yum 安装 RabbitMQ 的方法，RabbitMQ 是采用 Erlang 语言实现，因此安装 RabbitMQ 前，需要先安装 Erlang。直接用 yum install erlang 安装的版本是 R16B-03.18.el7，不满足要求，为此，RabbitMQ 贴心提供了一个 <a href="https://github.com/rabbitmq/erlang-rpm" target="_blank" rel="noopener">erlang.repo</a>，将以下内容添加到 /etc/yum.repos.d/rabbitmq-erlang.repo。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将 erlang 新版本源添加到 /etc/yum.repos.d/rabbitmq-erlang.repo</span></span><br><span class="line"><span class="comment"># In /etc/yum.repos.d/rabbitmq_erlang.repo</span></span><br><span class="line">[rabbitmq_erlang]</span><br><span class="line">name=rabbitmq_erlang</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/$basearch</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line"><span class="comment"># PackageCloud's repository key and RabbitMQ package signing key</span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line">[rabbitmq_erlang-source]</span><br><span class="line">name=rabbitmq_erlang-source</span><br><span class="line">baseurl=https://packagecloud.io/rabbitmq/erlang/el/7/SRPMS</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"><span class="comment"># PackageCloud's repository key and RabbitMQ package signing key</span></span><br><span class="line">gpgkey=https://packagecloud.io/rabbitmq/erlang/gpgkey</span><br><span class="line">       https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</span><br><span class="line">sslverify=1</span><br><span class="line">sslcacert=/etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">metadata_expire=300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装 erlang</span></span><br><span class="line">$ yum install erlang -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 将 RabbitMQ 新版本源添加到 /etc/yum.repos.d/rabbitmq-erlang.repo</span></span><br><span class="line">[bintray-rabbitmq-server]</span><br><span class="line">name=bintray-rabbitmq-rpm</span><br><span class="line">baseurl=https://dl.bintray.com/rabbitmq/rpm/rabbitmq-server/v3.8.x/el/7/</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 安装 RabbitMQ</span></span><br><span class="line">$ yum install rabbitmq-server -y</span><br></pre></td></tr></table></figure><h3 id="Mac-安装-RabbitMQ"><a href="#Mac-安装-RabbitMQ" class="headerlink" title="Mac 安装 RabbitMQ"></a>Mac 安装 RabbitMQ</h3><p>Mac 中使用 brew 安装 RabbitMQ 的方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用 RabbitMQ 安装</span></span><br><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>rabbitmq</span><br></pre></td></tr></table></figure><h3 id="Windows-安装-RabbitMQ"><a href="#Windows-安装-RabbitMQ" class="headerlink" title="Windows 安装 RabbitMQ"></a>Windows 安装 RabbitMQ</h3><p>Windows 中使用 choco 安装 RabbitMQ 的方法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用 RabbitMQ 安装</span></span><br><span class="line">$ choco <span class="keyword">install</span> rabbitmq</span><br></pre></td></tr></table></figure><h3 id="开启-rabbitmq-management-以便通过浏览器访问控制台"><a href="#开启-rabbitmq-management-以便通过浏览器访问控制台" class="headerlink" title="开启 rabbitmq_management 以便通过浏览器访问控制台"></a>开启 rabbitmq_management 以便通过浏览器访问控制台</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 开启 rabbitmq_management 以便通过浏览器访问控制台</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 将 RabbitMQ 加入开机自启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> rabbitmq-server.service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 立即启动 RabbitMQ</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start rabbitmq-server.service</span></span><br></pre></td></tr></table></figure><p>管理控制台的地址默认为 <a href="http://server-name:15672" target="_blank" rel="noopener">http://server-name:15672</a> （将其中 server-name 替换为你自己的 ip 地址）。RabbitMQ 默认有个 guest 账号，密码也为 guest，但是如果不是从 RabbitMQ 所在机器上试图用这个账号登陆管理控制台的话，会报错误：“User can only log in via localhost”。RabbitMQ 3.0 开始禁止使用 guest/guest 权限通过除 localhost 外的访问。因此，我们需要添加一个超级管理员。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 添加一个账户吧，用户名 admin 密码 admin</span></span><br><span class="line">$ rabbitmqctl add_user <span class="literal">admin</span> <span class="literal">admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 该用户赋予超级管理员的角色</span></span><br><span class="line">$ rabbitmqctl set_user_tags <span class="literal">admin</span> administrator</span><br></pre></td></tr></table></figure><p><strong>在 RabbitMQ 中，用户角色可分为五类：</strong></p><ul><li>超级管理员（administrator）：可登陆管理控制台，可查看所有的信息，并且可以对用户、策略（policy） 进行操作。</li><li>监控者（monitoring）：可登陆管理控制台，同时可以查看 RabbitMQ 节点的相关信息（进程数，内存使用情况，磁盘使用情况等）。</li><li>策略制定者（policymaker）：可登陆管理控制台，同时可以对 policy 进行管理，但无法查看节点的相关信息。</li><li>普通管理者（management）：仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</li><li>其他：无法登陆管理控制台，通常就是普通的生产者和消费者。</li></ul><h2 id="RabbitMQ-的六种消息队列教程"><a href="#RabbitMQ-的六种消息队列教程" class="headerlink" title="RabbitMQ 的六种消息队列教程"></a>RabbitMQ 的六种消息队列教程</h2><p><img src="/media/15789869946673/20180805223801450.jpg" alt="RabbitMQ 的六种消息队列"></p><p>1、 导入 RabbitMQ 的客户端依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、 定义创建连接工具类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">static</span> Connection getConnection() throws Exception &#123;</span><br><span class="line">        <span class="comment">// 定义连接工厂</span></span><br><span class="line">        ConnectionFactory <span class="keyword">factory</span> = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 设置服务器地址</span></span><br><span class="line">        <span class="keyword">factory</span>.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">// 设置服务器端口</span></span><br><span class="line">        <span class="keyword">factory</span>.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">// 设置服务器账号</span></span><br><span class="line">        <span class="keyword">factory</span>.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">// 设置服务器密码</span></span><br><span class="line">        <span class="keyword">factory</span>.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        <span class="comment">// 通过连接工厂获取连接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">factory</span>.newConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Hello-World-”"><a href="#“Hello-World-”" class="headerlink" title="“Hello World!”"></a>“Hello World!”</h3><p>创建一个生产者项目用来向消息队列发送数据，创建一个消费者项目用来从消息队列里接收数据，消费者需要注册到指定到 MQ 队列中，如下图所示：</p><p><img src="/media/15789869946673/python-one.png" alt="RabbitMQ 简单模式"></p><p>1、Publisher ：消息生产者 Publisher 向交换器（AMQP default）发送消息，交换器类型为 Direct Exchange，消息传递时，ROUTING_KEY 必须完全匹配，才会被队列接收，否则该消息会被抛弃。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Send &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建队列（队列名称，非持久化，非独占，不自动删除队列，空参数）</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="string">"Hello World!"</span>;</span><br><span class="line">            <span class="comment">// 发送消息（exchange，routingKey，其他属性，消息正文），交换器名称为默认(AMQP default)，交换器类型为direct</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Consumer ：消息消费者 Consumer 从消息队列 hello 中取得消息</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Recv &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建队列（队列名称，非持久化，非独占，不自动删除队列，空参数）</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">                <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">            channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Work-queues"><a href="#Work-queues" class="headerlink" title="Work queues"></a>Work queues</h3><p>Work queues 工作队列也称为任务队列，主要思想是避免立即执行资源密集型的任务。将需要执行的任务放到消息队列中，等待资源空闲时消费者从消息队列中取出消息并逐个执行。使用任务队列的优点之一是能够轻松并行化工作，如果我们正在积压工作，我们可以增加更多的消费者，这样就可以轻松扩展。工作队列适用于很多场景，一般的使用方式也都是采用任务队列，如下图所示：</p><p><img src="/media/15789869946673/python-two.png" alt="RabbitMQ Work queues 工作队列模式"></p><p>1、Publisher ：消息生产者 Publisher 向交换器（AMQP default）发送消息，交换器类型为 Direct Exchange。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Send &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建队列（队列名称，持久化，非独占，不自动删除队列，空参数）</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 遍历发送 100 条消息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 消息内容</span></span><br><span class="line">                <span class="keyword">String</span> message = <span class="keyword">String</span>.format(<span class="string">"Hello World! %s"</span>, i);</span><br><span class="line">                <span class="comment">// 发送消息（exchange，routingKey，其他属性，消息正文），交换器名称为默认(AMQP default)，交换器类型为direct</span></span><br><span class="line">                channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Consumer：消息消费者 Consumer 从消息队列 hello 中取得消息，通过 Thread.sleep() 函数来伪造资源密集型的任务</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Recv &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">String</span> QUEUE_NAME = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明创建队列（队列名称，持久化，非独占，不自动删除队列，空参数）</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doWork();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">" [x] Done"</span>);</span><br><span class="line">                <span class="comment">// 手动消息确认（若忘记手动消息确认，当您的客户端退出时，消息将被重新发送（可能看起来像是随机重新发送），但是RabbitMQ将消耗越来越多的内存，因为它将无法释放任何未确认的消息。）</span></span><br><span class="line">                channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> doWork()  &#123;</span><br><span class="line">        <span class="comment">// Thread.sleep（）函数来伪造资源密集型的任务</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Consumer：当任务积压时，我们只需要启动多个消费者，这样就可以轻松扩展，完成消费。</p><p><strong>注意：</strong>默认情况下，RabbitMQ 将每个消息依次发送给下一个使用者。平均而言，每个消费者都会收到相同数量的消息。这种分发消息的方式称为循环。</p><h3 id="Publish-Subscribe"><a href="#Publish-Subscribe" class="headerlink" title="Publish/Subscribe"></a>Publish/Subscribe</h3><p>Publish/Subscribe 发布订阅模式，将消息广播发送给所有消费者。这里以日志系统为例，假设生产者程序将消息发送给两个消费者，其中一个消费者负责将日志输出到控制台，另外一个消费者负责将日志写入到磁盘。Publish/Subscribe 发布订阅模式中交换器类型为 Fanout Exchange。扇形交换器，所有发送到 Fanout Exchange 的消息都会被转发到与该 Exchange 绑定 （Binding） 的所有 Queue 上，如下图所示：</p><p><img src="/media/15789869946673/20200117143611.png" alt="RabbitMQ Publish/Subscribe 发布订阅模式"></p><p>1、Publisher ：消息生产者 Publisher 向交换器 logs 发送消息，交换器类型为 Fanout Exchange。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class EmitLog &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建交换器（交换器名称，交换器类型，非持久化），交换器类型为扇形交换器</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="string">"Hello World!"</span>;</span><br><span class="line">            <span class="comment">// 发送消息（exchange，routingKey，其他属性，消息正文），当ExchangeType为fanout时，将忽略routingKey参数</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Consumer：消息消费者 Consumer 从 channel 中获取一个随机的非持久化自动删除队列（客户端退出就自动删除），然 绑定消息队列和 exchange。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ReceiveLogs &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> EXCHANGE_NAME = <span class="string">"logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明创建交换器（交换器名称，交换器类型，非持久化），交换器类型为扇形交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 获取队列，得到一个随机名称（非持久化的自动删除队列）</span></span><br><span class="line">        <span class="keyword">String</span> queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定消息队列和exchange</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Consumer：当启动多个消费者，每个消费者会创建队列并绑定至交换器 logs 上，消息生产者向交换器 logs 发送消息，交换器 logs 将消息转发到与该 Exchange 绑定 （Binding） 的所有 Queue 上。</p><p><strong>注意：</strong>消费者必须先绑定到 exchange 上，然后生产者再发送消息，否则 exchange 无法将消息路由到任何队列。</p><h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p>Routing 路由，进行有选择的接收消息，可以订阅某个消息队列的子集。例如，我们将只能将严重错误消息定向到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。Routing 路由模式中交换器类型为 Fanout Exchange。直接交换器，Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的交换机模式，根据 ROUTING_KEY 全文匹配去寻找队列。其工作方式类似于单播，Exchange 会将消息发送完全匹配 ROUTING_KEY 的 Queue，如下图所示：</p><p><img src="/media/15789869946673/four.png" alt="RabbitMQ Routing 路由模式"></p><p>1、Publisher ：消息生产者 Publisher 向交换器 direct_logs  发送消息，交换器类型为 Direct Exchange。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建交换器（交换器名称，交换器类型），交换器类型为直接交换器</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向指定exchange发送消息，路由key为 info</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"info"</span>, <span class="keyword">null</span>, <span class="string">"info message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向指定exchange发送消息，路由key为 warning</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"warning"</span>, <span class="keyword">null</span>, <span class="string">"warning message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向指定exchange发送消息，路由key为 error</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"error"</span>, <span class="keyword">null</span>, <span class="string">"error message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Consumer：消息消费者 Consumer 从 channel 中获取一个随机的非持久化自动删除队列（客户端退出就自动删除），绑定消息队列、exchange、路由 key。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ReceiveLogsDirect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明创建交换器（交换器名称，交换器类型），交换器类型为直接交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 获取队列，得到一个随机名称（非持久化的自动删除队列）</span></span><br><span class="line">        <span class="keyword">String</span> queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//  绑定消息队列、exchange、路由key为error</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"error"</span>);</span><br><span class="line">        <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Consumer：消费者可以为一个队列绑定多个 routingKey。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ReceiveLogsDirect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> EXCHANGE_NAME = <span class="string">"direct_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明创建交换器（交换器名称，交换器类型），交换器类型为直接交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">// 获取队列，得到一个随机名称（非持久化的自动删除队列）</span></span><br><span class="line">        <span class="keyword">String</span> queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//  绑定消息队列、exchange、路由key为info</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"info"</span>);</span><br><span class="line">        <span class="comment">//  绑定消息队列、exchange、路由key为error</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"error"</span>);</span><br><span class="line">        <span class="comment">//  绑定消息队列、exchange、路由key为warning</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"warning"</span>);</span><br><span class="line">        <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h3><p>Topics 主题，基于主题交换的策略接收消息，基于 Topics 的方式可以让消息队列的使用更加灵活，为消息的发送和订阅提供更加细粒度的控制。例如，在我们的日志记录系统中，我们可能不仅要根据严重性订阅日志，还要根据发出日志的源订阅日志。Topics 主题模式中交换器类型为 Topic Exchange。主题交换器，工作方式类似于组播，Exchange 会将消息转发和 ROUTING_KEY 匹配模式相同的所有队列，如下图所示：</p><p><img src="/media/15789869946673/topic.png" alt="RabbitMQ Topics 主题模式"></p><p>1、Publisher ：消息生产者 Publisher 向交换器 topic_logs  发送消息，交换器类型为 Topic Exchange。首先需要指定 exchange 的类型为 topic，在生产者发送消息时设置 routingKey 为一个符号表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLogTopic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接并创建通道</span></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = ConnectionUtils.getConnection(); Channel channel = connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明创建交换器（交换器名称，交换器类型），交换器类型为主题交换器</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向指定exchange发送消息, routingKey 为 s.info.l， 订阅的消费者需要指定主题routingKey为 *.info.* 或者 #.info.#</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"s.info.l"</span>, <span class="keyword">null</span>, <span class="string">"info message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向指定exchange发送消息, routingKey 为 lazy.test.one, 订阅的消费者需要指定主题routingKey为 lazy.#</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">"lazy.test.one"</span>, <span class="keyword">null</span>, <span class="string">"lazy message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、Consumer：消息消费者 Consumer 从 channel 中获取一个随机的非持久化自动删除队列（客户端退出就自动删除），通过符号表达式绑定消息队列、exchange、路由 key。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ReceiveLogsTopic &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> EXCHANGE_NAME = <span class="string">"topic_logs"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取连接</span></span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明创建交换器（交换器名称，交换器类型），交换器类型为主题交换器</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        <span class="comment">// 获取队列，得到一个随机名称（非持久化的自动删除队列）</span></span><br><span class="line">        <span class="keyword">String</span> queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">// 绑定消息队列和exchange</span></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.info.*"</span>);</span><br><span class="line">        <span class="comment">// 消费者接收到队列投递的回调（consumerTag 服务端生成的消费者标识，delivery投递）</span></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="comment">//  获取消息内容并输出</span></span><br><span class="line">            <span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 开启消费者监听（队列名称，自动确认消息，投递消息回调，取消消息回调），此时 RabbitMQ 将消息推送至消费者（若想用拉的方式，则可以使用channel.basicGet()方法）</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC 远程过程调用，RabbitMQ 也支持这种同步调用的特性，调用之后等待调用结果返回。该模式使用率较少，在实际项目中应用场景较小。如下图所示：</p><p><img src="/media/15789869946673/20200117155340.png" alt="RabbitMQ RPC 远程过程调用模式"></p><p>客户端通过 RabbitMQ 的 RPC 调用服务端，等待服务端返回结果，示例程序如下：</p><p>1、为了说明如何使用 RPC 服务，我们将创建一个简单的客户端类。它将公开一个名为 call 的方法，该方法 发送 RPC 请求并阻塞，直到收到答案为止：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">AutoCloseable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> RPC_QUEUE_NAME = <span class="string">"rpc_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RPCClient() throws IOException, TimeoutException &#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> <span class="type">ConnectionFactory</span>();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        connection = connectionFactory.<span class="keyword">new</span><span class="type">Connection</span>();</span><br><span class="line">        channel = connection.createChannel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> (RPCClient fibonacciRpc = <span class="keyword">new</span> <span class="type">RPCClient</span>()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">String</span> i_str = Integer.toString(i);</span><br><span class="line">                System.out.println(<span class="string">" [x] Requesting fib("</span> + i_str + <span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">String</span> response = fibonacciRpc.call(i_str);</span><br><span class="line">                System.out.println(<span class="string">" [.] Got '"</span> + response + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> call(<span class="keyword">String</span> message) throws IOException, InterruptedException &#123;</span><br><span class="line">        final <span class="keyword">String</span> corrId = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> replayQueueName = channel.queueDeclare().getQueue();</span><br><span class="line">        AMQP.BasicProperties basicProperties = <span class="keyword">new</span> <span class="type">AMQP</span>.BasicProperties</span><br><span class="line">                .Builder()</span><br><span class="line">                .correlationId(corrId)</span><br><span class="line">                .replyTo(replayQueueName)</span><br><span class="line">                .build();</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, RPC_QUEUE_NAME, basicProperties, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        final BlockingQueue&lt;<span class="keyword">String</span>&gt; response = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> cTag = channel.basicConsume(replayQueueName, <span class="literal">true</span>, (consumeTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (delivery.getProperties().getCorrelationId().equals(corrId)) &#123;</span><br><span class="line">                response.offer(<span class="keyword">new</span> <span class="type">String</span>(delivery.getBody(), StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">String</span> result = response.take();</span><br><span class="line">        channel.basicCancel(cTag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> void close() throws Exception &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、由于我们没有值得分配的耗时任务，因此我们将创建一个虚拟 RPC 服务，该服务返回斐波那契数：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class RPCServer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> RPC_QUEUE_NAME  = <span class="string">"rpc_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> fib(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        connectionFactory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Connection connection = connectionFactory.newConnection()) &#123;</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            channel.queueDeclare(RPC_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            channel.queuePurge(RPC_QUEUE_NAME);</span><br><span class="line"></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">" [x] Awaiting PRC request"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Object</span> monitor = <span class="keyword">new</span> <span class="keyword">Object</span>();</span><br><span class="line">            DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">                AMQP.BasicProperties replyProperties = <span class="keyword">new</span> AMQP.BasicProperties</span><br><span class="line">                        .Builder()</span><br><span class="line">                        .correlationId(message.getProperties().getCorrelationId())</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">String</span> response = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">String</span> theMessage = <span class="keyword">new</span> <span class="keyword">String</span>(message.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="built_in">int</span> n = Integer.parseInt(theMessage);</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">" [.] fib("</span> + n + <span class="string">")"</span>);</span><br><span class="line">                    response += fib(n);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">" [.] "</span> + e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">""</span>, message.getProperties().getReplyTo(), replyProperties, response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                        monitor.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(RPC_QUEUE_NAME, <span class="keyword">false</span>, deliverCallback, (consumeTag -&gt; &#123;</span><br><span class="line">            &#125;));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (monitor) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        monitor.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException | IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了spring-boot-starter-amqp 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 spring-boot-starter-amqp 的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.host</span>=localhost</span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.port</span>=<span class="number">5672</span></span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.username</span>=guest</span><br><span class="line">spring<span class="selector-class">.rabbitmq</span><span class="selector-class">.password</span>=guest</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Receiver : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqHelloTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><h4 id="对象的支持"><a href="#对象的支持" class="headerlink" title="对象的支持"></a>对象的支持</h4><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span>(<span class="params">User user</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Sender object: "</span> + user.toString());</span><br><span class="line">    <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"object"</span>, user);</span><br><span class="line">    <span class="comment">// Sender object: User&#123;name='neo', pass='123456'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收者</span></span><br><span class="line">@RabbitHandler(queues = <span class="string">"object"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">User user</span>)</span> &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(<span class="string">"Receiver object : "</span> + user);</span><br><span class="line">    <span class="comment">// Receiver object : User&#123;name='neo', pass='123456'&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h4><p>在使用 RabbitMQ 时，我们可以通过消息持久化来解决服务器因异常崩溃而造成的消息丢失。在使用 RabbitMQ 时，我们可以通过消息持久化来解决服务器因异常崩溃而造成的消息丢失。其中，RabblitMQ 的持久化分为三个部分：交换器（Exchange）的持久化、队列（Queue）的持久化、消息（Message）的持久化。</p><p>1、设置队列、交换器持久化，防止在 RabbitMQ 出现异常情况（重启，宕机）时，Exchange、Queue 丢失，影响后续的消息写入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数1 name ：队列名</span></span><br><span class="line">        <span class="comment">// 参数2 durable ：是否持久化</span></span><br><span class="line">        <span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除</span></span><br><span class="line">        <span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// （交换器名称，设置 durable=true 持久化交换器，非独占，不自动删除队列，空参数）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"directExchange"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queue, DirectExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(directExchange).with(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者通过消费者 @RabbitListener 注解的方式进行持久化。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="comment">// 如果不存在，自动创建队列和交换器并且绑定</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(</span><br><span class="line">        bindings = <span class="variable">@QueueBinding</span>(</span><br><span class="line">                value = <span class="variable">@Queue</span>(value = <span class="string">"hello"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">                exchange = <span class="variable">@Exchange</span>(value = <span class="string">"directExchange"</span>, type = <span class="string">"direct"</span>, durable = <span class="string">"true"</span>),</span><br><span class="line">                key = <span class="string">"hello"</span>))</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"Receiver : "</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Exchange 交换器的持久化，在声明时指定 durable =&gt; true，若 durable=false 非持久化，在 RabbitMQ 出现异常情况（重启，宕机）时，该 Exchange 会丢失，会影响后续的消息写入该 Exchange；Queue 队列的持久化，在声明时指定 durable =&gt; true，若 durable=false 非持久化，在 RabbitMQ 出现异常情况（重启，宕机）时，队列丢失，队列丢失导致队列与 Exchange 绑定关系丢失，会影响后续的消息路由给服务器中的队列。</p><p>3、发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Sender : "</span> + context);</span><br><span class="line">        <span class="comment">// 通过阅读源代码可以发现 new MessageProperties() 持久化的策略是 MessageDeliveryMode.PERSISTENT，因此它会初始化时默认消息是持久化的</span></span><br><span class="line">        Message message = MessageBuilder.withBody(context.getBytes()).build();</span><br><span class="line">        message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">"hello"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Spring AMQP 是对原生的 RabbitMQ 客户端的封装。一般情况下，我们只需要定义交换器的持久化和队列的持久化。Message 消息的持久化，在投递时指定 delivery_mode =&gt; 2（1 是非持久化），RabbitTemplate 它持久化的策略是 MessageDeliveryMode.PERSISTENT，因此它会初始化时默认消息是持久化的。</p><p>4、注意事项</p><p>（1）理论上可以将所有的消息都设置为持久化，但是这样会严重影响 RabbitMQ 的性能。因为写入磁盘的速度比写入内存的速度慢得不止一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吞吐量之间做一个权衡。</p><p>（2）将交换器、队列、消息都设置了持久化之后仍然不能百分之百保证数据不丢失，因为当持久化的消息正确存入 RabbitMQ 之后，还需要一段时间（虽然很短，但是不可忽视）才能存入磁盘之中。如果在这段时间内 RabbitMQ 服务节点发生了宕机、重启等异常情况，消息还没来得及落盘，那么这些消息将会丢失。</p><p>（3）单单只设置队列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。</p><h4 id="ACK-确认机制"><a href="#ACK-确认机制" class="headerlink" title="ACK 确认机制"></a>ACK 确认机制</h4><p>默认情况下消息消费者是自动 ack （确认）消息的，自动确认会在消息发送给消费者后立即确认，这样存在丢失消息的可能。</p><p>1、配置 RabbitMQ 的安装地址、端口、账户信息以及 ACK 确认模式</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.<span class="attribute">host</span>=118.25.39.41</span><br><span class="line">spring.rabbitmq.<span class="attribute">port</span>=5672</span><br><span class="line">spring.rabbitmq.<span class="attribute">username</span>=admin</span><br><span class="line">spring.rabbitmq.<span class="attribute">password</span>=admin</span><br><span class="line"><span class="comment">## 确认模式设置为手动签收，1、NONE：没有ack的意思，对应RabbitMQ的自动确认模式；2、MANUAL：手动模式，对应RabbitMQ的显式确认模式；AUTO：自动模式，对应RabbitMQ的显式确认模式；</span></span><br><span class="line"><span class="comment">## MANUAL与AUTO的关系有点类似于在Spring中手动提交事务与自动提交事务的区别：一个是手动发送ack；一个是在方法执行完，没有异常的情况下自动发送ack</span></span><br><span class="line">spring.rabbitmq.listener.simple.<span class="attribute">acknowledge-mode</span>=MANUAL</span><br></pre></td></tr></table></figure><p>注意：AcknowledgeMode.MANUAL 模式需要人为地获取到 channel 之后调用方法向 server 发送 ack（或消费失败时的 nack）信息；AcknowledgeMode.AUTO 模式下，由 spring-rabbit 依据消息处理逻辑是否抛出异常自动发送 ack（无异常）或 nack（异常）到 server 端。</p><p>2、接收者，消息消费者手动确认消息以及消息拒绝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello, Message message, Channel channel)</span> </span>&#123;</span><br><span class="line">        String ackMessage = <span class="string">"hello"</span>;</span><br><span class="line">        <span class="keyword">if</span> (ackMessage.equals(hello)) &#123;</span><br><span class="line">            <span class="comment">// 确认消息接收：第一个deliveryTag参数为每条信息带有的tag值，第二个multiple参数为布尔类型；为true时会将小于等于此次tag的所有消息都确认掉，如果为false则只确认当前tag的信息，可根据实际情况进行选择。</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 消息拒绝：第一个deliveryTag参数为每条信息带有的tag值，第二个multiple参数为布尔类型，第三个requeue参数为拒绝后是否重新回到队列；</span></span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 消息拒绝：basicReject() 和 basicNack()的区别在于basicNack可以批量拒绝多条消息，而basicReject一次只能拒绝一条消息。</span></span><br><span class="line">            <span class="comment">// channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列。</p><p>1、首先对 topic 规则配置，使 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String message = <span class="string">"topic.message"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String messages = <span class="string">"topic.messages"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、发送 send1 会匹配到 topic.# 和 topic.message 两个 Receiver 都可以收到消息，发送 send2 只有 topic.# 可以匹配所有只有 Receiver2 监听到消息。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String <span class="built_in">context</span> = <span class="string">"hi, i am message 1"</span><span class="comment">;</span></span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">    this.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.message"</span>, <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String <span class="built_in">context</span> = <span class="string">"hi, i am messages 2"</span><span class="comment">;</span></span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">    this.rabbitTemplate.convertAndSend(<span class="string">"exchange"</span>, <span class="string">"topic.messages"</span>, <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>1、首先对 fanout 规则配置，这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">AMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">BMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">CMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"fanout.C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanoutExchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeA</span><span class="params">(Queue AMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeB</span><span class="params">(Queue BMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingExchangeC</span><span class="params">(Queue CMessage, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、绑定到 fanout 交换机上面的队列都收到了消息</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String <span class="built_in">context</span> = <span class="string">"hi, fanout msg "</span><span class="comment">;</span></span><br><span class="line">    System.out.println(<span class="string">"Sender : "</span> + <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">    this.rabbitTemplate.convertAndSend(<span class="string">"fanoutExchange"</span>,<span class="string">""</span>, <span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Sender :</span> hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver <span class="string">B:</span> hi, fanout msg </span><br><span class="line">fanout Receiver <span class="string">A  :</span> hi, fanout msg </span><br><span class="line">fanout Receiver <span class="string">C:</span> hi, fanout msg</span><br></pre></td></tr></table></figure><h2 id="基于-RabbitMQ-实现消息延迟队列方案"><a href="#基于-RabbitMQ-实现消息延迟队列方案" class="headerlink" title="基于 RabbitMQ 实现消息延迟队列方案"></a>基于 RabbitMQ 实现消息延迟队列方案</h2><p>延时队列顾名思义，即放置在该队列里面的消息是不需要立即消费的，而是等待一段时间之后取出消费。在很多的业务场景中，延时队列可以实现很多功能，此类业务中，一般上是非实时的，需要延迟处理的，需要进行重试补偿的。</p><ul><li>订单超时关闭：在支付场景中，一般上订单在创建后 30 分钟或 1 小时内未支付的，会自动取消订单。</li><li>短信或者邮件通知：在一些注册或者下单业务时，需要在 1 分钟或者特定时间后进行短信或者邮件发送相关资料的。本身此类业务于主业务是无关联性的，一般上的做法是进行异步发送。</li><li>重试场景：比如消息通知，在第一次通知出现异常时，会在隔几分钟之后进行再次重试发送。</li></ul><p>RabbitMQ 实现延时队列一般而言有两种形式：</p><ul><li>第一种方式：利用两个特性，Time To Live（TTL）、Dead Letter Exchanges（DLX），通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能</li><li>第二种方式：利用 RabbitMQ 中的插件 x-delay-message 实现延迟功能</li></ul><h3 id="第一种方式：利用两个特性，Time-To-Live（TTL）、Dead-Letter-Exchanges（DLX）"><a href="#第一种方式：利用两个特性，Time-To-Live（TTL）、Dead-Letter-Exchanges（DLX）" class="headerlink" title="第一种方式：利用两个特性，Time To Live（TTL）、Dead Letter Exchanges（DLX）"></a>第一种方式：利用两个特性，Time To Live（TTL）、Dead Letter Exchanges（DLX）</h3><p>AMQP 协议和 RabbitMQ 队列本身没有直接支持延迟队列功能，但是我们可以通过 RabbitMQ 的两个特性 TTL（Time-To-Live，存活时间）和 DLX（Dead-Letter-Exchange，死信队列交换机）来曲线实现延迟队列：</p><h4 id="存活时间（Time-To-Live-简称-TTL）"><a href="#存活时间（Time-To-Live-简称-TTL）" class="headerlink" title="存活时间（Time-To-Live 简称 TTL）"></a>存活时间（Time-To-Live 简称 TTL）</h4><p>RabbitMQ 可以通过设置队列过期时间实现延时消费或者通过设置消息过期时间实现延时消费，如果超时（两者同时设置以最先到期的时间为准），则消息变为 dead letter（死信）。</p><p>RabbitMQ 针对队列中的消息过期时间有两种方法可以设置，A：通过队列属性设置，队列中所有消息都有相同的过期时间；B：对消息进行单独设置，每条消息 TTL 可以不同。如果同时使用，则消息的过期时间以两者之间 TTL 较小的那个数值为准。消息在队列的生存时间一旦超过设置的 TTL 值，就成为 dead letter。</p><h4 id="死信交换（Dead-Letter-Exchanges-简称-DLX）"><a href="#死信交换（Dead-Letter-Exchanges-简称-DLX）" class="headerlink" title="死信交换（Dead Letter Exchanges 简称 DLX）"></a>死信交换（Dead Letter Exchanges 简称 DLX）</h4><p>设置了 TTL 的消息或队列最终会成为 Dead Letter，当消息在一个队列中变成死信之后，它能被重新发送到另一个交换机中，这个交换机就是 DLX，绑定此 DLX 的队列就是死信队列。</p><p>RabbitMQ 的 Queue 可以配置 x-dead-letter-exchange 和 x-dead-letter-routing-key（可选）两个参数，如果队列内出现了 dead letter，则按照这两个参数重新路由转发到指定的队列。</p><p>x-dead-letter-exchange：出现 dead letter 之后将 dead letter 重新发送到指定 exchange；<br>x-dead-letter-routing-key：出现 dead letter 之后将 dead letter 重新按照指定的 routing-key 发送。</p><p>队列出现 dead letter 的情况有：</p><ul><li><p>消息或者队列的 TTL 过期；</p></li><li><p>队列达到最大长度；</p></li><li><p>消息被消费端拒绝（basic.reject or basic.nack）并且 requeue=false。</p></li></ul><h4 id="Spring-Boot-集成-RabbitMQ-实现延时队列实战"><a href="#Spring-Boot-集成-RabbitMQ-实现延时队列实战" class="headerlink" title="Spring Boot 集成 RabbitMQ 实现延时队列实战"></a>Spring Boot 集成 RabbitMQ 实现延时队列实战</h4><p>1、队列以及交换器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 死信队列跟交换机类型没有关系，不一定为directExchange，不影响该类型交换机的特性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">"dead.letter.direct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">repeatTradeQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于延时消费的队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"repeat.trade.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">repeatTradeBinding</span><span class="params">(Queue repeatTradeQueue, DirectExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定交换机并指定routing key</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(repeatTradeQueue).to(directExchange).with(<span class="string">"repeat.trade.queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置死信队列</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 方式一：设置队列过期时间实现延时消费，设置队列中消息存活时间为3秒</span></span><br><span class="line">        args.put(<span class="string">"x-message-ttl"</span>, <span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 出现 dead letter 之后将 dead letter 重新发送到指定 exchange</span></span><br><span class="line">        args.put(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"dead.letter.direct"</span>);</span><br><span class="line">        <span class="comment">// 出现 dead letter 之后将 dead letter 重新按照指定的 routing-key 发送</span></span><br><span class="line">        args.put(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"repeat.trade.queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"dead.letter.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、发送者，这里发送者需要指定前面配置了过期时间的队列 dead.letter.queue</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DeadLetterSender &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> send() &#123;</span><br><span class="line">        <span class="built_in">String</span> context = <span class="string">"hello "</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">"DeadLetterSender sendTime:"</span> + LocalDateTime.now().toString() + <span class="string">" message:"</span> + context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：设置消息过期时间实现延时消费，设置消息存活时间为10秒，同时使用队列过期时间以及消息过期时间，则消息的过期时间以两者之间TTL较小的那个数值为准。</span></span><br><span class="line">        MessagePostProcessor messagePostProcessor = message -&gt; &#123;</span><br><span class="line">            MessageProperties messageProperties = message.getMessageProperties();</span><br><span class="line">            <span class="comment">// 设置过期时间10*1000毫秒</span></span><br><span class="line">            messageProperties.setExpiration(<span class="string">"10000"</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向dead.letter.queue发送消息，10*1000毫秒后过期，形成死信</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"dead.letter.queue"</span>, (<span class="built_in">Object</span>) context, messagePostProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、接收者，消费者监听指定用于延时消费的队列 repeat.trade.queue</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"repeat.trade.queue"</span>)</span><br><span class="line">public class RepeatTradeReceiver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void process(String msg) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"RepeatTradeReceiver receiptTime:"</span> + LocalDateTime.now().toString() + <span class="string">" message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootTest</span></span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private DeadLetterSender deadLetterSender;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@SneakyThrows</span></span><br><span class="line">    <span class="variable">@Test</span></span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        <span class="selector-tag">deadLetterSender</span><span class="selector-class">.send</span>();</span><br><span class="line">        <span class="comment">// 线程休眠5s，等待死信队列中的消息过期变成死信，重新发送到 repeatTradeQueue 队列中</span></span><br><span class="line">        <span class="selector-tag">TimeUnit</span><span class="selector-class">.SECONDS</span><span class="selector-class">.sleep</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">DeadLetterSender</span> <span class="selector-tag">sendTime</span><span class="selector-pseudo">:2020-01-19T17</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:42.633</span> <span class="selector-tag">message</span><span class="selector-pseudo">:hello</span> <span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 19 17<span class="selector-pseudo">:15</span><span class="selector-pseudo">:42</span> <span class="selector-tag">CST</span> 2020</span><br><span class="line"><span class="selector-tag">RepeatTradeReceiver</span> <span class="selector-tag">receiptTime</span><span class="selector-pseudo">:2020-01-19T17</span><span class="selector-pseudo">:15</span><span class="selector-pseudo">:45.672</span> <span class="selector-tag">message</span><span class="selector-pseudo">:hello</span> <span class="selector-tag">Sun</span> <span class="selector-tag">Jan</span> 19 17<span class="selector-pseudo">:15</span><span class="selector-pseudo">:42</span> <span class="selector-tag">CST</span> 2020</span><br></pre></td></tr></table></figure><p><img src="/media/15789869946673/59254a4fe4b0b33567a81dfa.png" alt="利用两个特性，Time To Live、Dead Letter Exchanges 两个特征实现延时队列"></p><h3 id="第二种方式：利用-RabbitMQ-中的插件-x-delay-message"><a href="#第二种方式：利用-RabbitMQ-中的插件-x-delay-message" class="headerlink" title="第二种方式：利用 RabbitMQ 中的插件 x-delay-message"></a>第二种方式：利用 RabbitMQ 中的插件 x-delay-message</h3><p>延迟插件 rabbitmq-delayed-message-exchange 是在 RabbitMQ 3.5.7 及以上的版本才支持的，依赖 Erlang/OPT 18.0 及以上运行环境。</p><p>实现机制：安装插件后会生成新的 Exchange 类型 x-delayed-message，该类型消息支持延迟投递机制, 接收到消息后并未立即将消息投递至目标队列中，而是存储在 mnesia（一个分布式数据系统） 表中，检测消息延迟时间，如达到可投递时间时并将其通过 x-delayed-type 类型标记的交换机类型投递至目标队列。</p><h4 id="安装延迟插件"><a href="#安装延迟插件" class="headerlink" title="安装延迟插件"></a>安装延迟插件</h4><p>1、下载插件</p><p>可以通过 RabbitMQ 官网的官方插件  <a href="https://www.rabbitmq.com/community-plugins.html" target="_blank" rel="noopener">Community Plugins</a> 下载相对应的 rabbitmq_delayed_message_exchange 插件，并将插件包放在 RabbitMQ 安装目录 plugins 目录下。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos plugins]# wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/v3<span class="meta">.8</span><span class="meta">.0</span>/rabbitmq_delayed_message_exchange-<span class="number">3.8</span><span class="meta">.0</span>.ez</span><br></pre></td></tr></table></figure><p>2、开启 rabbitmq_delayed_message_exchange 插件</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> plugins]<span class="meta"># rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span></span><br></pre></td></tr></table></figure><p>3、查询安装的所有插件，检查 rabbitmq_delayed_message_exchange 插件是否是开启状态</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> plugins]<span class="meta"># rabbitmq-plugins list</span></span><br></pre></td></tr></table></figure><p>4、重启 RabbitMQ，使插件生效</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># systemctl restart rabbitmq-server.service</span></span><br></pre></td></tr></table></figure><p>此时，通过浏览器访问控制台在交换器栏目下新增交换器多了 “x-delayed-message” 类型。</p><h4 id="Spring-Boot-集成-RabbitMQ-实现延时队列实战-1"><a href="#Spring-Boot-集成-RabbitMQ-实现延时队列实战-1" class="headerlink" title="Spring Boot 集成 RabbitMQ 实现延时队列实战"></a>Spring Boot 集成 RabbitMQ 实现延时队列实战</h4><p>1、队列以及交换器配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">directExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义的交换机类型</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        args.put(<span class="string">"x-delayed-type"</span>, <span class="string">"direct"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">"dead.letter.direct"</span>, <span class="string">"x-delayed-message"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置死信队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"dead.letter.queue"</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">repeatTradeBinding</span><span class="params">(Queue repeatTradeQueue, CustomExchange directExchange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定交换机并指定routing key</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(repeatTradeQueue).to(directExchange).with(<span class="string">"repeat.trade.queue"</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、发送者，这里发送者需要指定前面配置了过期时间的队列 dead.letter.queue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String context = <span class="string">"hello "</span> + <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"DeadLetterSender sendTime:"</span> + LocalDateTime.now().toString() + <span class="string">" message:"</span> + context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向dead.letter.queue发送消息，10*1000毫秒后过期，形成死信</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"dead.letter.direct"</span>, <span class="string">"dead.letter.queue"</span>, context, message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 设置消息过期时间实现延时消费，设置消息存活时间为10秒</span></span><br><span class="line">                    message.getMessageProperties().setDelay(<span class="number">10000</span>);</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、接收者，消费者监听指定用于死信队列 dead.letter.queue</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@RabbitListener</span>(queues = <span class="string">"dead.letter.queue"</span>)</span><br><span class="line">public class DeadLetterReceiver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@RabbitHandler</span></span><br><span class="line">    public void process(String msg) &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(<span class="string">"DeadLetterReceiver receiptTime:"</span> + LocalDateTime.now().toString() + <span class="string">" message:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootTest</span></span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private DeadLetterSender deadLetterSender;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@SneakyThrows</span></span><br><span class="line">    <span class="variable">@Test</span></span><br><span class="line">    public void hello() &#123;</span><br><span class="line">        <span class="selector-tag">deadLetterSender</span><span class="selector-class">.send</span>();</span><br><span class="line">        <span class="comment">// 等待接收程序执行之后，再退出测试</span></span><br><span class="line">        <span class="selector-tag">TimeUnit</span><span class="selector-class">.SECONDS</span><span class="selector-class">.sleep</span>(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">DeadLetterSender</span> <span class="selector-tag">sendTime</span><span class="selector-pseudo">:2020-01-20T11</span><span class="selector-pseudo">:08</span><span class="selector-pseudo">:24.412</span> <span class="selector-tag">message</span><span class="selector-pseudo">:hello</span> <span class="selector-tag">Mon</span> <span class="selector-tag">Jan</span> 20 11<span class="selector-pseudo">:08</span><span class="selector-pseudo">:24</span> <span class="selector-tag">CST</span> 2020</span><br><span class="line"><span class="selector-tag">DeadLetterReceiver</span> <span class="selector-tag">receiptTime</span><span class="selector-pseudo">:2020-01-20T11</span><span class="selector-pseudo">:08</span><span class="selector-pseudo">:34.440</span> <span class="selector-tag">message</span><span class="selector-pseudo">:hello</span> <span class="selector-tag">Mon</span> <span class="selector-tag">Jan</span> 20 11<span class="selector-pseudo">:08</span><span class="selector-pseudo">:24</span> <span class="selector-tag">CST</span> 2020</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ 官方文档地址</a><br>[2]. <a href="https://www.cnblogs.com/ityouknow/p/6120544.html" target="_blank" rel="noopener">Spring Boot(八)：RabbitMQ 详解</a><br>[3]. <a href="http://www.imooc.com/article/262102" target="_blank" rel="noopener">Spring Boot（十四）RabbitMQ延迟队列</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. AMQP：AMQP（advanced message queuing protocol）在 2003 年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP 是一种协议，更准确的说是一种 binary wire-level protocol（链接协议）。在 AMQP 中，消息路由（message routing）和 JMS 存在一些差别，在 AMQP 中增加了 Exchange 和 binding 的角色。producer 将消息发送给 Exchange，binding 决定 Exchange 的消息应该发送到那个 queue，而 consumer 直接从 queue 中消费消息。</small></p><hr><h2 id="了不起的消息队列系列"><a href="#了不起的消息队列系列" class="headerlink" title="了不起的消息队列系列"></a>了不起的消息队列系列</h2><ul><li><a href="1c55560e.html">了不起的消息队列（一）：浅谈消息队列及常见的分布式消息队列中间件</a></li><li><a href="f99da47b.html">了不起的消息队列（二）：啊哈！RabbitMQ</a></li><li><a href="5d3d79c7.html">了不起的消息队列（三）：致敬匠心，Kafka</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在本系列的前一篇博文中，笔者对消息队列的概述、特点等进行讲解，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。&lt;/p&gt;
&lt;p&gt;经过上一篇博客介绍，相信大家对消息队列已经有了一个大致了解。RabbitMQ 是 MQ 产品的典型代表，是一款基于 AMQP 协议可复用的企业消息系统。业务上，可以实现服务提供者和消费者之间的数据解耦，提供高可用性的消息传输机制，在实际生产中应用相当广泛。本文意在介绍 RabbitMQ 的基本原理，包括 RabbitMQ 基本框架、概念、通信过程等，介绍一下 RabbitMQ 安装教程，最后介绍一下 RabbitMQ 在项目中实际应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列" scheme="https://blog.maoning.vip/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="安装教程" scheme="https://blog.maoning.vip/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="RabbitMQ" scheme="https://blog.maoning.vip/tags/RabbitMQ/"/>
    
      <category term="AMQP" scheme="https://blog.maoning.vip/tags/AMQP/"/>
    
  </entry>
  
  <entry>
    <title>Java8 那些事儿（六）：从 CompletableFuture 到异步编程</title>
    <link href="https://blog.maoning.vip/archives/a3263046.html"/>
    <id>https://blog.maoning.vip/archives/a3263046.html</id>
    <published>2020-04-19T04:45:12.000Z</published>
    <updated>2020-08-03T09:36:34.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JDK 5 引入了 Future 模式。Future 接口是 Java 多线程 Future 模式的实现，在 java.util.concurrent 包中，可以来进行异步计算。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？如 Netty、Guava 分别扩展了 Java 的 Future 接口，方便异步编程。</p><p>为了解决这个问题，自 JDK8 开始，吸收了 Guava 的设计思想，加入了 Future 的诸多扩展功能形成了 CompletableFuture，让 Java 拥有了完整的非阻塞编程模型。CompletableFuture 它提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力。CompletableFuture 能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p><p>CompletableFuture 弥补了 Future 模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过 thenAccept、thenApply、thenCompose 等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p><a id="more"></a><h2 id="CompletableFuture-简介"><a href="#CompletableFuture-简介" class="headerlink" title="CompletableFuture 简介"></a>CompletableFuture 简介</h2><p>CompletableFuture 类实现了 CompletionStage 和 Future 接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;T&gt; <span class="title">implements</span> <span class="title">Future</span>&lt;T&gt;, <span class="title">CompletionStage</span>&lt;T&gt; &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="supplyAsync-runAsync-异步计算结果"><a href="#supplyAsync-runAsync-异步计算结果" class="headerlink" title="supplyAsync / runAsync 异步计算结果"></a>supplyAsync / runAsync 异步计算结果</h4><p>在该类中提供了四个静态方法创建 CompletableFuture 对象：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码，异步操作有返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span>(<span class="params">Supplier&lt;U&gt; supplier</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的 thread pool 执行异步代码，异步操作有返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span>(<span class="params">Supplier&lt;U&gt; supplier, Executor executor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(screenExecutor(executor), supplier);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span>(<span class="params">Runnable runnable</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指定的 thread pool 执行异步代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span>(<span class="params">Runnable runnable, Executor executor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(screenExecutor(executor), runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以 Async 结尾并且没有指定 Executor 的方法会使用 ForkJoinPool.commonPool() 作为线程池执行异步代码。</li><li>runAsync 方法用于没有返回值的任务，它以 Runnable 函数式接口类型为参数，所以 CompletableFuture 的计算结果为空。</li><li>supplyAsync 方法用于有返回值的任务，以 Supplier&lt;U> 函数式接口类型为参数，CompletableFuture 的计算结果类型为 U。</li></ul><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><h4 id="complete-completeExceptionally"><a href="#complete-completeExceptionally" class="headerlink" title="complete / completeExceptionally"></a>complete / completeExceptionally</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成异步执行，并返回 future 的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> triggered = completeValue(value);</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行不正常的结束，抛出一个异常，而不是一个成功的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">boolean</span> triggered = internalComplete(<span class="keyword">new</span> CompletableFuture.AltResult(ex));</span><br><span class="line">    postComplete();</span><br><span class="line">    <span class="keyword">return</span> triggered;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>我们可以通过 CompletableFuture 来异步获取一组数据，并对数据进行一些转换，类似 RxJava、Scala 的 map、flatMap 操作。</p><h4 id="thenApply-转换结果（map）"><a href="#thenApply-转换结果（map）" class="headerlink" title="thenApply 转换结果（map）"></a>thenApply 转换结果（map）</h4><p>我们可以将操作串联起来，或者将 CompletableFuture 组合起来。它的入参是上一个阶段计算后的结果，返回值是经过转化后结果。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 接受一个 <span class="function"><span class="keyword">Function</span></span>&lt;? super T, ? <span class="keyword">extends</span> U&gt; 参数用来转换 CompletableFuture</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(</span><br><span class="line">        <span class="function"><span class="keyword">Function</span></span>&lt;? super T, ? <span class="keyword">extends</span> U&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(null, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接受一个<span class="function"><span class="keyword">Function</span></span>&lt;? super T,? <span class="keyword">extends</span> U&gt; 参数用来转换CompletableFuture，使用ForkJoinPool</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(</span><br><span class="line">        <span class="function"><span class="keyword">Function</span></span>&lt;? super T, ? <span class="keyword">extends</span> U&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 接受一个<span class="function"><span class="keyword">Function</span></span>&lt;? super T,? <span class="keyword">extends</span> U&gt;参数用来转换CompletableFuture，使用指定的线程池</span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(</span><br><span class="line">        <span class="function"><span class="keyword">Function</span></span>&lt;? super T, ? <span class="keyword">extends</span> U&gt; fn, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thenApply 的功能相当于将 CompletableFuture&lt;T> 转换成 CompletableFuture&lt;U>。</li><li>thenApply 函数的功能是当原来的 CompletableFuture 计算完后，将结果传递给函数 fn，将 fn 的结果作为新的 CompletableFuture 计算结果，这些转换并不是马上执行的，也不会阻塞，而是在前一个 stage 完成后继续执行。</li><li>它们与 handle 方法的区别在于 handle 方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而 thenApply 方法只是用来处理正常值，因此一旦有异常就会抛出。</li></ul><h4 id="thenCompose-非嵌套整合（flatMap）"><a href="#thenCompose-非嵌套整合（flatMap）" class="headerlink" title="thenCompose 非嵌套整合（flatMap）"></a>thenCompose 非嵌套整合（flatMap）</h4><p>thenCompose 可以用于组合多个 CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回 CompletableFuture 类型。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(</span><br><span class="line">        <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> CompletionStage&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回 CompletableFuture 类型。使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(</span><br><span class="line">        <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> CompletionStage&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(asyncPool, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回 CompletableFuture 类型。使用指定的线程池。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(</span><br><span class="line">        <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? <span class="keyword">extends</span> CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="line">        Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thenCompose 可以用于组合多个 CompletableFuture，将前一个结果作为下一个计算的参数，它们之间存在着先后顺序。</li><li>thenapply() 是接受一个 <code>Function&lt;? super T,? extends U&gt;</code> 参数用来转换 CompletableFuture，相当于流的 map 操作，返回的是非 CompletableFuture 类型，它的功能相当于将 CompletableFuture&lt;T> 转换成 CompletableFuture&lt;U>。</li><li>thenCompose() 在异步操作完成的时候对异步操作的结果进行一些操作，并且仍然返回 CompletableFuture 类型，相当于 flatMap，用来连接两个 CompletableFuture。</li></ul><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><h3 id="thenCombine"><a href="#thenCombine" class="headerlink" title="thenCombine"></a>thenCombine</h3><p>thenCombine 方法主要作用：结合两个 CompletionStage 的结果，进行转化后返回。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 fn，用它来组合另外一个 CompletableFuture 的结果。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombine(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? <span class="keyword">extends</span> V&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">biApplyStage</span><span class="params">(<span class="keyword">null</span>, other, fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 fn，用它来组合另外一个 CompletableFuture 的结果。使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? <span class="keyword">extends</span> V&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">biApplyStage</span><span class="params">(asyncPool, other, fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 fn，用它来组合另外一个 CompletableFuture 的结果。使用指定的线程池。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? <span class="keyword">extends</span> V&gt; fn, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> biApplyStage(screenExecutor(executor), other, fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在有 CompletableFuture&lt;T>、CompletableFuture&lt;U> 和一个函数 (T, U) -&gt; V，thenCompose 就是将 CompletableFuture&lt;T> 和 CompletableFuture&lt;U> 变为 CompletableFuture&lt;V>。</li><li>使用 thenCombine() 之后 future1、future2 之间是并行执行的，最后再将结果汇总。</li></ul><h4 id="thenAcceptBoth"><a href="#thenAcceptBoth" class="headerlink" title="thenAcceptBoth"></a>thenAcceptBoth</h4><p>thenAcceptBoth 方法主要作用：结合两个 CompletionStage 的结果，进行消耗，返回CompletableFuture&lt;Void> 类型。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 action，用它来组合另外一个 CompletableFuture 的结果。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;<span class="keyword">Void</span>&gt; thenAcceptBoth(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 action，用它来组合另外一个 CompletableFuture 的结果。使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;<span class="keyword">Void</span>&gt; thenAcceptBothAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(asyncPool, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当两个 CompletableFuture 都正常完成后，执行提供的 action，用它来组合另外一个 CompletableFuture 的结果。使用指定的线程池。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;<span class="keyword">Void</span>&gt; thenAcceptBothAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> U&gt; other,</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> biAcceptStage(screenExecutor(executor), other, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thenAcceptBoth 跟 thenCombine 类似，但是返回 CompletableFuture&lt;Void> 类型。</li><li>thenAcceptBoth 以及相关方法提供了类似的功能，当两个 CompletionStage 都正常完成计算的时候，就会执行提供的 action，它用来组合另外一个异步的结果。</li></ul><h3 id="计算结果完成时的处理"><a href="#计算结果完成时的处理" class="headerlink" title="计算结果完成时的处理"></a>计算结果完成时的处理</h3><p>当 CompletableFuture 完成计算结果后，我们可能需要对结果进行一些处理。</p><h4 id="whenComplete-计算结果完成时的处理"><a href="#whenComplete-计算结果完成时的处理" class="headerlink" title="whenComplete  计算结果完成时的处理"></a>whenComplete  计算结果完成时的处理</h4><p>whenComplete  方法主要作用：当运行完成时，对结果的记录。</p><p>当 CompletableFuture 的计算结果完成，或者抛出异常的时候，有如下四个方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果时对结果进行处理，或者当 CompletableFuture 产生异常的时候对异常进行处理。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; whenComplete(</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniWhenCompleteStage</span><span class="params">(<span class="keyword">null</span>, action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果时对结果进行处理，或者当 CompletableFuture 产生异常的时候对异常进行处理。使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; whenCompleteAsync(</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniWhenCompleteStage</span><span class="params">(asyncPool, action)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果时对结果进行处理，或者当 CompletableFuture 产生异常的时候对异常进行处理。使用指定的线程池。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; whenCompleteAsync(</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; exceptionally(</span><br><span class="line">        Function&lt;Throwable, ? <span class="keyword">extends</span> T&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniExceptionallyStage</span><span class="params">(fn)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到 Action 的类型是 <code>BiConsumer&lt;? super T, ? super Throwable&gt;</code> 它可以处理正常的计算结果，或者异常情况。</li><li>方法不以 Async 结尾，意味着 Action 使用相同的线程执行，而 Async 可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）。</li><li>exceptionally 方法返回一个新的 CompletableFuture，当原始的 CompletableFuture 抛出异常的时候，就会触发这个 CompletableFuture 的计算，调用 function 计算值，也就是这个 exceptionally 方法用来处理异常的情况。</li></ul><h4 id="handle-执行完可以做转换"><a href="#handle-执行完可以做转换" class="headerlink" title="handle 执行完可以做转换"></a>handle 执行完可以做转换</h4><p>handle  方法主要作用：运行完成时，对结果的处理。</p><p>除了上述四个方法之外，一组 handle 方法也可用于处理计算结果。当原先的 CompletableFuture 的值计算完成或者抛出异常的时候，会触发这个 CompletableFuture 对象的计算，结果由 BiFunction 参数计算而得。因此这组方法兼有 whenComplete 和转换的两个功能。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果或者抛出异常的时候，执行提供的 fn</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; handle(</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? <span class="keyword">extends</span> U&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniHandleStage</span><span class="params">(<span class="keyword">null</span>, fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果或者抛出异常的时候，执行提供的 fn，使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? <span class="keyword">extends</span> U&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniHandleStage</span><span class="params">(asyncPool, fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果或者抛出异常的时候，执行提供的 fn，使用指定的线程池。</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(</span><br><span class="line">        BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? <span class="keyword">extends</span> U&gt; fn, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="thenAccept-纯消费结果"><a href="#thenAccept-纯消费结果" class="headerlink" title="thenAccept 纯消费结果"></a>thenAccept 纯消费结果</h4><p>上面的方法是当计算完成的时候，会生成新的计算结果 (thenApply, handle)，或者返回同样的计算结果 whenComplete。我们可以在每个 CompletableFuture 上注册一个操作，该操作会在 CompletableFuture 完成执行后调用它。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果，只对结果执行 Action，而不返回新的计算值。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="built_in">Void</span>&gt; thenAccept(Consumer&lt;? <span class="keyword">super</span> T&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果，只对结果执行 Action，而不返回新的计算值，使用 ForkJoinPool。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="built_in">Void</span>&gt; thenAcceptAsync(Consumer&lt;? <span class="keyword">super</span> T&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(asyncPool, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 CompletableFuture 完成计算结果，只对结果执行 Action，而不返回新的计算值。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="built_in">Void</span>&gt; thenAcceptAsync(Consumer&lt;? <span class="keyword">super</span> T&gt; action,</span><br><span class="line">                                               Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(screenExecutor(executor), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CompletableFuture 通过 thenAccept 方法提供了这一功能，它接收CompletableFuture 执行完毕后的返回值做参数，只对结果执行Action，而不返回新的计算值。</li></ul><h3 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h3><p>Either 表示的是两个 CompletableFuture，当其中任意一个 CompletableFuture 计算完成的时候就会执行。</p><h4 id="acceptEither"><a href="#acceptEither" class="headerlink" title="acceptEither"></a>acceptEither</h4><p>applyToEither 方法主要作用：两个 CompletionStage，谁计算的快，我就用那个 CompletionStage 的结果进行下一步的消耗操作。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当任意一个 CompletableFuture 完成的时候，action 这个消费者就会被执行。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="keyword">Void</span>&gt; acceptEither(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(<span class="keyword">null</span>, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当任意一个 CompletableFuture 完成的时候，action 这个消费者就会被执行。使用 ForkJoinPool</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="keyword">Void</span>&gt; acceptEitherAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action) &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(asyncPool, other, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当任意一个 CompletableFuture 完成的时候，action 这个消费者就会被执行。使用指定的线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;<span class="keyword">Void</span>&gt; acceptEitherAsync(</span><br><span class="line">        CompletionStage&lt;? <span class="keyword">extends</span> T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action,</span><br><span class="line">        Executor executor) &#123;</span><br><span class="line">    <span class="keyword">return</span> orAcceptStage(screenExecutor(executor), other, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="applyToEither"><a href="#applyToEither" class="headerlink" title="applyToEither"></a>applyToEither</h4><p>applyToEither 方法主要作用：两个 CompletionStage，谁计算的快，我就用那个 CompletionStage 的结果进行下一步的转化操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 当任意一个 CompletableFuture 完成的时候，fn 会被执行，它的返回值会当作新的 CompletableFuture<span class="tag">&lt;<span class="name">U</span>&gt;</span> 的计算结果。</span><br><span class="line">public <span class="tag">&lt;<span class="name">U</span>&gt;</span> CompletableFuture<span class="tag">&lt;<span class="name">U</span>&gt;</span> applyToEither(</span><br><span class="line">        CompletionStage<span class="php"><span class="meta">&lt;?</span> extends T&gt; other, <span class="function"><span class="keyword">Function</span>&lt;? <span class="title">super</span> <span class="title">T</span>, <span class="title">U</span>&gt; <span class="title">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">return</span> orApplyStage(<span class="keyword">null</span>, other, fn);</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">// 当任意一个 CompletableFuture 完成的时候，fn 会被执行，它的返回值会当作新的 CompletableFuture&lt;U &gt; 的计算结果。使用 ForkJoinPool</span></span></span><br><span class="line"><span class="php"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(</span></span><br><span class="line"><span class="php">        CompletionStage<span class="meta">&lt;?</span> extends T&gt; other, <span class="function"><span class="keyword">Function</span>&lt;? <span class="title">super</span> <span class="title">T</span>, <span class="title">U</span>&gt; <span class="title">fn</span>) </span>&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">return</span> orApplyStage(asyncPool, other, fn);</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"><span class="php"></span></span><br><span class="line"><span class="php"><span class="comment">// 当任意一个 CompletableFuture 完成的时候，fn 会被执行，它的返回值会当作新的 CompletableFuture&lt;U &gt; 的计算结果。使用指定的线程池</span></span></span><br><span class="line"><span class="php"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(</span></span><br><span class="line"><span class="php">        CompletionStage<span class="meta">&lt;?</span> extends T&gt; other, <span class="function"><span class="keyword">Function</span>&lt;? <span class="title">super</span> <span class="title">T</span>, <span class="title">U</span>&gt; <span class="title">fn</span>,</span></span></span><br><span class="line"><span class="php">        Executor executor) &#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">return</span> orApplyStage(screenExecutor(executor), other, fn);</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>acceptEither 跟 applyToEither 类似，但是返回 CompletableFuture&lt;Void> 类型。</li></ul><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>allOf、anyOf 是 CompletableFuture 的静态方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在所有 Future 对象完成后结束，并返回一个 future</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">andTree</span><span class="params">(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在任何一个 Future 对象结束后结束，并返回一个 future。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">orTree</span><span class="params">(cfs, <span class="number">0</span>, cfs.length - <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>allOf() 方法所返回的 CompletableFuture，并不能组合前面多个 CompletableFuture 的计算结果。</li><li>anyOf 和 acceptEither、applyToEither 的区别在于，后两者只能使用在两个 future 中，而 anyOf 可以使用在多个 future 中。</li></ul><h3 id="CompletableFuture-异常处理"><a href="#CompletableFuture-异常处理" class="headerlink" title="CompletableFuture 异常处理"></a>CompletableFuture 异常处理</h3><p>CompletableFuture 在运行时如果遇到异常，可以使用 get() 并抛出异常进行处理，但这并不是一个最好的方法。CompletableFuture 本身也提供了几种方式来处理异常。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 只有当 CompletableFuture 抛出异常的时候，才会触发这个 exceptionally 的计算，调用 function 计算值。</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; exceptionally(</span><br><span class="line">        Function&lt;Throwable, ? <span class="keyword">extends</span> T&gt; fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniExceptionallyStage</span><span class="params">(fn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以捕获任意阶段的异常。如果没有异常的话，就执行 action</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; whenComplete(</span><br><span class="line">        BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">uniWhenCompleteStage</span><span class="params">(<span class="keyword">null</span>, action)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>exceptionally 方法主要作用在于当运行时出现了异常，可以通过 exceptionally 进行补偿。</li></ul><h2 id="使用-JAVA-CompletableFuture-的-20-例子"><a href="#使用-JAVA-CompletableFuture-的-20-例子" class="headerlink" title="使用 JAVA CompletableFuture 的 20 例子"></a>使用 JAVA CompletableFuture 的 20 例子</h2><h3 id="新建一个完成的-CompletableFuture"><a href="#新建一个完成的-CompletableFuture" class="headerlink" title="新建一个完成的 CompletableFuture"></a>新建一个完成的 CompletableFuture</h3><p>这个简单的示例中创建了一个已经完成的预先设置好结果的 CompletableFuture。通常作为计算的起点阶段。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">completedFutureExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>);</span><br><span class="line">    assertTrue(cf.isDone());</span><br><span class="line">    <span class="comment">// getNow 方法会返回完成后的结果（这里就是 message），如果还未完成，则返回传入的默认值 null</span></span><br><span class="line">    assertEquals(<span class="string">"message"</span>, cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行一个简单的异步-stage"><a href="#运行一个简单的异步-stage" class="headerlink" title="运行一个简单的异步 stage"></a>运行一个简单的异步 stage</h3><p>下面的例子解释了如何创建一个异步运行 Runnable 的 stage。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> runAsyncExample() &#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        assertTrue(Thread.currentThread().isDaemon());</span></span></span><br><span class="line"><span class="function"><span class="params">        randomSleep();</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">assertFalse</span><span class="params">(cf.isDone())</span>;</span></span><br><span class="line"><span class="function">    <span class="title">sleepEnough</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">assertTrue</span><span class="params">(cf.isDone())</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="将方法作用于前一个-Stage"><a href="#将方法作用于前一个-Stage" class="headerlink" title="将方法作用于前一个 Stage"></a>将方法作用于前一个 Stage</h3><p>下面的例子引用了第一个例子中已经完成的 CompletableFuture，它将引用生成的字符串结果并将该字符串大写。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">thenApplyExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApply(s -&gt; &#123;</span><br><span class="line">        assertFalse(Thread.currentThread().isDaemon());</span><br><span class="line">        <span class="function"><span class="keyword">return</span> s.<span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Function 是阻塞的，这意味着只有当大写操作执行完成之后才会执行 getNow() 方法。</li></ul><h3 id="异步的将方法作用于前一个-Stage"><a href="#异步的将方法作用于前一个-Stage" class="headerlink" title="异步的将方法作用于前一个 Stage"></a>异步的将方法作用于前一个 Stage</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">thenApplyAsyncExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; &#123;</span><br><span class="line">        assertTrue(Thread.currentThread().isDaemon());</span><br><span class="line">        randomSleep();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> s.<span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    assertNull(cf.getNow(<span class="keyword">null</span>));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用一个自定义的-Executor-来异步执行该方法"><a href="#使用一个自定义的-Executor-来异步执行该方法" class="headerlink" title="使用一个自定义的 Executor 来异步执行该方法"></a>使用一个自定义的 Executor 来异步执行该方法</h3><p>异步方法的一个好处是可以提供一个 Executor 来执行 CompletableStage。这个例子展示了如何使用一个固定大小的线程池来实现大写操作。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ExecutorService executor = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="type">ThreadFactory</span>() &#123;</span><br><span class="line">    int count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Thread <span class="keyword">new</span><span class="type">Thread</span>(Runnable runnable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Thread</span>(runnable, <span class="string">"custom-executor-"</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void thenApplyAsyncWithExecutorExample() &#123;</span><br><span class="line">    CompletableFuture&lt;<span class="keyword">String</span>&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>).thenApplyAsync(s -&gt; &#123;</span><br><span class="line">        assertTrue(Thread.currentThread().getName().startsWith(<span class="string">"custom-executor-"</span>));</span><br><span class="line">        assertFalse(Thread.currentThread().isDaemon());</span><br><span class="line">        randomSleep();</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;, executor);</span><br><span class="line">    assertNull(cf.getNow(<span class="literal">null</span>));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGE"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费（Consume）前一个-Stage-的结果"><a href="#消费（Consume）前一个-Stage-的结果" class="headerlink" title="消费（Consume）前一个 Stage 的结果"></a>消费（Consume）前一个 Stage 的结果</h3><p>果下一个 Stage 接收了当前 Stage 的结果但是在计算中无需返回值（比如其返回值为 void），那么它将使用方法 thenAccept 并传入一个 Consumer 接口。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> thenAcceptExample() &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="literal">result</span> = new <span class="type">StringBuilder</span>();</span><br><span class="line">    <span class="type">CompletableFuture</span>.completedFuture(<span class="string">"thenAccept message"</span>)</span><br><span class="line">            .thenAccept(<span class="literal">result</span>::append);</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, <span class="literal">result</span>.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Consumer 将会同步执行，所以我们无需在返回的 CompletableFuture 上执行 join 操作。</p><h3 id="异步执行-Comsume"><a href="#异步执行-Comsume" class="headerlink" title="异步执行 Comsume"></a>异步执行 Comsume</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> thenAcceptAsyncExample() &#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture&lt;<span class="keyword">Void</span>&gt; cf = CompletableFuture.completedFuture(<span class="string">"thenAcceptAsync message"</span>)</span><br><span class="line">            .thenAcceptAsync(result::<span class="keyword">append</span>);</span><br><span class="line">    cf.<span class="keyword">join</span>();</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算出现异常时"><a href="#计算出现异常时" class="headerlink" title="计算出现异常时"></a>计算出现异常时</h3><p>为了简洁性，我们还是将一个字符串大写，但是我们会模拟延时进行该操作。我们会使用 thenApplyAsyn(Function, Executor)，第一个参数是大写转化方法，第二个参数是一个延时 executor，它会延时一秒钟再将操作提交给 ForkJoinPool。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> completeExceptionallyExample() &#123;</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>)</span><br><span class="line">            <span class="comment">// JDK9 的新特性，使用 CompletableFuture.delayedExecutor 实现</span></span><br><span class="line">            .thenApplyAsync(<span class="built_in">String</span><span class="type">::toUpperCase</span>, CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; exceptionHandler = cf</span><br><span class="line">            .<span class="keyword">handle</span>((s, th) -&gt; (th != <span class="built_in">null</span>) ? <span class="string">"message upon cancel"</span> : <span class="string">""</span>);</span><br><span class="line">    cf.completeExceptionally(<span class="literal">new</span> RuntimeException(<span class="string">"completed exceptionally"</span>));</span><br><span class="line">    assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</span><br><span class="line">    try &#123;</span><br><span class="line">        cf.<span class="keyword">join</span>();</span><br><span class="line">        <span class="keyword">fail</span>(<span class="string">"Should have thrown an exception"</span>);</span><br><span class="line">    &#125; catch (CompletionException ex) &#123; <span class="comment">// just for testing</span></span><br><span class="line">        assertEquals(<span class="string">"completed exceptionally"</span>, ex.getCause().getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    assertEquals(<span class="string">"message upon cancel"</span>, exceptionHandler.<span class="keyword">join</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：handle 方法返回一个新的 CompletionStage，无论之前的 Stage 是否正常运行完毕。传入的参数包括上一个阶段的结果和抛出异常。</p><h3 id="取消计算"><a href="#取消计算" class="headerlink" title="取消计算"></a>取消计算</h3><p>和计算时异常处理很相似，我们可以通过 Future 接口中的 cancel(boolean mayInterruptIfRunning) 来取消计算。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> cancelExample() &#123;</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; cf = CompletableFuture.completedFuture(<span class="string">"message"</span>)</span><br><span class="line">            .thenApplyAsync(<span class="built_in">String</span><span class="type">::toUpperCase</span>, CompletableFuture.delayedExecutor(<span class="number">1</span>, TimeUnit.SECONDS));</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; cf2 = cf.exceptionally(throwable -&gt; <span class="string">"canceled message"</span>);</span><br><span class="line">    assertTrue(<span class="string">"Was not canceled"</span>, cf.cancel(<span class="literal">true</span>));</span><br><span class="line">    assertTrue(<span class="string">"Was not completed exceptionally"</span>, cf.isCompletedExceptionally());</span><br><span class="line">    assertEquals(<span class="string">"canceled message"</span>, cf2.<span class="keyword">join</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：exceptionally 方法返回一个新的 CompletableFuture，如果出现异常，则为该方法中执行的结果，否则就是正常执行的结果。</p><h3 id="将-Function-作用于两个已完成-Stage-的结果之一"><a href="#将-Function-作用于两个已完成-Stage-的结果之一" class="headerlink" title="将 Function 作用于两个已完成 Stage 的结果之一"></a>将 Function 作用于两个已完成 Stage 的结果之一</h3><p>下面的例子创建了一个 CompletableFuture 对象并将 Function 作用于已完成的两个 Stage 中的任意一个（没有保证哪一个将会传递给 Function）。这两个阶段分别如下：一个将字符串大写，另一个小写。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void applyToEitherExample() &#123;</span><br><span class="line">    <span class="built_in">String</span> original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; cf1 = CompletableFuture.completedFuture(original)</span><br><span class="line">            .thenApplyAsync(s -&gt; delayedUpperCase(s));</span><br><span class="line">    CompletableFuture&lt;<span class="built_in">String</span>&gt; cf2 = cf1.applyToEither(</span><br><span class="line">            CompletableFuture.completedFuture(original)</span><br><span class="line">                    .thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">            s -&gt; s + <span class="string">" from applyToEither"</span>);</span><br><span class="line">    assertTrue(cf2.join().endsWith(<span class="string">" from applyToEither"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费两个阶段的任意一个结果"><a href="#消费两个阶段的任意一个结果" class="headerlink" title="消费两个阶段的任意一个结果"></a>消费两个阶段的任意一个结果</h3><p>和前一个例子类似，将 Function 替换为 Consumer</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void acceptEitherExample() &#123;</span><br><span class="line">    String <span class="keyword">original </span>= <span class="string">"Message"</span><span class="comment">;</span></span><br><span class="line">    StringBuilder result = new StringBuilder()<span class="comment">;</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; cf = CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>           .thenApplyAsync(s -&gt; delayedUpperCase(s))</span><br><span class="line">            .acceptEither(CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>                           .thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">                    s -&gt; result.append(s).append(<span class="string">"acceptEither"</span>))<span class="comment">;</span></span><br><span class="line">    cf.<span class="keyword">join();</span></span><br><span class="line"><span class="keyword"> </span>   assertTrue(<span class="string">"Result was empty"</span>, result.toString().endsWith(<span class="string">"acceptEither"</span>))<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在两个阶段都完成后运行-Runnable"><a href="#在两个阶段都完成后运行-Runnable" class="headerlink" title="在两个阶段都完成后运行 Runnable"></a>在两个阶段都完成后运行 Runnable</h3><p>注意这里的两个 Stage 都是同步运行的，第一个 stage 将字符串转化为大写之后，第二个 stage 将其转化为小写。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> runAfterBothExample() &#123;</span><br><span class="line">    <span class="built_in">String</span> original = <span class="string">"Message"</span>;</span><br><span class="line">    StringBuilder result = <span class="literal">new</span> StringBuilder();</span><br><span class="line">    CompletableFuture.completedFuture(original)</span><br><span class="line">            .thenApply(<span class="built_in">String</span><span class="type">::toUpperCase</span>)</span><br><span class="line">            .runAfterBoth(</span><br><span class="line">                    CompletableFuture.completedFuture(original)</span><br><span class="line">                            .thenApply(<span class="built_in">String</span><span class="type">::toLowerCase</span>),</span><br><span class="line">                    () -&gt; result.append(<span class="string">"done"</span>));</span><br><span class="line">    assertTrue(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用-Biconsumer-接收两个-stage-的结果"><a href="#用-Biconsumer-接收两个-stage-的结果" class="headerlink" title="用 Biconsumer 接收两个 stage 的结果"></a>用 Biconsumer 接收两个 stage 的结果</h3><p>Biconsumer 支持同时对两个 Stage 的结果进行操作。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void thenAcceptBothExample() &#123;</span><br><span class="line">    String <span class="keyword">original </span>= <span class="string">"Message"</span><span class="comment">;</span></span><br><span class="line">    StringBuilder result = new StringBuilder()<span class="comment">;</span></span><br><span class="line">    CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>           .thenApply(String::toUpperCase)</span><br><span class="line">            .thenAcceptBoth(</span><br><span class="line">                    CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>                           .thenApply(String::toLowerCase),</span><br><span class="line">                    (<span class="built_in">s1</span>, <span class="built_in">s2</span>) -&gt; result.append(<span class="built_in">s1</span>).append(<span class="built_in">s2</span>))<span class="comment">;</span></span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, result.toString())<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-Bifunction-同时作用于两个阶段的结果"><a href="#将-Bifunction-同时作用于两个阶段的结果" class="headerlink" title="将 Bifunction 同时作用于两个阶段的结果"></a>将 Bifunction 同时作用于两个阶段的结果</h3><p>如果 CompletableFuture 想要合并两个阶段的结果并且返回值，我们可以使用方法 thenCombine。这里的计算流都是同步的，所以最后的 getNow() 方法会获得最终结果，即大写操作和小写操作的结果的拼接。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void thenCombineExample() &#123;</span><br><span class="line">    String <span class="keyword">original </span>= <span class="string">"Message"</span><span class="comment">;</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>           .thenApply(s -&gt; delayedUpperCase(s))</span><br><span class="line">            .thenCombine(CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>                           .thenApply(s -&gt; delayedLowerCase(s)),</span><br><span class="line">                    (<span class="built_in">s1</span>, <span class="built_in">s2</span>) -&gt; <span class="built_in">s1</span> + <span class="built_in">s2</span>)<span class="comment">;</span></span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.getNow(null))<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步将-Bifunction-同时作用于两个阶段的结果"><a href="#异步将-Bifunction-同时作用于两个阶段的结果" class="headerlink" title="异步将 Bifunction 同时作用于两个阶段的结果"></a>异步将 Bifunction 同时作用于两个阶段的结果</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void thenCombineAsyncExample() &#123;</span><br><span class="line">    String <span class="keyword">original </span>= <span class="string">"Message"</span><span class="comment">;</span></span><br><span class="line">    CompletableFuture&lt;String&gt; cf = CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>           .thenApplyAsync(s -&gt; delayedUpperCase(s))</span><br><span class="line">            .thenCombine(CompletableFuture.completedFuture(<span class="keyword">original)</span></span><br><span class="line"><span class="keyword"> </span>                           .thenApplyAsync(s -&gt; delayedLowerCase(s)),</span><br><span class="line">                    (<span class="built_in">s1</span>, <span class="built_in">s2</span>) -&gt; <span class="built_in">s1</span> + <span class="built_in">s2</span>)<span class="comment">;</span></span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.<span class="keyword">join());</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Compose-CompletableFuture"><a href="#Compose-CompletableFuture" class="headerlink" title="Compose CompletableFuture"></a>Compose CompletableFuture</h3><p>我们可以使用 thenCompose 来完成前两个例子中的操作。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void thenComposeExample() &#123;</span><br><span class="line">    String original = <span class="string">"Message"</span>;</span><br><span class="line">    CompletableFuture cf = CompletableFuture.completedFuture(original)</span><br><span class="line">            .<span class="function"><span class="title">thenApply</span>(s -&gt;</span> delayedUpperCase(s))</span><br><span class="line">            .<span class="function"><span class="title">thenCompose</span>(upper -&gt;</span> CompletableFuture.completedFuture(original)</span><br><span class="line">                    .<span class="function"><span class="title">thenApply</span>(s -&gt;</span> delayedLowerCase(s))</span><br><span class="line">                    .<span class="function"><span class="title">thenApply</span>(s -&gt;</span> upper + s));</span><br><span class="line">    assertEquals(<span class="string">"MESSAGEmessage"</span>, cf.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当多个阶段中有有何一个完成，即新建一个完成阶段"><a href="#当多个阶段中有有何一个完成，即新建一个完成阶段" class="headerlink" title="当多个阶段中有有何一个完成，即新建一个完成阶段"></a>当多个阶段中有有何一个完成，即新建一个完成阶段</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> anyOfExample() &#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;String&gt; messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; futures = messages.stream()</span><br><span class="line">            .map(msg<span class="function"> -&gt;</span> CompletableFuture.completedFuture(msg)</span><br><span class="line">                    .thenApply(s<span class="function"> -&gt;</span> delayedUpperCase(s)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture.anyOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]))</span><br><span class="line">            .whenComplete<span class="function"><span class="params">((res, th) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">if</span> (th == <span class="literal">null</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    assertTrue(isUpperCase((String) res));</span></span></span><br><span class="line"><span class="function"><span class="params">                    result.append(res);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">assertTrue</span><span class="params">(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="当所有的阶段完成，新建一个完成阶段"><a href="#当所有的阶段完成，新建一个完成阶段" class="headerlink" title="当所有的阶段完成，新建一个完成阶段"></a>当所有的阶段完成，新建一个完成阶段</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> allOfExample() &#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;String&gt; messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; futures = messages.stream()</span><br><span class="line">            .map(msg<span class="function"> -&gt;</span> CompletableFuture.completedFuture(msg)</span><br><span class="line">                    .thenApply(s<span class="function"> -&gt;</span> delayedUpperCase(s)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]))</span><br><span class="line">            .whenComplete<span class="function"><span class="params">((v, th) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="literal">null</span>))));</span></span></span><br><span class="line"><span class="function"><span class="params">                result.append(<span class="string">"done"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">assertTrue</span><span class="params">(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="当所有阶段完成以后，新建一个异步完成阶段"><a href="#当所有阶段完成以后，新建一个异步完成阶段" class="headerlink" title="当所有阶段完成以后，新建一个异步完成阶段"></a>当所有阶段完成以后，新建一个异步完成阶段</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static <span class="literal">void</span> allOfAsyncExample() &#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    List&lt;String&gt; messages = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; futures = messages.stream()</span><br><span class="line">            .map(msg<span class="function"> -&gt;</span> CompletableFuture.completedFuture(msg)</span><br><span class="line">                    .thenApplyAsync(s<span class="function"> -&gt;</span> delayedUpperCase(s)))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> CompletableFuture[<span class="number">0</span>]))</span><br><span class="line">            .whenComplete<span class="function"><span class="params">((v, th) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                futures.forEach(cf -&gt; assertTrue(isUpperCase(cf.getNow(<span class="literal">null</span>))));</span></span></span><br><span class="line"><span class="function"><span class="params">                result.append(<span class="string">"done"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">    <span class="title">allOf</span>.<span class="title">join</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    <span class="title">assertTrue</span><span class="params">(<span class="string">"Result was empty"</span>, result.length() &gt; <span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="真实场景"><a href="#真实场景" class="headerlink" title="真实场景"></a>真实场景</h3><p>下面展示了一个实践 CompletableFuture 的场景：</p><p>1、先通过调用 cars() 方法异步获得 Car 列表。它将会返回一个 CompletionStage&lt;List&lt;Car>&gt;。cars() 方法应当使用一个远程的 REST 端点来实现。<br>2、我们将该 Stage 和另一个 Stage 组合，另一个 Stage 会通过调用 rating(manufactureId) 来异步获取每辆车的评分。<br>3、当所有的 Car 对象都填入评分后，我们调用 allOf() 来进入最终 Stage，它将在这两个阶段完成后执行<br>4、 在最终 Stage 上使用 whenComplete()，打印出车辆的评分。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cars()返回一个汽车列表</span></span><br><span class="line">cars().thenCompose(cars -&gt; &#123;</span><br><span class="line"><span class="comment">// 迭代所有汽车实体</span></span><br><span class="line">    List&lt;CompletionStage&gt; updatedCars = cars.stream()</span><br><span class="line">    <span class="comment">// 为每个汽车打分</span></span><br><span class="line">            .map(car -&gt; rating(car.manufacturerId).thenApply(r -&gt; &#123;</span><br><span class="line">                car.setRating(r);</span><br><span class="line">                <span class="keyword">return</span> car;</span><br><span class="line">            &#125;)).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>());</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当所有分数打完，迭代所有汽车</span></span><br><span class="line">    CompletableFuture done = CompletableFuture</span><br><span class="line">            .allOf(updatedCars.toArray(<span class="keyword">new</span> CompletableFuture[updatedCars.<span class="keyword">size</span>()]));</span><br><span class="line">    <span class="comment">// 返回所有汽车得分</span></span><br><span class="line">    <span class="keyword">return</span> done.thenApply(v -&gt; updatedCars.stream().map(CompletionStage::toCompletableFuture)</span><br><span class="line">            .map(CompletableFuture::<span class="keyword">join</span>).<span class="keyword">collect</span>(Collectors.<span class="keyword">toList</span>()));</span><br><span class="line">&#125;).whenComplete((cars, th) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (th == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cars.forEach(System.out::<span class="keyword">println</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(th);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).toCompletableFuture().<span class="keyword">join</span>();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 8 提供了一种函数风格的异步和事件驱动编程模型 CompletableFuture，它不会造成堵塞。CompletableFuture 背后依靠的是 fork/join 框架来启动新的线程实现异步与并发。当然，我们也能通过指定线程池来做这些事情。</p><p>CompletableFuture 特别是对微服务架构而言，会有很大的作为。举一个具体的场景，电商的商品页面可能会涉及到商品详情服务、商品评论服务、相关商品推荐服务等等。获取商品的信息时，需要调用多个服务来处理这一个请求并返回结果。这里可能会涉及到并发编程，我们完全可以使用 Java 8 的 CompletableFuture 或者 RxJava 来实现。事实证明，只有当每个操作很复杂需要花费相对很长的时间（比如，调用多个其它的系统的接口；比如，商品详情页面这种需要从多个系统中查数据显示）的时候用 CompletableFuture 才合适，不然区别真的不大，还不如顺序同步执行。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://segmentfault.com/a/1190000013452165" target="_blank" rel="noopener">猫头鹰的深夜翻译：使用JAVA CompletableFuture的20例子</a><br>[2]. <a href="https://www.jianshu.com/p/11327ad1d645" target="_blank" rel="noopener">Java8学习笔记之CompletableFuture组合式异步编程</a></p><hr><h2 id="Java8-那些事儿系列"><a href="#Java8-那些事儿系列" class="headerlink" title="Java8 那些事儿系列"></a>Java8 那些事儿系列</h2><ul><li><a href="8cef11db.html">Java8 那些事儿（一）：Stream 函数式编程</a></li><li><a href="8eb6feba.html">Java8 那些事儿（二）：Optional 类解决空指针异常</a></li><li><a href="d66032e3.html">Java8 那些事儿（三）：Date/Time API(JSR 310)</a></li><li><a href="139a123e.html">Java8 那些事儿（四）：增强的 Map 集合</a></li><li><a href="43810ae.html">Java8 那些事儿（五）：函数式接口</a></li><li><a href="a3263046.html">Java8 那些事儿（六）：从 CompletableFuture 到异步编程</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JDK 5 引入了 Future 模式。Future 接口是 Java 多线程 Future 模式的实现，在 java.util.concurrent 包中，可以来进行异步计算。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？如 Netty、Guava 分别扩展了 Java 的 Future 接口，方便异步编程。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，自 JDK8 开始，吸收了 Guava 的设计思想，加入了 Future 的诸多扩展功能形成了 CompletableFuture，让 Java 拥有了完整的非阻塞编程模型。CompletableFuture 它提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力。CompletableFuture 能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。&lt;/p&gt;
&lt;p&gt;CompletableFuture 弥补了 Future 模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过 thenAccept、thenApply、thenCompose 等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.maoning.vip/categories/Java/"/>
    
    
      <category term="Java8" scheme="https://blog.maoning.vip/tags/Java8/"/>
    
      <category term="CompletableFuture" scheme="https://blog.maoning.vip/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>了不起的消息队列（三）：致敬匠心，Kafka</title>
    <link href="https://blog.maoning.vip/archives/5d3d79c7.html"/>
    <id>https://blog.maoning.vip/archives/5d3d79c7.html</id>
    <published>2020-03-03T08:50:50.000Z</published>
    <updated>2020-07-03T09:02:10.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在本系列的前一篇博文中，笔者对 RabbitMQ 基本框架、概念、通信过程等基础原理，RabbitMQ 安装教程，RabbitMQ 在项目中实际应用场景等进行了详细的讲解。经过上一篇博客介绍，相信大家对 RabbitMQ 已经有了一个大致了解。Kafka 是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 Zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p><p>本文意在介绍 Kafka 的基本原理，包括 Kafka 基本概念、通信过程等，介绍一下 Kafka 安装教程，最后介绍一下 Kafka 在项目中实际应用场景。</p><a id="more"></a><h2 id="Kafka-介绍"><a href="#Kafka-介绍" class="headerlink" title="Kafka 介绍"></a>Kafka 介绍</h2><p>Kafka 是一个消息系统，原本开发自 LinkedIn，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础。现在它已被多家不同类型的公司 作为多种类型的数据管道和消息系统使用。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>如下图所示，一个典型的 kafka 集群中包含若干 producer（可以是 web 前端产生的 page view，或者是服务器日志，系统 CPU、memory 等），若干 broker（Kafka 支持水平扩展，一般 broker 数量越多，集群吞吐率越高），若干 consumer group，以及一个 Zookeeper 集群。Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 consumer group 发生变化时进行 rebalance。producer 使用 push 模式将消息发布到 broker，consumer 使用 pull 模式从 broker 订阅并消费消息。 　</p><p><img src="/media/15898787033263/WeChat%20Screenshot_20190325215237.png" alt="Kafka 相关概念"></p><ul><li><strong>Producer：</strong> 生产者，消息的产生者，负责发布消息到 Kafka Broker。</li><li><strong>Broker：</strong>经纪人，Kafka 集群包含一个或多个服务器，这种服务器被称为 Broker。如果某 topic 有 N 个 partition，集群有 N 个 broker，那么每个 broker 存储该 topic 的一个 partition；如果某 topic 有 N 个 partition，集群有 (N+M) 个 broker，那么其中有 N 个 broker 存储该 topic 的一个 partition，剩下的 M 个 broker 不存储该 topic 的 partition 数据；如果某 topic 有 N 个 partition，集群中 broker 数目少于 N 个，那么一个 broker 存储该 topic 的一个或多个 partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致 Kafka 集群数据不均衡。</li><li><strong>Topic：</strong> 消息的主题，每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（物理上不同 Topic 的消息分开存储，逻辑上一个 Topic 的消息虽然保存于一个或多个 broker 上但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）</li><li><strong>Partition：</strong>topic 的分区，每个 topic 可以有多个分区，分区的作用是做负载，提高 kafka 的吞吐量。parition 是物理上的概念，每个 topic 包含一个或多个 partition，创建 topic 时可指定 parition 数量。每个 partition 对应于一个文件夹，该文件夹下存储该 partition 的数据和索引文件。</li><li><strong>Replication：</strong>复制，每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为 Leader。在 kafka 中默认副本的最大数量是 10 个，且副本的数量不能大于 Broker 的数量，follower 和 leader 绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本（包括自己）。</li><li><strong>Consumer：</strong>消费者，即消息的消费方，是消息的出口。每个 consumer 属于一个特定的 consumer group。使用 consumer high level API 时，同一 topic 的一条消息只能被同一个 consumer group 内的一个 consumer 消费，但多个 consumer group 可同时消费这一消息。</li><li><strong>Consumer Group：</strong>消费组，每个消费者都属于一个特定的 Consumer Group，可通过 group.id 配置项指定，若不指定 group name 则默认为 test-consumer-group。我们可以将多个消费组组成一个消费者组，在 kafka 的设计中同一个分区的数据只能被消费者组中的某一个消费者消费，同一个消费者组的消费者可以消费同一个 topic 的不同分区的数据。</li><li><strong>Zookeeper：</strong>kafka 集群依赖 Zookeeper 来保存集群的的元信息，来保证系统的可用性。Kafka 利用 Zookeeper 保存相应的元数据信息，包括：Broker 信息，Kafka 集群信息，旧版消费者信息以及消费偏移量信息，主题信息，分区状态信息，分区副本分片方案信息，动态配置信息，等等。</li></ul><h3 id="生产端设计"><a href="#生产端设计" class="headerlink" title="生产端设计"></a>生产端设计</h3><p>生产者发送消息流程：</p><ul><li>新建 ProducerRecord 对象，包含目标主题和要发送的内容，也可以指定键或分区</li><li>如果配置了拦截器，可用对发送的消息进行可定制化的拦截或更改</li><li>发送 ProducerRecord 对象时，生产者要把键和值对象序列化成字节数组，这样它们才能在网络上传输</li><li>数据被传给分区器，如果 ProducerRecord 对象中指定了分区，那么分区器就不会再做任何事情，直接把指定的分区返回；如果没有指定分区，那么分区器会根据 ProducerRecord 对象的键来选择一个分区；选择好分区后，生产者就知道该往哪个主题和分区发送这条记录了。</li><li>这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上，有一个独立的 Sender 线程负责把这些记录批次发送到相应的 broker 上</li><li>服务器在收到这些消息时会返回一个相应，如果消息成功写入 kafka，就返回一个 RecordMetaData 对象，该对象包含了 Topic 信息、Patition 信息、消息在 Partition 中的 Offset 信息；如果写入失败，则会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息</li><li>Kafka 的顺序保证。Kafka 保证同一个 partition 中的消息是有序的，即如果生产者按照一定的顺序发送消息，broker 就会按照这个顺序把他们写入 partition，消费者也会按照相同的顺序读取他们</li></ul><p><img src="/media/15898787033263/619336-20180428120740241-1965646945.png" alt="生产者发送消息流程"></p><h4 id="同步发送消息到-Kafka"><a href="#同步发送消息到-Kafka" class="headerlink" title="同步发送消息到 Kafka"></a>同步发送消息到 Kafka</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties() &#123;&#123;</span><br><span class="line">    <span class="comment">/* 定义kakfa服务的地址 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">/* 消息确认类型 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</span><br><span class="line">    <span class="comment">/* 生产端消息发送失败时的重试次数 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.RETRIES_CONFIG, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* batch 批次消息大小 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">    <span class="comment">/* 用来控制 batch 最大的空闲时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 生产端消息缓冲池或缓冲区的大小 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line">    <span class="comment">/* 最大阻塞时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.MAX_BLOCK_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">/* key的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">    <span class="comment">/* value的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">KafkaProducer&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"><span class="comment">// Topic Key Value</span></span><br><span class="line">ProducerRecord&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line">    Future future = producer.send(record);</span><br><span class="line">    future.<span class="built_in">get</span>();</span><br><span class="line">&#125; <span class="built_in">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 连接错误、No Leader错误都可以通过重试解决；消息太大这类错误kafkaProducer不会进行任何重试，直接抛出异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//all done  close</span></span><br><span class="line">producer.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><p>注意：Producer 有两种错误类型。一种是可以通过再次发送消息解决的错误，比如连接出现问题，需要重新连接；或者是 “no leader” 错误，通过等待一会 Leader 重新选举完就可以继续。Producer 可以配置自动重试。另一种是通过重试无法处理的错误，比如消息过大，这种情况下，Producer 就不会重试，而是直接抛出异常。</p><h4 id="异步发送消息到-Kafka"><a href="#异步发送消息到-Kafka" class="headerlink" title="异步发送消息到 Kafka"></a>异步发送消息到 Kafka</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties() &#123;&#123;</span><br><span class="line">    <span class="comment">/* 定义kakfa服务的地址 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">/* 消息确认类型 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.ACKS_CONFIG, <span class="string">"all"</span>);</span><br><span class="line">    <span class="comment">/* 生产端消息发送失败时的重试次数 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.RETRIES_CONFIG, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* batch 批次消息大小 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">    <span class="comment">/* 用来控制 batch 最大的空闲时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.LINGER_MS_CONFIG, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 生产端消息缓冲池或缓冲区的大小 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br><span class="line">    <span class="comment">/* 最大阻塞时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.MAX_BLOCK_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">/* key的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">    <span class="comment">/* value的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">KafkaProducer&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"><span class="comment">// Topic Key Value</span></span><br><span class="line">ProducerRecord&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">"CustomCountry"</span>, <span class="string">"Precision Products"</span>, <span class="string">"France"</span>);</span><br><span class="line">producer.send(record, (metadata, exception) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 如果Kafka返回一个错误，onCompletion方法抛出一个non null异常</span></span><br><span class="line">    <span class="built_in">if</span> (exception != null) &#123;</span><br><span class="line">        <span class="comment">// 发送消息时，传递一个回调对象，该回调对象必须实现org.apahce.kafka.clients.producer.Callback接口</span></span><br><span class="line">        <span class="built_in">if</span> (metadata != null) &#123;</span><br><span class="line">            log.error(<span class="string">"kafka write exception.topic - &#123;&#125;[&#123;&#125;]"</span>, metadata.topic(), metadata.partition(), exception);</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"kafka write exception.topic"</span>, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//all done  close</span></span><br><span class="line">producer.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h4 id="生产端核心参数"><a href="#生产端核心参数" class="headerlink" title="生产端核心参数"></a>生产端核心参数</h4><p>（1）acks：acks 参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数消息丢失的可能性有重要影响。只有当 leader 确认已成功写入消息的副本数后，才会给 Producer 发送响应，此时消息才可以认为 “已提交”。该参数影响着消息的可靠性以及生产端 的 吞吐量，并且两者往往相向而驰，通常消息可靠性越高则生产端的吞吐量越低。</p><ul><li>acks=0，表示生产端发送消息后立即返回，不等待 broker 端的响应结果。通常此时生产端吞吐量最高，消息发送的可靠性最低。</li><li>acks=1，表示 leader 副本成功写入就会响应 Producer，而无需等待 ISR<sup>[1]</sup> （同步副本）集合中的其他副本写入成功。这种方案提供了 适当的持久性，保证了一定的吞吐量。默认值即是 1。</li><li>acks=all 或 - 1，表示不仅要等 leader 副本成功 写入 ，还要求 ISR 中的其他副本成功写入，才会响应 Producer。这种方案提供了最高的持久性，但也提供了最差的吞吐量。</li></ul><p>调优建议：建议根据实际情况设置，如果要严格保证消息不丢失，请设置为 all 或 - 1；如果允许存在丢失，建议设置为 1；一般不建议设为 0，除非无所谓消息丢不丢失。</p><p>（2）batch.size：发送到缓冲区中的消息会被分为一个一个的 batch，分批次的发送到 broker 端，这个参数就表示 batch 批次大小，默认值为 16384，即 16KB。因此减小 batch 大小有利于降低消息延时，增加 batch 大小有利于提升吞吐量。</p><p>调优建议：通常合理调大该参数值，能够显著提升生产端吞吐量，比如可以调整到 32KB，调大也意味着消息会有相对较大的延时。</p><p>（3）buffer.memory：表示生产端消息缓冲池或缓冲区的大小，默认值为 33554432，即 32M。这个参数基本可以认为是 Producer 程序所使用的内存大小。当前版本中，如果生产消息的速度过快导致 buffer 满了的时候，将阻塞 max.block.ms（默认 60000 即 60s）配置的时间，超时将会抛 TimeoutException 异常。在 Kafka 0.9.0 及之前版本，建 议设置另一个参数 block.on.buffer.full 为 true，该参数表示当 buffer 填满时 Producer 处于阻塞状态并停止接收新消息而不是抛异常。</p><p>调优建议：通常我们应尽量保证生产端整体吞吐量，建议适当调大该参数，也意味着生产客户端会占用更多的内存。也可以选择不调整 。</p><p>（4）compression.type：表示生产端是否对消息进行压缩，默认值为 none，即不压缩消息。压缩可以显著减少网络 IO 传输、磁盘 IO 以及磁盘空间，从而提升整体吞吐量，但也是以 牺牲 CPU 开销为代价的 。当前 Kafka 支持 4 种压缩方式，分别是 gzip、snappy、 lz4 及 zstd（Kafka 2.1.0 开始支持） 。</p><p>调优建议：出于提升吞吐量的考虑，建议在生产端对消息进行压缩。对于 Kafka 而已，综合考虑吞吐量与压缩比，建议选择 lz4 压缩。如果追求最高的压缩比则推荐 zstd 压缩 。</p><p>（5）max.request.size：这个参数比较重要，表示生产端能够发送的 最大 消息大小，默认值为 1048576，即 1M。</p><p>调优建议：一般而言，这个配置有点小，为了避免因消息过大导致发送失败，建议适当调大，比如调到 10485760 即 10M。</p><p>（6）retries：表示生产端消息发送失败时的重试次数，默认值为 0，表示不进行重试。这个参数一般是为了解决因瞬时故障导致的消息发送失败， 比如网络抖动、leader 换主，其中瞬时的 leader 重选举是比较常见的 。因此这个参数的设置显得非常重要。另外为了避免频繁重试的影响，两次重试之间都会停顿一段时间，受参数 retry.backoff.ms，默认为 100ms，通常可以不调整。</p><p>调优建议：这里要尽量避免消息丢失，建议设置为一个大于 0 的值，比如 3 或者更大值 。</p><p>（7）linger.ms：用来控制 batch 最大的空闲时间，超过该时间的 batch 也会被发送到 broker 端。这实际上是一种权衡，即吞吐量与延时之间的权衡。默认值为 0，表示消息需要被立即发送，无需关系 batch 是否被填满。</p><p>调优建议：通常为了减少请求次数、提升整体吞吐量，建议设置一个大于 0 的值，比如设置为 100，此时会在负载低的情况下带来 100ms 的延时 。</p><p>（8）request.timeout.ms：这个参数表示生产端发送请求后等待 broker 端响应的最长时间，默认值为 30000，即 30s，超时生产端可能会选择重试（如果配置了 retries）。</p><p>调优建议：该参数默认值一般够用了。如果生产端负载很大，可以适当调大以避免超时，比如可以调到 60000。</p><p>（9）max.in.flight.requests.per.connection：表示生产端与 broker 之间的每个连接最多缓存的请求数，默认值为 5，即每个连接最多可以缓存 5 个未响应的请求，该参数指定了生产者在收到服务器响应之前可以发送多少个消息。这个参数通常用来解决分区乱序的问题。</p><p>调优建议：为了避免消息乱序问题，建议将该参数设置为 1，表示生产端在某个 broker 响应之前将无法再向该 broker 发送消息请求，这能够有效避免同一分区下的消息乱序问题。</p><p>（10）interceptor.classes：用作拦截器的类的列表。通过实现 ProducerInterceptor 接口，您可以在生产者发布到 Kafka 集群之前拦截（并可能会改变）生产者收到的记录。默认情况下，没有拦截器，可自定义拦截器。</p><p>（11）partitioner.class：实现 Partitioner 接口的分区器类。默认使用 DefaultPartitioner 来进行分区。</p><h3 id="消费端设计"><a href="#消费端设计" class="headerlink" title="消费端设计"></a>消费端设计</h3><p>消费者消费消息流程：</p><ul><li>消息由生产者发布到 kafka 集群后，会被消费者消费。消息的消费模型有两种，推送模型（push）和拉取模型（pull）。</li><li>kafka 采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序拉取每个分区的消息。消费者拉取的最大上限通过最高水位（watermark）控制，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的。<br>这种由消费者控制偏移量的优点是：消费者可以按照任意的顺序消费消息。比如，消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费。在一些消息系统中，消息代理会在消息被消费之后立即删除消息。如果有不同类型的消费者订阅同一个主题，消息代理可能需要冗余地存储同一消息；或者等所有消费者都消费完才删除，这就需要消息代理跟踪每个消费者的消费状态，这种设计很大程度上限制了消息系统的整体吞吐量和处理延迟。Kafka 的做法是生产者发布的所有消息会一致保存在 Kafka 集群中，不管消息有没有被消费。用户可以通过设置保留时间来清理过期的数据，比如，设置保留策略为两天。那么，在消息发布之后，它可以被不同的消费者消费，在两天之后，过期的消息就会自动清理掉。</li><li>消费者是以 consumer group 消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个 topic。每个分区在同一时间只能由 group 中的一个消费者读取，但是多个 group 可以同时消费这个 partition。某个消费者读取某个分区，也可以叫做某个消费者是某个分区的拥有者。</li><li>在这种情况下，消费者可以通过水平扩展的方式同时读取大量的消息。另外，如果一个消费者失败了，那么其他的 group 成员会自动负载均衡读取之前失败的消费者读取的分区。</li><li>再均衡期间，消费者无法读取消息，造成整个 consumer group 一小段时间的不可用。另外，当分区被重新分配给另一个消费者时，当前的读取状态会丢失。消费者通过向作为组协调器（Group Coordinator）的 broker（不同的组可以有不同的协调器）发送心跳来维持和群组以及分区的关系。心跳表明消费者在读取分区里的消息。消费者会在轮询消息或提交偏移量（offset）时发送心跳。如果消费者停止发送心跳的时间足够长，会话就会过期，组协调器认为消费者已经死亡，会触发一次再均衡。（在 Kafka 0.10.1 的版本中，对心跳行为进行了修改，由一个独立的线程负责心跳）</li></ul><h4 id="自动确认-Offset"><a href="#自动确认-Offset" class="headerlink" title="自动确认 Offset"></a>自动确认 Offset</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties() &#123;&#123;</span><br><span class="line">    <span class="comment">/* 定义kakfa服务的地址，不需要将所有broker指定上 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">/* 制定consumer group */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">/* 开启自动确认选项 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line">    <span class="comment">/* 自动提交时间间隔 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">"5000"</span>);</span><br><span class="line">    <span class="comment">/* 消费者与服务器断开连接的最大时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="string">"30000"</span>);</span><br><span class="line">    <span class="comment">/* key的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    <span class="comment">/* value的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义consumer */</span></span><br><span class="line">KafkaConsumer&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"><span class="comment">/* 消费者订阅的topic, 可同时订阅多个 */</span></span><br><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">"CustomCountry"</span>));</span><br><span class="line"><span class="comment">/* subscribe() 也可以接收一个正则表达式，匹配多个主题：支持正则表达式，订阅所有与test相关的Topic */</span></span><br><span class="line"><span class="comment">//consumer.subscribe("test.*");</span></span><br><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line">    <span class="comment">/* 读取数据，读取超时时间为100ms */</span></span><br><span class="line">    <span class="built_in">while</span> (true) &#123;</span><br><span class="line">        ConsumerRecords&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="built_in">for</span> (ConsumerRecord&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; record : records) &#123;</span><br><span class="line">            log.info(<span class="string">"offset = &#123;&#125;, key = &#123;&#125;, value = &#123;&#125;"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="comment">// 关闭消费者,网络连接和 socket 也会随之关闭，并立即触发一次再均衡</span></span><br><span class="line">    consumer.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="手工控制-Offset"><a href="#手工控制-Offset" class="headerlink" title="手工控制 Offset"></a>手工控制 Offset</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties() &#123;&#123;</span><br><span class="line">    <span class="comment">/* 定义kakfa服务的地址，不需要将所有broker指定上 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"localhost:9092"</span>);</span><br><span class="line">    <span class="comment">/* 制定consumer group */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">"test"</span>);</span><br><span class="line">    <span class="comment">/* 关闭自动确认选项 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);</span><br><span class="line">    <span class="comment">/* 消费者与服务器断开连接的最大时间 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="string">"30000"</span>);</span><br><span class="line">    <span class="comment">/* key的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">    <span class="comment">/* value的序列化类 */</span></span><br><span class="line">    <span class="built_in">put</span>(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义consumer */</span></span><br><span class="line">KafkaConsumer&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(properties);</span><br><span class="line"><span class="comment">/* 消费者订阅的topic, 可同时订阅多个 */</span></span><br><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">"CustomCountry"</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">try</span> &#123;</span><br><span class="line">    <span class="comment">/* 读取数据，读取超时时间为100ms */</span></span><br><span class="line">    <span class="built_in">while</span> (true) &#123;</span><br><span class="line">        ConsumerRecords&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="built_in">for</span> (ConsumerRecord&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; record : records) &#123;</span><br><span class="line">            log.info(<span class="string">"offset = &#123;&#125;, key = &#123;&#125;, value = &#123;&#125;"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理完当前批次的消息，在轮询更多的消息之前，调用commitSync方法提交当前批次最新的消息</span></span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125; <span class="built_in">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">            <span class="comment">// 只要没有发生不可恢复的错误，commitSync方法会一直尝试直至提交成功。如果提交失败，我们也只能把异常记录到错误日志里</span></span><br><span class="line">            log.error(<span class="string">"commit failed"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    <span class="comment">// 关闭消费者,网络连接和 socket 也会随之关闭，并立即触发一次再均衡</span></span><br><span class="line">    consumer.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：消费者为什么要提交偏移量？当消费者崩溃或者有新的消费者加入，那么就会触发再均衡（rebalance），完成再均衡后，每个消费者可能会分配到新的分区，而不是之前处理那个，为了能够继续之前的工作，消费者需要读取每个 partition 最后一次提交的偏移量，然后从偏移量指定的地方继续处理。</p><h4 id="消费端核心参数"><a href="#消费端核心参数" class="headerlink" title="消费端核心参数"></a>消费端核心参数</h4><p>Kafka 与消费者相关的配置大部分参数都有合理的默认值，一般不需要修改，不过有一些参数与消费者的性能和可用性有很大关系。</p><p>（1）fetch.min.bytes：指定消费者从服务器获取记录的最小字节数。服务器在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes，那么会等到有足够的可用数据时才返回给消费者。</p><p>调优建议：合理的设置可以降低消费者和 broker 的工作负载，在 Topic 消息生产不活跃时，减少处理消息次数。如果没有很多可用数据，但消费者的 CPU 使用率却很高，需要调高该属性的值。如果消费者的数量比较多，调高该属性的值也可以降低 broker 的工作负载。</p><p>（2）fetch.max.wait.ms：指定在 broker 中的等待时间，默认是 500ms。如果没有足够的数据流入 Kafka，消费者获取的数据量的也没有达到 fetch.min.bytes，最终导致 500ms 的延迟。</p><p>调优建议：如果要降低潜在的延迟（提高 SLA），可以调低该属性的值。fetch.max.wait.ms 和 fetch.min.bytes 有一个满足条件就会返回数据。</p><p>（3）max.parition.fetch.bytes：指定了服务器从每个分区里返回给消费者的最大字节数，默认值是 1MB。也就是说 KafkaConsumer#poll() 方法从每个分区里返回的记录最多不超过 max.parition.fetch.bytes 指定的字节。</p><p>调优建议：如果一个主题有 20 个分区和 5 个消费者（同一个组内），那么每个消费者需要至少 4MB 的可用内存（每个消费者读取 4 个分区）来接收记录。如果组内有消费者发生崩溃，剩下的消费者需要处理更多的分区。max.parition.fetch.bytes 必须比 broker 能够接收的最大消息的字节数（max.message.size）大，否则消费者可能无法读取这些消息，导致消费者一直重试。</p><p>（4）session.timeout.ms：指定了消费者与服务器断开连接的最大时间，默认是 3s。如果消费者没有在指定的时间内发送心跳给 GroupCoordinator，就被认为已经死亡，会触发再均衡，把它的分区分配给其他消费者。</p><p>调优建议：该属性与 heartbeat.interval.ms 紧密相关，heartbeat.interval.ms 指定了 poll() 方法向协调器发送心跳的频率，session.timeout.ms 指定了消费者最长多久不发送心跳。所以，一般需要同时修改这两个属性，heartbeat.interval.ms 必须比 session.timeout.ms 小，一般是 session.timeout.ms 的三分之一，如果 session.timeout.ms 是 3s，那么 heartbeat.interval.ms 应该是 1s。</p><p>（5）auto.offset.reset：指定了消费者在读取一个没有偏移量（offset）的分区或者偏移量无效的情况下（因消费者长时间失效，包含偏移量的记录已经过时井被删除）该作何处理，默认值是 latest，表示在 offset 无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）。</p><p>调优建议：另一个值是 earliest，消费者将从起始位置读取分区的记录。</p><p>（6）enable.auto.commit：指定了消费者是否自动提交偏移量，默认值是 true，自动提交。</p><p>调优建议：设为 false 可以程序自己控制何时提交偏移量。如果设为 true，需要通过配置 auto.commit.interval.ms 属性来控制提交的频率。</p><p>（7）partition.assignment.strategy：分区分配给组内消费者的策略，根据给定的消费者和 Topic，决定哪些分区应该被分配给哪个消费者。</p><p>调优建议：Kafka 有两个默认的分配策略。Range，把 Topic 的若干个连续的分区分配给消费者；RoundRobin，把所有分区逐个分配给消费者。默认值是 org.apache.kafka.clients.consumer.RangeAssignor，这个类实现了 Range 策略，org.apache.kafka.clients.consumer.RoundRobinAssignor 是 RoundRobin 策略的实现类。还可以使用自定义策略，属性值设为自定义类的名字。</p><p>（8）client.id：broker 用来标识从客户端发送过来的消息，可以是任意字符串，通常被用在日志、度量指标和配额中。</p><p>（9）max.poll.records：用于控制单次调用 call() 方法能够返回的记录数量，帮助控制在轮询里需要处理的数据量。</p><p>（10）receive.buffer.bytes：指定了 TCP socket 接收数据包的缓冲区大小。如果设为 - 1 就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p><p>（11）send.buffer.bytes：指定了 TCP socket 发送数据包的缓冲区大小。如果设为 - 1 就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p><h2 id="Kafka-安装以及环境配置"><a href="#Kafka-安装以及环境配置" class="headerlink" title="Kafka 安装以及环境配置"></a>Kafka 安装以及环境配置</h2><p>本文统一使用软件包管理器的方式安装 Kafka，减少环境变量的配置，更加方便快捷。</p><h3 id="Linux-安装-Kafka"><a href="#Linux-安装-Kafka" class="headerlink" title="Linux 安装 Kafka"></a>Linux 安装 Kafka</h3><p>从 <a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">Kafka 官网下载</a> Kafka 安装包，解压安装，或直接使用命令下载。Kafka 依赖 ZooKeeper，从 <a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="noopener">ZooKeeper 官网下载</a> ZooKeeper 安装包，解压安装，或直接使用命令下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 下载 kafka</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入下载目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，kafka_2.12-2.5.0.tgz 版本是已经编译好的版本，解压就能使用。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget https://mirror.bit.edu.cn/apache/kafka/2.5.0/kafka_2.12-2.5.0.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar -xzvf kafka_2.12-2.5.0.tgz</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移动到安装目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv kafka_2.12-2.5.0 /usr/<span class="built_in">local</span>/kafka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2. 配置 kafka</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入配置目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/kafka/config</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑修改相应的参数 [包括 broker.id、port、host.name、log.dirs、zookeeper.connect 等，小编这里统一设置默认]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi server.properties</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存退出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wq!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 3. 启动 kafka</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 kafka 目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/kafka</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 zookeeper, 启动 kafka 自带的 zookeeper（若不用自带 zk 可不执行此句）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 kafka</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bin/kafka-server-start.sh -daemon config/server.properties</span></span><br></pre></td></tr></table></figure><p>Kafka 是使用 Zookeeper 来保存集群元数据信息和消费者信息。虽然 Kafka 发行版已经自带了 Zookeeper，可以通过脚本直接启动，但仍然建议安装一个完整版的 Zookeeper。</p><h3 id="Mac-安装-Kafka"><a href="#Mac-安装-Kafka" class="headerlink" title="Mac 安装 Kafka"></a>Mac 安装 Kafka</h3><p>Mac 中使用 brew 安装 Kafka 的方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 使用 Kafka 安装，由于 Kafka 依赖了 Zookeeper，所以在下载的时候会自动下载。</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install kafka</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2. 配置 kafka</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入配置目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/etc/kafka/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑修改相应的参数 [包括 broker.id、port、host.name、log.dirs、zookeeper.connect 等，小编这里统一设置默认]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi server.properties</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存退出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wq!</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 3. 启动 kafka</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 zookeeper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start zookeeper</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 kafka</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew services start kafka</span></span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前机器在集群中的唯一标识，和 zookeeper 的 myid 性质一样</span></span><br><span class="line">broker.<span class="attribute">id</span>=0 </span><br><span class="line"><span class="comment"># 当前 kafka 对外提供服务的端口默认是 9092</span></span><br><span class="line"><span class="attribute">port</span>=9092 </span><br><span class="line"><span class="comment"># 这个参数默认是关闭的</span></span><br><span class="line">host.<span class="attribute">name</span>=192.168.1.170 </span><br><span class="line"><span class="comment"># 这个是 borker 进行网络处理的线程数</span></span><br><span class="line">num.network.<span class="attribute">threads</span>=3 </span><br><span class="line"><span class="comment"># 这个是 borker 进行 I/O 处理的线程数</span></span><br><span class="line">num.io.<span class="attribute">threads</span>=8 </span><br><span class="line"><span class="comment"># 消息存放的目录，这个目录可以配置为 “，” 逗号分割的表达式，上面的 num.io.threads 要大于这个目录的个数这个目录，如果配置多个目录，新创建的 topic 他把消息持久化的地方是，当前以逗号分割的目录中，那个分区数最少就放那一个</span></span><br><span class="line">log.<span class="attribute">dirs</span>=/opt/kafka/kafkalogs/ </span><br><span class="line"><span class="comment"># 发送缓冲区 buffer 大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能</span></span><br><span class="line">socket.send.buffer.<span class="attribute">bytes</span>=102400 </span><br><span class="line"><span class="comment"># kafka 接收缓冲区大小，当数据到达一定大小后在序列化到磁盘</span></span><br><span class="line">socket.receive.buffer.<span class="attribute">bytes</span>=102400 </span><br><span class="line"><span class="comment"># 这个参数是向 kafka 请求消息或者向 kafka 发送消息的请请求的最大数，这个值不能超过 java 的堆栈大小</span></span><br><span class="line">socket.request.max.<span class="attribute">bytes</span>=104857600 </span><br><span class="line"><span class="comment"># 默认的分区数，一个 topic 默认 1 个分区数</span></span><br><span class="line">num.<span class="attribute">partitions</span>=1</span><br><span class="line"><span class="comment"># 默认消息的最大持久化时间，168 小时，7 天</span></span><br><span class="line">log.retention.<span class="attribute">hours</span>=168 </span><br><span class="line"><span class="comment"># 消息保存的最大值 5M</span></span><br><span class="line">message.max.<span class="attribute">byte</span>=5242880  </span><br><span class="line"><span class="comment"># kafka 保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务</span></span><br><span class="line">default.replication.<span class="attribute">factor</span>=2  </span><br><span class="line"><span class="comment"># 取消息的最大直接数</span></span><br><span class="line">replica.fetch.max.<span class="attribute">bytes</span>=5242880  </span><br><span class="line"><span class="comment"># 这个参数是：因为 kafka 的消息是以追加的形式落地到文件，当超过这个值的时候，kafka 会新起一个文件</span></span><br><span class="line">log.segment.<span class="attribute">bytes</span>=1073741824 </span><br><span class="line"><span class="comment"># 每隔 300000 毫秒去检查上面配置的 log 失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除</span></span><br><span class="line">log.retention.check.interval.<span class="attribute">ms</span>=300000 </span><br><span class="line"><span class="comment"># 是否启用 log 压缩，一般不用启用，启用的话可以提高性能</span></span><br><span class="line">log.cleaner.<span class="attribute">enable</span>=<span class="literal">false</span> </span><br><span class="line"><span class="comment"># 设置 zookeeper 的连接端口、如果非集群配置一个地址即可</span></span><br><span class="line">zookeeper.<span class="attribute">connect</span>=192.168.1.180:12181,192.168.1.181:12181,192.168.1.182:1218</span><br></pre></td></tr></table></figure><h3 id="功能验证"><a href="#功能验证" class="headerlink" title="功能验证"></a>功能验证</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 topic[创建一个名为 test 的 topic，只有一个副本，一个分区]</span></span><br><span class="line">$ bin/kafka-topics.sh <span class="params">--create</span> <span class="params">--zookeeper</span> localhost<span class="function">:2181</span> <span class="params">--replication-factor</span> 1 <span class="params">--partitions</span> 1 <span class="params">--topic</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 list 命令查看刚刚创建的 topic</span></span><br><span class="line">$ bin/kafka-topics.sh <span class="params">--list</span> <span class="params">--zookeeper</span> localhost<span class="function">:2181</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 kafka-console-producer.sh 发送消息</span></span><br><span class="line">$ bin/kafka-console-producer.sh <span class="params">--broker-list</span> localhost<span class="function">:9092</span> <span class="params">--topic</span> test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 kafka-console-consumer.sh 接收消息并在终端打印</span></span><br><span class="line">$ bin/kafka-console-consumer.sh <span class="params">--bootstrap-server</span> localhost<span class="function">:9092</span> <span class="params">--topic</span> test <span class="params">--from-beginning</span></span><br></pre></td></tr></table></figure><p>友情提示：对于 Kafka 数据我们可以直接通过 IDEA 提供的 Kafka 可视化管理插件 - Kafkalytic 来查看。</p><h2 id="Spring-Boot-集成-Kafka"><a href="#Spring-Boot-集成-Kafka" class="headerlink" title="Spring Boot 集成 Kafka"></a>Spring Boot 集成 Kafka</h2><p>Spring 创建了一个项目 Spring-kafka，封装了 Apache 的 Kafka-client，用于在 Spring 项目里快速集成 kafka。除了简单的收发消息外，Spring-kafka 还提供了很多高级功能，下面我们就来一一探秘这些用法。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 spring-kafka 的支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、配置 kafka 的安装地址、端口以及账户信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.kafka</span><span class="selector-class">.bootstrap-servers</span>=localhost:<span class="number">9092</span></span><br></pre></td></tr></table></figure><p>3、主题配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过注入一个 NewTopic 类型的 Bean 来创建 topic，如果 topic 已存在，则会忽略。</span></span><br><span class="line"><span class="comment">     * P.S.</span></span><br><span class="line"><span class="comment">     * 1. 如果要修改分区数，只需修改配置值重启项目即可；修改分区数并不会导致数据的丢失，但是分区数只能增大不能减小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NewTopic <span class="title">helloTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NewTopic(<span class="string">"topic_hello"</span>, <span class="number">2</span>, (<span class="keyword">short</span>) <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;Object, Object&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(<span class="string">"topic_hello"</span>, <span class="string">"hello, world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    @KafkaListener(id = <span class="string">"hello"</span>, topics = <span class="string">"topic_hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span>(<span class="params">ConsumerRecord&lt;?, ?&gt; record</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Receiver :"</span> + record.<span class="keyword">value</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaHelloTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProducer helloProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        helloProducer.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><h4 id="kafka-事务消息"><a href="#kafka-事务消息" class="headerlink" title="kafka 事务消息"></a>kafka 事务消息</h4><p>默认情况下，Spring-kafka 自动生成的 KafkaTemplate 实例，是不具有事务消息发送能力的。如果需要开启事务机制，使用默认配置需要在 application.properties 添加 spring.kafka.producer.transaction-id-prefix 配置或者通过 Java Config 方式自己初始化 Bean。事务激活后，所有的消息发送只能在发生事务的方法内执行了，不然就会抛一个没有事务交易的异常。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 application.properties 添加 spring.kafka.producer.transaction-id-prefix 配置激活事务</span></span><br><span class="line">spring<span class="selector-class">.kafka</span><span class="selector-class">.producer</span><span class="selector-class">.transaction-id-prefix</span>=kafka_tx.</span><br></pre></td></tr></table></figure><p>Spring-Kafka 的事务消息是基于 Kafka 提供的事务消息功能的，Kafka 使用事务的两种方式：1、配置 Kafka 事务管理器并使用 @Transactional 注解；2、用 KafkaTemplate 的 executeInTransaction 方法</p><p>（一）配置 Kafka 事务管理器并使用 @Transactional 注解</p><p>使用注解方式开启事务还是比较方便的，不过首先需要我们配置 KafkaTransactionManager，这个类就是 Kafka 提供给我们的事务管理类，我们需要使用生产者工厂来创建这个事务管理类。通过 application.properties 添加 spring.kafka.producer.transaction-id-prefix 配置，KafkaAutoConfiguration 类会自动帮我们配置好相应的 Bean，感兴趣的同学可以阅读 KafkaAutoConfiguration 类的方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Test</span></span><br><span class="line"><span class="variable">@Transactional</span>(rollbackFor = RuntimeException.class)</span><br><span class="line">public void send() &#123;</span><br><span class="line">    <span class="selector-tag">kafkaTemplate</span><span class="selector-class">.send</span>(<span class="string">"topic_input"</span>, <span class="string">"kl"</span>);</span><br><span class="line">    <span class="selector-tag">throw</span> <span class="selector-tag">new</span> <span class="selector-tag">RuntimeException</span>(<span class="string">"failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法后我们可以看到控制台中输出了如下日志：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.apache</span><span class="selector-class">.kafka</span><span class="selector-class">.common</span><span class="selector-class">.KafkaException</span>: Failing batch since transaction was aborted</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.kafka</span><span class="selector-class">.clients</span><span class="selector-class">.producer</span><span class="selector-class">.internals</span><span class="selector-class">.Sender</span><span class="selector-class">.maybeSendAndPollTransactionalRequest</span>(Sender<span class="selector-class">.java</span>:<span class="number">422</span>) [kafka-clients-<span class="number">2.5</span>.<span class="number">0</span><span class="selector-class">.jar</span>:na]</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.kafka</span><span class="selector-class">.clients</span><span class="selector-class">.producer</span><span class="selector-class">.internals</span><span class="selector-class">.Sender</span><span class="selector-class">.runOnce</span>(Sender<span class="selector-class">.java</span>:<span class="number">312</span>) [kafka-clients-<span class="number">2.5</span>.<span class="number">0</span><span class="selector-class">.jar</span>:na]</span><br><span class="line">at org<span class="selector-class">.apache</span><span class="selector-class">.kafka</span><span class="selector-class">.clients</span><span class="selector-class">.producer</span><span class="selector-class">.internals</span><span class="selector-class">.Sender</span><span class="selector-class">.run</span>(Sender<span class="selector-class">.java</span>:<span class="number">239</span>) [kafka-clients-<span class="number">2.5</span>.<span class="number">0</span><span class="selector-class">.jar</span>:na]</span><br><span class="line">at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>) ~[na:<span class="number">1.8</span>.<span class="number">0</span>_211]</span><br></pre></td></tr></table></figure><p>（二）使用 KafkaTemplate 的 executeInTransaction 方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testExecuteInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 本地事务，不需要事务管理器</span></span><br><span class="line">    kafkaTemplate.executeInTransaction(operations -&gt; &#123;</span><br><span class="line">        operations.send(<span class="string">"topic_input"</span>, <span class="string">"kl"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"fail"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="生产者获取发送结果"><a href="#生产者获取发送结果" class="headerlink" title="生产者获取发送结果"></a>生产者获取发送结果</h4><p>通过 KafkaTemplate 发送消息时，我们可以通过异步或者同步的方式获取发送结果：</p><p>（1）异步获取</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    kafkaTemplate.send(<span class="string">"topic_input"</span>, <span class="string">"kl"</span>).addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;SendResult&lt;Object, Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">            log.<span class="keyword">error</span>(<span class="string">"kafka write topic failure."</span>, throwable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult&lt;Object, Object&gt; objectObjectSendResult)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"kafka write topic successful. - &#123;&#125;[&#123;&#125;]"</span>, objectObjectSendResult.getRecordMetadata().topic(), objectObjectSendResult.getRecordMetadata().partition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）同步获取</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">public <span class="keyword">void</span> send() &#123;</span><br><span class="line">    ListenableFuture&lt;SendResult&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt;&gt; future = kafkaTemplate.send(<span class="string">"topic_input"</span>, <span class="string">"kl"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SendResult&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; result = future.<span class="keyword">get</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-KafkaListener-的使用"><a href="#消费者-KafkaListener-的使用" class="headerlink" title="消费者 @KafkaListener 的使用"></a>消费者 @KafkaListener 的使用</h4><p>前面在简单集成中已经演示过了 @KafkaListener 接收消息的能力，但是 @KafkaListener 的功能不止如此，其他的比较常见的，使用场景比较多的功能点如下：</p><p>（1）显示的指定消费哪些Topic和分区的消息<br>（2）设置每个Topic以及分区初始化的偏移量<br>（3）设置消费线程并发度<br>（4）设置消息异常处理器</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@KafkaListener(<span class="attr">id</span> = <span class="string">"webGroup"</span>, <span class="attr">topicPartitions</span> = &#123;</span><br><span class="line">        @TopicPartition(<span class="attr">topic</span> = <span class="string">"topic1"</span>, <span class="attr">partitions</span> = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>&#125;),</span><br><span class="line">        @TopicPartition(<span class="attr">topic</span> = <span class="string">"topic2"</span>, <span class="attr">partitions</span> = <span class="string">"0"</span>, <span class="attr">partitionOffsets</span> = @PartitionOffset(<span class="attr">partition</span> = <span class="string">"1"</span>, <span class="attr">initialOffset</span> = <span class="string">"100"</span>))</span><br><span class="line">&#125;, <span class="attr">concurrency</span> = <span class="string">"6"</span>, <span class="attr">errorHandler</span> = <span class="string">"myErrorHandler"</span>)</span><br><span class="line">public String listen(String input) &#123;</span><br><span class="line">    log.info(<span class="string">"input value: &#123;&#125;"</span>, input);</span><br><span class="line">    return <span class="string">"successful"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>errorHandler 需要设置这个参数需要实现一个接口 KafkaListenerErrorHandler。而且注解里的配置，是你自定义实现实例在 spring 上下文中的 Name。比如，上面配置为 errorHandler = “myErrorHandler”。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Service(<span class="string">"myErrorHandler"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaListenerErrorHandler</span> <span class="keyword">implements</span> <span class="title">KafkaListenerErrorHandler</span> </span>&#123;</span><br><span class="line">    Logger logger =LoggerFactory.getLogger(getClass());</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Object handleError(Message<span class="meta">&lt;?</span>&gt; message, ListenerExecutionFailedException <span class="keyword">exception</span>) &#123;</span><br><span class="line">        logger.info(message.getPayload().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Object handleError(Message<span class="meta">&lt;?</span>&gt; message, ListenerExecutionFailedException <span class="keyword">exception</span>, Consumer<span class="meta">&lt;?</span>, <span class="meta">?&gt;</span> consumer) &#123;</span><br><span class="line">        logger.info(message.getPayload().toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-KafkaListener-注解监听器生命周期"><a href="#消费者-KafkaListener-注解监听器生命周期" class="headerlink" title="消费者 @KafkaListener 注解监听器生命周期"></a>消费者 @KafkaListener 注解监听器生命周期</h4><p>@KafkaListener 注解的监听器的生命周期是可以控制的，默认情况下，@KafkaListener 的参数 autoStartup = “true”。也就是自动启动消费，但是也可以同过 KafkaListenerEndpointRegistry 来干预他的生命周期。KafkaListenerEndpointRegistry 有三个动作方法分别如：启动 start()、停止 pause()、继续 resume()；接下来我们通过一个场景来描述一下这个功能的用途：比如现在单机环境下，我们需要利用 Kafka 做数据持久化的功能，由于用户活跃的时间为早上 10 点至晚上 12 点，那在这个时间段做一个大数据量的持久化可能会影响数据库性能导致用户体验降低，我们可以选择在用户活跃度低的时间段去做持久化的操作，也就是晚上 12 点后到第二条的早上 10 点前。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@EnableScheduling</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TaskListener</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private final KafkaProperties properties;</span><br><span class="line"></span><br><span class="line">    private final KafkaListenerEndpointRegistry kafkaListenerEndpointRegistry;</span><br><span class="line"></span><br><span class="line">    public TaskListener(KafkaProperties properties, KafkaListenerEndpointRegistry kafkaListenerEndpointRegistry) &#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">        <span class="keyword">this</span>.kafkaListenerEndpointRegistry = kafkaListenerEndpointRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConcurrentKafkaListenerContainerFactory&lt;?, ?&gt; delayContainerFactory(</span><br><span class="line">            ConcurrentKafkaListenerContainerFactoryConfigurer configurer,</span><br><span class="line">            ObjectProvider&lt;ConsumerFactory&lt;Object, Object&gt;&gt; kafkaConsumerFactory) &#123;</span><br><span class="line">        ConcurrentKafkaListenerContainerFactory&lt;Object, Object&gt; factory = <span class="keyword">new</span> ConcurrentKafkaListenerContainerFactory&lt;&gt;();</span><br><span class="line">        configurer.configure(factory, kafkaConsumerFactory</span><br><span class="line">                .getIfAvailable<span class="function"><span class="params">(() -&gt; <span class="keyword">new</span> DefaultKafkaConsumerFactory&lt;&gt;(<span class="keyword">this</span>.properties.buildConsumerProperties()))</span>);</span></span><br><span class="line"><span class="function">        // 禁止自动启动</span></span><br><span class="line"><span class="function">        <span class="title">factory</span>.<span class="title">setAutoStartup</span><span class="params">(<span class="literal">false</span>)</span>;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">factory</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    @<span class="title">KafkaListener</span><span class="params">(id = <span class="string">"durable"</span>, topics = <span class="string">"topic.quick.durable"</span>, containerFactory = <span class="string">"delayContainerFactory"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">void</span> <span class="title">durableListener</span><span class="params">(String data)</span> &#123;</span></span><br><span class="line"><span class="function">        // 这里做数据持久化的操作</span></span><br><span class="line"><span class="function">        <span class="title">log</span>.<span class="title">info</span><span class="params">(<span class="string">"topic.quick.durable receive : "</span> + data)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * 定时器，每天凌晨0点开启监听</span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    @<span class="title">Scheduled</span><span class="params">(cron = <span class="string">"0 0 0 * * ?"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">void</span> <span class="title">startListener</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">        // 判断监听容器是否启动，未启动则将其启动</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(!kafkaListenerEndpointRegistry.getListenerContainer(<span class="string">"durable"</span>).isRunning())</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">kafkaListenerEndpointRegistry</span>.<span class="title">getListenerContainer</span><span class="params">(<span class="string">"durable"</span>)</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">kafkaListenerEndpointRegistry</span>.<span class="title">getListenerContainer</span><span class="params">(<span class="string">"durable"</span>)</span>.<span class="title">resume</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /**</span></span><br><span class="line"><span class="function">     * 定时器，每天早上10点关闭监听</span></span><br><span class="line"><span class="function">     */</span></span><br><span class="line"><span class="function">    @<span class="title">Scheduled</span><span class="params">(cron = <span class="string">"0 0 10 * * ?"</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">void</span> <span class="title">shutDownListener</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">kafkaListenerEndpointRegistry</span>.<span class="title">getListenerContainer</span><span class="params">(<span class="string">"durable"</span>)</span>.<span class="title">pause</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="消费者手动-Ack-模式"><a href="#消费者手动-Ack-模式" class="headerlink" title="消费者手动 Ack 模式"></a>消费者手动 Ack 模式</h4><p>手动 ACK 模式，由业务逻辑控制提交偏移量。开启手动首先需要关闭自动提交，然后设置下 consumer 的消费模式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enable.auto.commit 参数设置成 false。那么就是 Spring 来替为我们做人工提交，从而简化了人工提交的方式</span></span><br><span class="line">spring<span class="selector-class">.kafka</span><span class="selector-class">.consumer</span><span class="selector-class">.enable-auto-commit</span>=false</span><br><span class="line">spring<span class="selector-class">.kafka</span><span class="selector-class">.listener</span><span class="selector-class">.ack-mode</span>=manual</span><br></pre></td></tr></table></figure><p>上面的设置好后，在消费时，只需要在 @KafkaListener 监听方法的入参加入 Acknowledgment 即可，执行到 ack.acknowledge() 代表提交了偏移量：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">KafkaListener</span>(<span class="keyword">id</span> = <span class="string">"hello"</span>, topics = <span class="string">"topic_input"</span>)</span><br><span class="line">public void listen(String input, Acknowledgment ack) &#123;</span><br><span class="line">    <span class="selector-tag">log</span><span class="selector-class">.info</span>("<span class="selector-tag">input</span> <span class="selector-tag">value</span>: &#123;&#125;", <span class="selector-tag">input</span>);</span><br><span class="line">    <span class="selector-tag">ack</span><span class="selector-class">.acknowledge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者-SendTo-消息转发"><a href="#消费者-SendTo-消息转发" class="headerlink" title="消费者 SendTo 消息转发"></a>消费者 SendTo 消息转发</h4><p>@SendTo 注解可以带一个参数，指定转发的 Topic 队列。常见的场景如，一个消息需要做多重加工，不同的加工耗费的 cup 等资源不一致，那么就可以通过跨不同 Topic 和部署在不同主机上的 consumer 来解决了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(id = <span class="meta-string">"webGroup"</span>, topics = <span class="meta-string">"topic-kl"</span>)</span></span><br><span class="line"><span class="meta">@SendTo(<span class="meta-string">"topic-ckl"</span>)</span></span><br><span class="line"><span class="keyword">public</span> String listen(String input) &#123;</span><br><span class="line">    log.info(<span class="string">"input value: &#123;&#125;"</span>, input);</span><br><span class="line">    <span class="comment">// 将 input + "hello!" 消息转发至 topic-ckl 队列</span></span><br><span class="line">    <span class="keyword">return</span> input + <span class="string">"hello!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@KafkaListener(id = <span class="meta-string">"webGroup1"</span>, topics = <span class="meta-string">"topic-ckl"</span>)</span></span><br><span class="line"><span class="keyword">public</span> void listen2(String input) &#123;</span><br><span class="line">    log.info(<span class="string">"input value: &#123;&#125;"</span>, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kafka-知识问答"><a href="#kafka-知识问答" class="headerlink" title="kafka 知识问答"></a>kafka 知识问答</h2><h3 id="Kafka-的分区数是不是越多越好？"><a href="#Kafka-的分区数是不是越多越好？" class="headerlink" title="Kafka 的分区数是不是越多越好？"></a>Kafka 的分区数是不是越多越好？</h3><p>kafka 使用分区将 topic 的消息打散到多个分区分布保存在不同的 broker 上，实现了 producer 和 consumer 消息处理的高吞吐量。Kafka 的 producer 和 consumer 都可以多线程地并行操作，而每个线程处理的是一个分区的数据。因此分区实际上是调优 Kafka 并行度的最小单元。对于 producer 而言，它实际上是用多个线程并发地向不同分区所在的 broker 发起 Socket 连接同时给这些分区发送消息；而 consumer，同一个消费组内的所有 consumer 线程都被指定 topic 的某一个分区进行消费。所以说，如果一个 topic 分区越多，理论上整个集群所能达到的吞吐量就越大。</p><p>分区多的缺点：</p><p>一、客户端 / 服务器端内存开销<br>Kafka0.8.2 之后，在客户端 producer 有个参数 batch.size，默认是 16KB。它会为每个分区缓存消息，一旦满了就打包将消息批量发出。不过很显然，因为这个参数是分区级别的，如果分区数越多，这部分缓存所需的内存占用也会更多。对于服务器端 consumer 的开销也不小，如果阅读 Kafka 源码的话可以发现，服务器端的很多组件都在内存中维护了分区级别的缓存，比如 controller，FetcherManager 等，因此分区数越多，这种缓存的成本就越大。</p><p>二、文件句柄的开销<br>每个分区在底层文件系统都有属于自己的一个目录。该目录下通常会有两个文件： base_offset.log 和 base_offset.index。Kafak 的 Controller 和 ReplicaManager 会为每个 broker 都保存这两个文件句柄 (file handler)。很明显，如果分区数越多，所需要保持打开状态的文件句柄数也就越多，最终可能会突破你的 ulimit -n 的限制。</p><p>三、降低高可用性<br>Kafka 通过副本 (replica) 机制来保证高可用。具体做法就是为每个分区保存若干个副本 (replica_factor 指定副本数)。每个副本保存在不同的 broker 上。其中的一个副本充当 leader 副本，负责处理 producer 和 consumer 请求。其他副本充当 follower 角色，由 Kafka controller 负责保证与 leader 的同步。如果 leader 所在的 broker 挂掉了，contorller 会检测到然后在 zookeeper 的帮助下重选出新的 leader —— 这中间会有短暂的不可用时间窗口，虽然大部分情况下可能只是几毫秒级别。但如果你有 10000 个分区，10 个 broker，也就是说平均每个 broker 上有 1000 个分区。此时这个 broker 挂掉了，那么 zookeeper 和 controller 需要立即对这 1000 个分区进行 leader 选举。比起很少的分区 leader 选举而言，这必然要花更长的时间，并且通常不是线性累加的。</p><h3 id="一条消息如何知道要被发送到哪个分区？"><a href="#一条消息如何知道要被发送到哪个分区？" class="headerlink" title="一条消息如何知道要被发送到哪个分区？"></a>一条消息如何知道要被发送到哪个分区？</h3><p>一、按照 key 值分配：默认情况下，Kafka 根据传递消息的 key 来进行分区的分配，即 hash(key) % numPartitions，这保证了相同 key 的消息一定会被路由到相同的分区。</p><p>二、key 为 null 时，从缓存中取分区 id 或者随机取一个：不指定 key 时，Kafka 几乎就是随机找一个分区发送无 key 的消息，然后把这个分区号加入到缓存中以备后面直接使用——当然了，Kafka 本身也会清空该缓存（默认每 10 分钟或每次请求 topic 元数据时）。</p><h3 id="Kafka-是如何保证数据可靠性？"><a href="#Kafka-是如何保证数据可靠性？" class="headerlink" title="Kafka 是如何保证数据可靠性？"></a>Kafka 是如何保证数据可靠性？</h3><p>一、Topic 分区副本</p><p>在 Kafka 0.8.0 之前，Kafka 是没有副本的概念的，那时候人们只会用 Kafka 存储一些不重要的数据，因为没有副本，数据很可能会丢失。但是随着业务的发展，支持副本的功能越来越强烈，所以为了保证数据的可靠性，Kafka 从 0.8.0 版本开始引入了分区副本。也就是说每个分区可以人为的配置几个副本（比如创建主题的时候指定 replication-factor，也可以在 Broker 级别进行配置 default.replication.factor），一般会设置为 3。通过分区副本，引入了数据冗余，同时也提供了 Kafka 的数据可靠性。Kafka 的分区多副本架构是 Kafka 可靠性保证的核心，把消息写入多个副本可以使 Kafka 在发生崩溃时仍能保证消息的持久性。</p><p>二、Producer 往 Broker 发送消息</p><p> Kafka 在 Producer 里面提供了消息确认机制，也就是说我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。根据实际的应用场景，我们设置不同的 acks，以此保证数据的可靠性。另外，Producer 发送消息还可以选择同步（默认，通过 producer.type=sync 配置） 或者异步（producer.type=async）模式。如果设置成异步，虽然会极大的提高消息发送的性能，但是这样会增加丢失数据的风险。如果需要确保消息的可靠性，必须将 producer.type 设置为 sync。</p><p> 三、Leader 选举</p><p> 每个分区的 leader 会维护一个 ISR 列表，ISR 列表里面就是 follower 副本的 Borker 编号，只有跟得上 Leader 的 follower 副本才能加入到 ISR 里面，只有 ISR 里的成员才有被选为 leader 的可能。所以当 Leader 挂掉了，而且 unclean.leader.election.enable=false 的情况下，Kafka 会从 ISR 列表中选择第一个 follower 作为新的 Leader，因为这个分区拥有最新的已经 committed 的消息。通过这个可以保证已经 committed 的消息的数据可靠性。</p><p> 综上所述，为了保证数据的可靠性，我们最少需要配置一下几个参数：</p><ul><li>producer 级别：acks=all（或者 request.required.acks=-1），同时发生模式为同步 producer.type=sync</li><li>topic 级别：设置 replication.factor&gt;=3，并且 min.insync.replicas&gt;=2；</li><li>broker 级别：关闭不完全的 Leader 选举，即 unclean.leader.election.enable=false；</li></ul><h3 id="Kafka-是如何保证数据一致性？"><a href="#Kafka-是如何保证数据一致性？" class="headerlink" title="Kafka 是如何保证数据一致性？"></a>Kafka 是如何保证数据一致性？</h3><p>这里介绍的数据一致性主要是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。那么 Kafka 是如何实现的呢？</p><p>假设分区的副本为 3，其中副本 0 是 Leader，副本 1 和副本 2 是 follower，并且在 ISR 列表里面。虽然副本 0 已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，对应于上图的副本 2，这个很类似于木桶原理。这样做的原因是还没有被足够多副本复制的消息被认为是 “不安全” 的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本 0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本 1 为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。当然，引入了 High Water Mark 机制，会导致 Broker 间的消息复制因为某些原因变慢，那么消息到达消费者的时间也会随之变长（因为我们会先等待消息复制完毕）。延迟时间可以通过参数 replica.lag.time.max.ms 参数配置，它指定了副本在复制消息时可被允许的最大延迟时间。</p><p><img src="/media/15898787033263/kafka_high_water_make-iteblog.png" alt="Kafka High Water Mark"></p><h3 id="Kafka-如何通过经典的内存缓冲池设计来优化-JVM-GC-问题？"><a href="#Kafka-如何通过经典的内存缓冲池设计来优化-JVM-GC-问题？" class="headerlink" title="Kafka 如何通过经典的内存缓冲池设计来优化 JVM GC 问题？"></a>Kafka 如何通过经典的内存缓冲池设计来优化 JVM GC 问题？</h3><p>Kafka 是一个高吞吐的消息队列，是大数据场景首选的消息队列，这种场景就意味着发送单位时间消息的量会特别的大，那么 Kafka 如何做到能支持能同时发送大量消息的呢？</p><p>Kafka 通过批量压缩和发送做到能支持能同时发送大量消息。Kafka 的 kafkaProducer 对象是线程安全的，每个发送线程在发送消息时候共用一个 kafkaProducer 对象来调用发送方法，最后发送的数据根据 Topic 和分区的不同被组装进某一个 RecordBatch 中。发送的数据放入 RecordBatch 后会被发送线程批量取出组装成 ProduceRequest 对象发送给 Kafka 服务端。</p><p>Kafka 通过使用内存缓冲池的设计，让整个发送过程中的存储空间循环利用，有效减少 JVM GC 造成的影响，从而提高发送性能，提升吞吐量。也就是说，Kafka 首先判断需要存储的数据的大小是否 free（已申请未使用空间）里有合适的 recordBatch 装得下，如果装得下则用 recordBatch 来存储数据；如果 free（已申请未使用空间）里没有空间但是 availableMemory（未申请未使用）+free（已申请未使用空间）的大小比需要存储的数据大（也就是说可使用空间比实际需要申请的空间大），说明可使用空间大小足够，则会用让 free 一直释放 byteBuffer 空间直到有空间装得下要存储的数据位置；如果需要申请的空间比实际可使用空间大，则内存申请会阻塞直到申请到足够的内存为止。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/1621c1eda358" target="_blank" rel="noopener">kafka生产者Producer参数设置及参数调优建议-kafka商业环境实战系列</a><br>[2]. <a href="https://blog.csdn.net/u014774648/article/details/90110508" target="_blank" rel="noopener">spring-kafka生产者消费者配置详解</a><br>[3]. <a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/#" target="_blank" rel="noopener">Kafka 安装及快速入门</a><br>[4]. <a href="https://segmentfault.com/a/1190000020217170?utm_source=tag-newest#item-6-4" target="_blank" rel="noopener">spring boot集成kafka之spring-kafka深入探秘</a><br>[5]. <a href="https://blog.csdn.net/FreeApe/article/details/103710522" target="_blank" rel="noopener">Spring Boot Kafka概览、配置及优雅地实现发布订阅</a><br>[6]. <a href="https://www.iteblog.com/archives/2560.html" target="_blank" rel="noopener">Kafka 是如何保证数据可靠性和一致性</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. ISR：ISR（(In Sync Replicas）所有与 leader 副本保持一定程度同步的副本（包括 leader 副本在内）组成 ISR (In Sync Replicas)。分区中的所有副本统称为 AR (Assigned Replicas)。ISR 集合是 AR 集合的一个子集。消息会先发送到 leader 副本，然后 follower 副本才能从 leader 中拉取消息进行同步。同步期间，follow 副本相对于 leader 副本而言会有一定程度的滞后。前面所说的 ”一定程度同步 “ 是指可忍受的滞后范围，这个范围可以通过参数进行配置。于 leader 副本同步滞后过多的副本（不包括 leader 副本）将组成 OSR （Out-of-Sync Replied）由此可见，AR = ISR + OSR。正常情况下，所有的 follower 副本都应该与 leader 副本保持 一定程度的同步，即 AR=ISR，OSR 集合为空。leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态，当 follower 副本落后太多或失效时，leader 副本会把它从 ISR 集合中剔除。如果 OSR 集合中所有 follower 副本“追上” 了 leader 副本，那么 leader 副本会把它从 OSR 集合转移至 ISR 集合。默认情况下，当 leader 副本发生故障时，只有在 ISR 集合中的 follower 副本才有资格被选举为新的 leader，而在 OSR 集合中的副本则没有任何机会。</small></p><hr><h2 id="了不起的消息队列系列"><a href="#了不起的消息队列系列" class="headerlink" title="了不起的消息队列系列"></a>了不起的消息队列系列</h2><ul><li><a href="1c55560e.html">了不起的消息队列（一）：浅谈消息队列及常见的分布式消息队列中间件</a></li><li><a href="f99da47b.html">了不起的消息队列（二）：啊哈！RabbitMQ</a></li><li><a href="5d3d79c7.html">了不起的消息队列（三）：致敬匠心，Kafka</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在本系列的前一篇博文中，笔者对 RabbitMQ 基本框架、概念、通信过程等基础原理，RabbitMQ 安装教程，RabbitMQ 在项目中实际应用场景等进行了详细的讲解。经过上一篇博客介绍，相信大家对 RabbitMQ 已经有了一个大致了解。Kafka 是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 Zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。&lt;/p&gt;
&lt;p&gt;本文意在介绍 Kafka 的基本原理，包括 Kafka 基本概念、通信过程等，介绍一下 Kafka 安装教程，最后介绍一下 Kafka 在项目中实际应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列" scheme="https://blog.maoning.vip/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="安装教程" scheme="https://blog.maoning.vip/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="Kafka" scheme="https://blog.maoning.vip/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>以匠人之心，Java 11 正式发布</title>
    <link href="https://blog.maoning.vip/archives/7c18665b.html"/>
    <id>https://blog.maoning.vip/archives/7c18665b.html</id>
    <published>2020-02-24T08:18:44.000Z</published>
    <updated>2020-08-04T02:02:36.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Java 11 已于 2018 年 9 月 25 日正式发布，Java 开发团队为了加快的版本迭代、跟进社区反馈，Java 的版本发布周期调整为每六个月一次——即每半年发布一个大版本，每个季度发布一个中间特性版本，并且做出不会跳票的承诺。通过这样的方式，Java 开发团队能够将一些重要特性尽早的合并到 Java Release 版本中，以便快速得到开发者的反馈，避免出现类似 Java 9 发布时的两次延期的情况。</p><p>本文主要针对 Java 9 - Java 11 中的新特性展开介绍，让您快速了解 Java 9 - Java 11 带来的变化。</p><a id="more"></a><h2 id="特性介绍"><a href="#特性介绍" class="headerlink" title="特性介绍"></a>特性介绍</h2><p>按照官方介绍，新的版本发布周期将会严格按照时间节点，于每年的 3 月和 9 月发布，Java 11 发布的时间节点也正好处于 Java 8 免费更新到期的前夕。与 Java 9 和 Java 10 这两个被称为 “功能性的版本” 不同，Java 11 仅将提供长期支持服务（LTS, Long-Term-Support），还将作为 Java 平台的默认支持版本，并且会提供技术支持直至 2023 年 9 月，对应的补丁和安全警告等支持将持续至 2026 年。</p><p><img src="/media/15795735039117/5954965-80173492f7a44cc1.png" alt="Oracle Java 支持版本"></p><h3 id="REPL（JShell）-since-9"><a href="#REPL（JShell）-since-9" class="headerlink" title="REPL（JShell）@since 9"></a>REPL（JShell）@since 9</h3><p>REPL（Read Eval Print Loop）意为交互式的编程环境。JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。JShell 它提供了一个交互式 shell，用于快速原型、调试、学习 Java 及 Java API，所有这些都不需要 public static void main 方法，也不需要在执行之前编译代码。</p><p>1、执行 JSHELL</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jshell</span><br><span class="line">|  <span class="type">欢迎使用 JShell</span> -- 版本 <span class="number">13.0</span><span class="number">.1</span></span><br><span class="line">|  <span class="type">要大致了解该版本, 请键入: /help</span> <span class="built_in">intro</span></span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><p>2、查看 JShell 命令：输入 /help 可以查看 JShell 相关的命令</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /help</span><br><span class="line">|<span class="string">  键入 Java 语言表达式, 语句或声明。</span></span><br><span class="line">|<span class="string">  或者键入以下命令之一:</span></span><br><span class="line">|<span class="string">  /list [&lt;名称或 id&gt;</span>|<span class="string">-all</span>|<span class="string">-start]</span></span><br><span class="line">|<span class="string">       列出您键入的源</span></span><br><span class="line">|<span class="string">  /edit &lt;名称或 id&gt;</span></span><br><span class="line">|<span class="string">       编辑源条目</span></span><br><span class="line">|<span class="string">  /drop &lt;名称或 id&gt;</span></span><br><span class="line">|<span class="string">       删除源条目</span></span><br><span class="line">|<span class="string">  /save [-all</span>|<span class="string">-history</span>|<span class="string">-start] &lt;文件&gt;</span></span><br><span class="line">|<span class="string">       将片段源保存到文件</span></span><br><span class="line">|<span class="string">  /open &lt;file&gt;</span></span><br><span class="line">|<span class="string">       打开文件作为源输入</span></span><br><span class="line">|<span class="string">  /vars [&lt;名称或 id&gt;</span>|<span class="string">-all</span>|<span class="string">-start]</span></span><br><span class="line">|<span class="string">       列出已声明变量及其值</span></span><br><span class="line">|<span class="string">  /methods [&lt;名称或 id&gt;</span>|<span class="string">-all</span>|<span class="string">-start]</span></span><br><span class="line">|<span class="string">       列出已声明方法及其签名</span></span><br><span class="line">|<span class="string">  /types [&lt;名称或 id&gt;</span>|<span class="string">-all</span>|<span class="string">-start]</span></span><br><span class="line">|<span class="string">       列出类型声明</span></span><br><span class="line">|<span class="string">  /imports</span></span><br><span class="line">|<span class="string">       列出导入的项</span></span><br><span class="line">|<span class="string">  /exit [&lt;integer-expression-snippet&gt;]</span></span><br><span class="line">|<span class="string">       退出 jshell 工具</span></span><br><span class="line">|<span class="string">  /env [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;] ...</span></span><br><span class="line">|<span class="string">       查看或更改评估上下文</span></span><br><span class="line">|<span class="string">  /reset [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;] [-add-modules &lt;模块&gt;]...</span></span><br><span class="line">|<span class="string">       重置 jshell 工具</span></span><br><span class="line">|<span class="string">  /reload [-restore] [-quiet] [-class-path &lt;路径&gt;] [-module-path &lt;路径&gt;]...</span></span><br><span class="line">|<span class="string">       重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)</span></span><br><span class="line">|<span class="string">  /history [-all]</span></span><br><span class="line">|<span class="string">       您键入的内容的历史记录</span></span><br><span class="line">|<span class="string">  /help [&lt;command&gt;</span>|<span class="string">&lt;subject&gt;]</span></span><br><span class="line">|<span class="string">       获取有关使用 jshell 工具的信息</span></span><br><span class="line">|<span class="string">  /set editor</span>|<span class="string">start</span>|<span class="string">feedback</span>|<span class="string">mode</span>|<span class="string">prompt</span>|<span class="string">truncation</span>|<span class="string">format ...</span></span><br><span class="line">|<span class="string">       设置配置信息</span></span><br><span class="line">|<span class="string">  /? [&lt;command&gt;</span>|<span class="string">&lt;subject&gt;]</span></span><br><span class="line">|<span class="string">       获取有关使用 jshell 工具的信息</span></span><br><span class="line">|<span class="string">  /!</span></span><br><span class="line">|<span class="string">       重新运行上一个片段 -- 请参阅 /help rerun</span></span><br><span class="line">|<span class="string">  /&lt;id&gt;</span></span><br><span class="line">|<span class="string">       按 ID 或 ID 范围重新运行片段 -- 参见 /help rerun</span></span><br><span class="line">|<span class="string">  /-&lt;n&gt;</span></span><br><span class="line">|<span class="string">       重新运行以前的第 n 个片段 -- 请参阅 /help rerun</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">  有关详细信息, 请键入 '/help', 后跟</span></span><br><span class="line">|<span class="string">  命令或主题的名称。</span></span><br><span class="line">|<span class="string">  例如 '/help /list' 或 '/help intro'。主题:</span></span><br><span class="line">|</span><br><span class="line">|<span class="string">  intro</span></span><br><span class="line">|<span class="string">       jshell 工具的简介</span></span><br><span class="line">|<span class="string">  keys</span></span><br><span class="line">|<span class="string">       类似 readline 的输入编辑的说明</span></span><br><span class="line">|<span class="string">  id</span></span><br><span class="line">|<span class="string">       片段 ID 以及如何使用它们的说明</span></span><br><span class="line">|<span class="string">  shortcuts</span></span><br><span class="line">|<span class="string">       片段和命令输入提示, 信息访问以及</span></span><br><span class="line">|<span class="string">       自动代码生成的按键说明</span></span><br><span class="line">|<span class="string">  context</span></span><br><span class="line">|<span class="string">       /env /reload 和 /reset 的评估上下文选项的说明</span></span><br><span class="line">|<span class="string">  rerun</span></span><br><span class="line">|<span class="string">       重新评估以前输入片段的方法的说明</span></span><br></pre></td></tr></table></figure><p>3、JShell 执行使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JShell 执行计算</span></span><br><span class="line">jshell&gt; <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">$<span class="number">3</span> ==&gt; <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JShell 定义变量</span></span><br><span class="line">jshell&gt; <span class="keyword">var</span> uuid = UUID.randomUUID();</span><br><span class="line">uuid ==&gt; f543a51c<span class="number">-8166</span><span class="number">-49</span>c3-a0d0-c06ed5993f71</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出的表达式</span></span><br><span class="line">jshell&gt; System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line"><span class="comment">// JShell 创建函数</span></span><br><span class="line"></span><br><span class="line">jshell&gt; public <span class="built_in">String</span> say(<span class="built_in">String</span> s) &#123;</span><br><span class="line">   ...&gt;   <span class="keyword">return</span> s;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  已创建 方法 say(<span class="built_in">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// JShell 使用函数</span></span><br><span class="line">jshell&gt; say(<span class="string">"Hello World!"</span>);</span><br><span class="line">$<span class="number">8</span> ==&gt; <span class="string">"Hello World!"</span></span><br></pre></td></tr></table></figure><p>4、退出 JShell：输入 /exit 命令退出 jshell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jshell&gt;</span><span class="bash"> /<span class="built_in">exit</span></span></span><br><span class="line">|  再见</span><br></pre></td></tr></table></figure><h3 id="局部变量类型推断-since-10"><a href="#局部变量类型推断-since-10" class="headerlink" title="局部变量类型推断 @since 10"></a>局部变量类型推断 @since 10</h3><p>从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型。这一改进简化了代码编写、节省了开发者的工作时间，因为不再需要显式声明局部变量的类型，而是可以使用关键字 var，且不会使源代码过于复杂。var 是 Java10 中新增的局部类型变量推断。它会根据后面的值来推断变量的类型，所以 var 必须要初始化。var 其实就是 Java 10 增加的一种语法糖而已，在编译期间会自动推断实际类型，其编译后的字节码和实际类型一致。</p><p>但是在 Java 10 中，还有下面几个限制：</p><ul><li>只能用于局部变量上</li><li>声明时必须初始化</li><li>不能用作方法参数</li><li>不能在 Lambda 表达式中使用</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 定义局部变量[等同于 int a = 1;]</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// var 接收方法返回[等同于 String result = this.getResult();]</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">this</span>.getResult();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var 循环中定义局部变量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">   System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var 结合泛型[等同于 List&lt;String&gt; list = new ArrayList&lt;&gt;();]</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// var 结合泛型[&lt;&gt;里默认会是Object]</span></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h4 id="用于-Lambda-参数的局部变量语法-since-11"><a href="#用于-Lambda-参数的局部变量语法-since-11" class="headerlink" title="用于 Lambda 参数的局部变量语法 @since 11"></a>用于 Lambda 参数的局部变量语法 @since 11</h4><p>Java 11 与 Java 10 的不同之处在于允许开发者在 Lambda 表达式中使用 var 进行参数声明。乍一看，这一举措似乎有点多余，因为在写代码过程中可以省略 Lambda 参数的类型，并通过类型推断确定它们。但是，添加上类型定义同时使用 @Nonnull 和 @Nullable 等类型注释还是很有用的，既能保持与局部变量的一致写法，也不丢失代码简洁。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nonnull <span class="keyword">var</span> x = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="function"><span class="params">(@Nonnull <span class="keyword">var</span> x, @Nullable <span class="keyword">var</span> y)</span> -&gt;</span> x.process(y)</span><br></pre></td></tr></table></figure><p><strong>局部变量类型推断优缺点</strong></p><p>（1）优点：简化代码</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList list1 = <span class="keyword">new</span> <span class="type">CopyOnWriteArrayList</span>();</span><br><span class="line">ConcurrentModificationException cme1 = <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span>();</span><br><span class="line">DefaultServiceUnavailableRetryStrategy strategy1 = <span class="keyword">new</span> <span class="type">DefaultServiceUnavailableRetryStrategy</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> <span class="type">CopyOnWriteArrayList</span> &lt;&gt;();</span><br><span class="line"><span class="keyword">var</span> cme2 = <span class="keyword">new</span> <span class="type">ConcurrentModificationException</span> ();</span><br><span class="line"><span class="keyword">var</span> strategy2 = <span class="keyword">new</span> <span class="type">DefaultServiceUnavailableRetryStrategy</span> ();</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，很长的定义类型会显得代码很冗长，使用 var 大大简化了代码编写，同时类型统一显得代码很对齐。</p><p>（2）缺点：掩盖类型</p><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="function"><span class="keyword">new</span> <span class="title">JsonParserDelegate</span>(parser).<span class="title">currentToken</span>();</span></span><br></pre></td></tr></table></figure><p>看以上代码，不进去看返回结果类型，谁知道返回的类型是什么？所以这种情况最好别使用 var，而使用具体的抽象类、接口或者实例类型。</p><h3 id="私有接口方法-since-9"><a href="#私有接口方法-since-9" class="headerlink" title="私有接口方法 @since 9"></a>私有接口方法 @since 9</h3><p>在 Java 8 之前，接口可以有常量变量和抽象方法。我们不能在接口中提供方法实现。如果我们要提供抽象方法和非抽象方法（方法与实现）的组合，那么我们就得使用抽象类。</p><p>在 Java 8 接口引入了一些新功能——默认方法和静态方法。我们可以在Java SE 8的接口中编写方法实现，仅仅需要使用 default 关键字来定义它们。</p><p>Java 9 不仅像 Java 8 一样支持接口默认方法，同时还支持私有方法。在 Java 9 中，一个接口中能定义如下几种变量/方法：</p><ul><li>常量</li><li>抽象方法</li><li>默认方法</li><li>静态方法</li><li>私有方法</li><li>私有静态方法</li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Long <span class="title">createEmployeeID</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Method implementation goes here.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">displayEmployeeDetails</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// Method implementation goes here.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串增强-since-11"><a href="#字符串增强-since-11" class="headerlink" title="字符串增强 @since 11"></a>字符串增强 @since 11</h3><p>Java 11 增加了一系列的字符串处理方法，如以下所示：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="keyword">boolean</span> blank = <span class="string">" "</span>.isBlank();</span><br><span class="line">System.out.<span class="built_in">println</span>(blank);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空格</span></span><br><span class="line"><span class="keyword">String</span> strip = <span class="string">" Hello Java11 "</span>.strip();</span><br><span class="line">System.out.<span class="built_in">println</span>(strip);  <span class="comment">// "Hello Java11"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="keyword">String</span> stripTrailing = <span class="string">" Hello Java11 "</span>.stripTrailing();</span><br><span class="line">System.out.<span class="built_in">println</span>(stripTrailing);  <span class="comment">// " Hello Java11"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="keyword">String</span> stripLeading = <span class="string">" Hello Java11 "</span>.stripLeading();</span><br><span class="line">System.out.<span class="built_in">println</span>(stripLeading);   <span class="comment">// "Hello Java11 "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="keyword">String</span> repeat = <span class="string">"Java11"</span>.repeat(<span class="number">3</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(repeat);   <span class="comment">// "Java11Java11Java11"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="keyword">long</span> count = <span class="string">"A\nB\nC"</span>.lines().count();</span><br><span class="line">System.out.<span class="built_in">println</span>(count);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="集合工厂方法-since-9"><a href="#集合工厂方法-since-9" class="headerlink" title="集合工厂方法  @since 9"></a>集合工厂方法  @since 9</h3><p>自 Java 9 开始，Jdk 里面为集合（List/ Set/ Map）都添加了 of 和 copyOf 方法，它们两个都用来创建不可变的集合，来看下它们的使用和区别。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可变集合 List</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">list</span> = <span class="built_in">List</span>.of(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变集合 Set</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">set</span> = <span class="built_in">Set</span>.of(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可变集合 Map</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="built_in">Map</span>.of(<span class="string">"Java"</span>, <span class="number">1</span>, <span class="string">"Python"</span>, <span class="number">2</span>, <span class="string">"C"</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>注意：使用 of 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常，使用 Set.of() 不能出现重复元素、Map.of() 不能出现重复 key，否则回报 java.lang.IllegalArgumentException。</p><h4 id="List-of-和-Arrays-asList-区别-since-9"><a href="#List-of-和-Arrays-asList-区别-since-9" class="headerlink" title="List.of 和 Arrays.asList 区别 @since 9"></a>List.of 和 Arrays.asList 区别 @since 9</h4><p>1、Arrays.asList 返回可变的 list，而 List.of 返回的是不可变的 list</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; <span class="type">list</span> = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, null);</span><br><span class="line"><span class="type">list</span>.set(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// OK</span></span><br><span class="line">List&lt;Integer&gt; <span class="type">list</span> = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">list</span>.set(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// Fails</span></span><br></pre></td></tr></table></figure><p>2、Arrays.asList 支持 null，而 List.of 不行</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">null</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="built_in">List</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">null</span>); <span class="comment">// 异常：NullPointerException</span></span><br></pre></td></tr></table></figure><p>3、List.of 和 Arrays.asList 的 contains 方法对 null 处理不一样</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">list</span>.contains(<span class="built_in">null</span>); <span class="comment">// Return false</span></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Integer</span>&gt; <span class="built_in">list</span> = <span class="built_in">List</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">list</span>.contains(<span class="built_in">null</span>); <span class="comment">// 抛出NullPointerException异常</span></span><br></pre></td></tr></table></figure><p>4、Arrays.asList 的数组的修改会影响原数组</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[]<span class="built_in"> array </span>= &#123;1, 2, 3&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(array);</span><br><span class="line">array[1] = 10;</span><br><span class="line">System.out.println(list); // 输出 [1, 10, 3]</span><br><span class="line">Integer[]<span class="built_in"> array </span>= &#123;1, 2, 3&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br><span class="line">array[1] = 10;</span><br><span class="line">System.out.println(list); // 输出 [1, 2, 3]</span><br></pre></td></tr></table></figure><h4 id="使用-copyOf-方法创建不可变集合-since-10"><a href="#使用-copyOf-方法创建不可变集合-since-10" class="headerlink" title="使用 copyOf 方法创建不可变集合 @since 10"></a>使用 copyOf 方法创建不可变集合 @since 10</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可变集合 List</span></span><br><span class="line"><span class="keyword">var</span> immutableList = <span class="keyword">List</span>.of(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">var</span> copyImmutableList = <span class="keyword">List</span>.copyOf(immutableList);</span><br><span class="line">System.<span class="keyword">out</span>.println(immutableList == copyImmutableList);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常集合 List：用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类，所以 copyOf 方法又创建了一个新的实例，所以为false</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">list</span> = new ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">copy</span> = <span class="keyword">List</span>.copyOf(<span class="keyword">list</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">list</span> == <span class="keyword">copy</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>来看下它们的源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="built_in">List</span>&lt;E&gt; of(E... elements) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (elements.length) &#123; <span class="comment">// implicit null check of elements</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ImmutableCollections.emptyList();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.List12&lt;&gt;(elements[<span class="number">0</span>], elements[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ImmutableCollections.ListN&lt;&gt;(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="built_in">List</span>&lt;E&gt; copyOf(Collection&lt;? <span class="keyword">extends</span> E&gt; coll) &#123;</span><br><span class="line">    <span class="keyword">return</span> ImmutableCollections.listCopy(coll);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="built_in">List</span>&lt;E&gt; listCopy(Collection&lt;? <span class="keyword">extends</span> E&gt; coll) &#123;</span><br><span class="line">    <span class="keyword">if</span> (coll instanceof AbstractImmutableList &amp;&amp; coll.getClass() != SubList.<span class="keyword">class</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">List</span>&lt;E&gt;)coll;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">List</span>&lt;E&gt;)<span class="built_in">List</span>.of(coll.toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 copyOf 方法会先判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创建一个新的集合。</p><h3 id="Stream-增强-since-9"><a href="#Stream-增强-since-9" class="headerlink" title="Stream 增强 @since 9"></a>Stream 增强 @since 9</h3><p>Stream 是 Java 8 中的新特性，Java 9 开始对 Stream 增加了以下 4 个新方法。</p><p>（1) 增加单个参数构造方法，可为 null，此方法可以接收 null 来创建一个空流</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">count</span> = Stream.ofNullable(<span class="keyword">null</span>).<span class="keyword">count</span>();</span><br><span class="line">System.out.<span class="keyword">println</span>(<span class="keyword">count</span>);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>（2）增加 takeWhile 和 dropWhile 方法</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从开始计算，当 n &lt; 3 时就截止：此方法根据 Predicate 接口来判断如果为 true 就取出来生成一个新的流，只要碰到 false 就终止，不管后边的元素是否符合条件。</span></span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        .takeWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect.toString()); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦 n &lt; 3 不成立就开始计算：此方法根据 Predicate 接口来判断如果为 true 就丢弃，只要碰到 false 就来生成一个新的流，不管后边的元素是否符合条件。</span></span><br><span class="line">List&lt;Integer&gt; collect1 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">        .dropWhile(n -&gt; n &lt; <span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect1.toString());    <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>（3）iterate 重载</p><p>以前使用 iterate 方法生成无限流需要配合 limit 进行截断</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List<span class="variable">&lt;Integer&gt;</span> collect2 = Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .<span class="keyword">limit</span>(<span class="number">5</span>)</span><br><span class="line">        .collect(Collectors.<span class="keyword">to</span>List());</span><br><span class="line">System.<span class="keyword">out</span>.println(collect2.<span class="keyword">to</span>String());    // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>现在重载后这个方法增加了个判断参数</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List<span class="variable">&lt;Integer&gt;</span> collect3 = Stream.iterate(<span class="number">1</span>, i -&gt; i <span class="variable">&lt;= 5, i -&gt;</span> i + <span class="number">1</span>)</span><br><span class="line">        .collect(Collectors.<span class="keyword">to</span>List());</span><br><span class="line">System.<span class="keyword">out</span>.println(collect3.<span class="keyword">to</span>String());    // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="Optional-增强-since-9"><a href="#Optional-增强-since-9" class="headerlink" title="Optional 增强 @since 9"></a>Optional 增强 @since 9</h3><p>Opthonal 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换成一个 Stream，或者当一个空 Optional 时给它一个替代的。</p><p>（1）stream()：stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream，否则返回一个空的 Stream（Stream.empty()）。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回Optional值的流</span></span><br><span class="line"><span class="built_in">Stream</span>&lt;<span class="keyword">String</span>&gt; stream = Optional.of(<span class="string">"Java 11"</span>).stream();</span><br><span class="line">stream.forEach(System.out::<span class="built_in">println</span>);    <span class="comment">// Java 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回空流</span></span><br><span class="line"><span class="built_in">Stream</span>&lt;Object&gt; stream2 = Optional.empty().stream();</span><br><span class="line">stream2.forEach(System.out::<span class="built_in">println</span>);    <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>（2）ifPresentOrElse(Consumer&lt; ? super T&gt; action, Runnable emptyAction)：ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">Integer</span>&gt; <span class="keyword">optional</span> = <span class="keyword">Optional</span>.of(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">optional</span>.ifPresentOrElse(x -&gt; System.<span class="keyword">out</span>.println(<span class="string">"Value: "</span> + x),</span><br><span class="line">        () -&gt; System.<span class="keyword">out</span>.println(<span class="string">"Not Present."</span>));    // <span class="keyword">Value</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">optional</span> = <span class="keyword">Optional</span>.empty();</span><br><span class="line"><span class="keyword">optional</span>.ifPresentOrElse(x -&gt; System.<span class="keyword">out</span>.println(<span class="string">"Value: "</span> + x),</span><br><span class="line">        () -&gt; System.<span class="keyword">out</span>.println(<span class="string">"Not Present."</span>));    //Not <span class="built_in">Present</span>.</span><br></pre></td></tr></table></figure><p>（3）or(Supplier&lt; ? extends Optional&lt; ? extends T&gt;&gt; supplier)：如果值存在，返回 Optional 指定的值，否则返回一个预设的值。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Optional</span>&lt;<span class="keyword">String</span>&gt; optional1 = <span class="keyword">Optional</span>.of(<span class="string">"Mahesh"</span>);</span><br><span class="line">Supplier&lt;<span class="keyword">Optional</span>&lt;<span class="keyword">String</span>&gt;&gt; supplierString = () -&gt; <span class="keyword">Optional</span>.of(<span class="string">"Not Present"</span>);</span><br><span class="line">optional1 = optional1.or(supplierString);</span><br><span class="line">optional1.ifPresent(x -&gt; System.out.println(<span class="string">"Value: "</span> + x));    // <span class="keyword">Value</span>: Mahesh</span><br><span class="line">optional1 = <span class="keyword">Optional</span>.empty();</span><br><span class="line">optional1 = optional1.or(supplierString);</span><br><span class="line">optional1.ifPresent(x -&gt; System.out.println(<span class="string">"Value: "</span> + x));    // <span class="keyword">Value</span>: <span class="keyword">Not</span> Present</span><br></pre></td></tr></table></figure><h3 id="标准-HTTP-Client-升级-since-11"><a href="#标准-HTTP-Client-升级-since-11" class="headerlink" title="标准 HTTP Client 升级 @since 11"></a>标准 HTTP Client 升级 @since 11</h3><p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。</p><p>Java 11 中的新 Http Client API，提供了对 HTTP/2 等业界前沿标准的支持，同时也向下兼容 HTTP/1.1，精简而又友好的 API 接口，与主流开源 API（如：Apache HttpClient、Jetty、OkHttp 等）类似甚至拥有更高的性能。与此同时它是 Java 在 Reactive-Stream 方面的第一个生产实践，其中广泛使用了 Java Flow API，终于让 Java 标准 HTTP 类库在扩展能力等方面，满足了现代互联网的需求，是一个难得的现代 Http/2 Client API 标准的实现，Java 工程师终于可以摆脱老旧的 HttpURLConnection 了。</p><p>同步请求会阻止当前线程</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request = HttpRequest.<span class="keyword">new</span><span class="type">Builder</span>()</span><br><span class="line">        .uri(URI.create(<span class="string">"https://www.baidu.com/"</span>))</span><br><span class="line">        .GET()</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">var</span> client = HttpClient.<span class="keyword">new</span><span class="type">HttpClient</span>();</span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line">HttpResponse&lt;<span class="keyword">String</span>&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">System.out.println(response.body());</span><br></pre></td></tr></table></figure><p>异步请求不会阻止当前线程，而是返回 CompletableFuture 来进行异步操作</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = HttpClient.<span class="keyword">new</span><span class="type">HttpClient</span>();</span><br><span class="line"><span class="keyword">var</span> request = HttpRequest.<span class="keyword">new</span><span class="type">Builder</span>()</span><br><span class="line">        .uri(URI.create(<span class="string">"https://www.baidu.com/"</span>))</span><br><span class="line">        <span class="comment">// 省略.GET()，因为它是默认的请求方法。</span></span><br><span class="line">        <span class="comment">// .GET()</span></span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 异步</span></span><br><span class="line">client.sendAsync(request, HttpResponse.BodyHandlers.ofString())</span><br><span class="line">        .thenApply(HttpResponse:<span class="type"></span>:body)</span><br><span class="line">        .thenAccept(System.out:<span class="type"></span>:println)</span><br><span class="line">        .join();</span><br></pre></td></tr></table></figure><h3 id="简化启动单个源代码文件的方法-since-11"><a href="#简化启动单个源代码文件的方法-since-11" class="headerlink" title="简化启动单个源代码文件的方法 @since 11"></a>简化启动单个源代码文件的方法 @since 11</h3><p>Java 11 版本中最令人兴奋的功能之一是增强 Java 启动器，使之能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中。</p><p>如今单文件程序在编写小实用程序时很常见，特别是脚本语言领域。从中开发者可以省去用 Java 编译程序等不必要工作，以及减少新手的入门障碍。</p><p>举个例子，写一个类文件 HelloWorld.java</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前简化启动单个源代码文件需要这样运行</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">javac </span>HelloWorld.<span class="keyword">java</span></span><br><span class="line"><span class="keyword">$ </span><span class="keyword">java </span>HelloWorld</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>现在只需要这样<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">java </span>HelloWorld.<span class="keyword">java</span></span><br><span class="line"><span class="keyword">Hello </span>World</span><br></pre></td></tr></table></figure></p><h2 id="更多新特性"><a href="#更多新特性" class="headerlink" title="更多新特性"></a>更多新特性</h2><ul><li>Flow API for reactive programming</li><li>Java Module System</li><li>Application Class Data Sharing</li><li>Dynamic Class-File Constants</li><li>Java REPL (JShell)</li><li>Flight Recorder</li><li>Unicode 10</li><li>G1: Full Parallel Garbage Collector</li><li>ZGC: Scalable Low-Latency Garbage Collector</li><li>Epsilon: No-Op Garbage Collector</li><li>Deprecate the Nashorn JavaScript Engine</li><li>…</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://segmentfault.com/a/1190000016537503#articleHeader5" target="_blank" rel="noopener">Java 11 正式发布，这 8 个逆天新特性教你写出更牛逼的代码</a><br>[2]. <a href="https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html" target="_blank" rel="noopener">Java 11 新特性介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Java 11 已于 2018 年 9 月 25 日正式发布，Java 开发团队为了加快的版本迭代、跟进社区反馈，Java 的版本发布周期调整为每六个月一次——即每半年发布一个大版本，每个季度发布一个中间特性版本，并且做出不会跳票的承诺。通过这样的方式，Java 开发团队能够将一些重要特性尽早的合并到 Java Release 版本中，以便快速得到开发者的反馈，避免出现类似 Java 9 发布时的两次延期的情况。&lt;/p&gt;
&lt;p&gt;本文主要针对 Java 9 - Java 11 中的新特性展开介绍，让您快速了解 Java 9 - Java 11 带来的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.maoning.vip/categories/Java/"/>
    
    
      <category term="Java11" scheme="https://blog.maoning.vip/tags/Java11/"/>
    
      <category term="Java9" scheme="https://blog.maoning.vip/tags/Java9/"/>
    
      <category term="Java10" scheme="https://blog.maoning.vip/tags/Java10/"/>
    
  </entry>
  
  <entry>
    <title>2019 年度总结</title>
    <link href="https://blog.maoning.vip/archives/f88003a.html"/>
    <id>https://blog.maoning.vip/archives/f88003a.html</id>
    <published>2020-01-22T03:26:30.000Z</published>
    <updated>2020-03-23T03:34:45.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在是 2020 年 1 月 22 日，戊戌狗年，腊月十七，星期三，也是今年我在公司上班的最后一天。临近年末，各个项目已经陆续的开始封版，我也开始光明正大的摸鱼了，终于体会到 “摸鱼一时爽，一直摸鱼一只爽”。哈哈哈哈哈，开玩笑。按道理来说，本来 2019 年度总结，我应该在 2019 年 12 月 31 日写完，然后在 2020 年 1 月 1 日发表出来，这样的节奏，生活才有仪式感。那么为什么不是这样的节奏进行呢？因为我的拖延症又又又犯了，我可太难了 (┬＿┬)。在 2019 年年末没有完成年终总结，本来打算就不写了。后来想想还是打算写一下，一方面是因为之前从来没有写过年终总结，另一方面是今年我的生活还是发生了很大的变化，是值得纪念的一年，因此还是想把我的 2019 年总结一下。那么，我就开始回顾一下我的 2019 年。</p><a id="more"></a><h2 id="2019-人生小目标"><a href="#2019-人生小目标" class="headerlink" title="2019 人生小目标"></a>2019 人生小目标</h2><p><img src="/media/15795992619147/20200121183403.png" alt="2019 人生小目标，2019.12.31"></p><p>上图是我 2018 年为我 2019 年定的小目标以及 2019 年我对这些目标的完成情况，我就从这么小目标进行展开，来详细的回顾一下我的 2019 年发生的点点滴滴。</p><h3 id="不要停止学习"><a href="#不要停止学习" class="headerlink" title="不要停止学习"></a>不要停止学习</h3><p>我好想是一个从来不喜欢看书的孩子。上学的时候，看书、背书是为了考试，好像只是为了应付考试，去死记硬背。从而我的短期记忆力好像很强，但是考试考完之后，所有背的东西就选择性一下子忘光了，我想，这可能就是我学不好英语的主要原因吧！上大学的时候，除了课本以外，陆陆续续的看了几本书，那时，好像真的是为了 “文艺” 去看书(┬＿┬)。工作后的第一年安顿生活，第二年选择安逸活着，也没有动力去看书。而 2019 年的我，好像除了应付面试，死记硬背面试题；以及阅读《Effective Java 中文版（第 3 版）》、《Redis 设计与实现》 这两本书籍以外并没有刻意的去学习，与我年初定下的目标还有很大的差距，因此这项我给我自己打未完成。</p><h3 id="坚持每天运动"><a href="#坚持每天运动" class="headerlink" title="坚持每天运动"></a>坚持每天运动</h3><p>说是每天运动，可能是我当初设置目标的表达不够准确，应该是每个星期坚持跑步 2 次。2019 年，我一般都是在星期一、三晚上到家后都会去马路上进行长跑，虽然有时候也会因为某些原因中断掉，但总算是踉踉跄跄的坚持下来了。长跑可能是我比较喜欢的运动，也是我坚持最长久的一项运动。高中的时候上完晚自习，我会去操场上跑上几圈，那时真的是单纯的释放压力；后来，我发现我特别享受跑步的过程，我享受定下目标后，一步一步接近目标那种感觉，所以跑步渐渐成为了我的爱好之一，并且一直坚持着。2019 年我共跑步 372.59 公里，跑步时长 35:06:12，共跑步 58 次，算勉强完成当时定下的目标。其实，当初我定这个目标的主要目的，就是督促自己坚持锻炼，我个人认为，出门在外照顾好自己，就是对父母最大的回报。</p><p><img src="/media/15795992619147/20200122105836.png" alt="坚持每天运动，2019.12.31"></p><h3 id="懂得虚心听取别人意见"><a href="#懂得虚心听取别人意见" class="headerlink" title="懂得虚心听取别人意见"></a>懂得虚心听取别人意见</h3><p>就我个人而言，我还是一个比较固执的人，很多时候，自己想好的事情，很容易一条道走到黑，听不进别人的意见。当初定下这个目标的想法就是想改改自己这个坏毛病，但是，一年下来，我发现，这东西是性格方面的原因，一时半会儿很难去改变，这一小目标也没有达成。但是，我意识到自己的缺点，我会在以后的生活着，尝试着慢慢去改正。</p><h3 id="掌握好自己情绪"><a href="#掌握好自己情绪" class="headerlink" title="掌握好自己情绪"></a>掌握好自己情绪</h3><p>我希望所有的事情能够一件一件来，等我处理完这件事后，下一件事情在过来。当在生活中，经常会出现，所有糟糕的、不糟糕的事情突然一下子找上你。面对这种情况，我就有一种“心有余而力不足”的感觉。用程序员的方式表示，我就好像是一个单线程处理的程序，没有同时处理多个请求的能力，面对并发的情况，一下子会导致程序崩溃。成年人的崩溃可能只来自瞬间，当很多事情堆在一起，我往往会有一种手足无措的感觉，自己的情绪很容易奔溃。接下来的一年，我希望自己在任何情况下处理事情都游刃有余，掌握好自己情绪，以正确积极的态度面对生活中发生的事情。</p><h3 id="做自己觉得应该要做的事情"><a href="#做自己觉得应该要做的事情" class="headerlink" title="做自己觉得应该要做的事情"></a>做自己觉得应该要做的事情</h3><p>2019 年我觉得我做的最好的事情就是做自己觉得应该要做的事情。比如说，我觉得我应该要换一份工作，那么背面试题、面试，这些事情都在为我换工作而努力；比如说，我觉得我应该要换一处住所，那么找房子、搬家，这些事情都在为我换处所而努力；比如说，我觉得我应该要坚持锻炼，那么每个星期一三跑步，这些事情都在为我坚持锻炼而努力；比如说，我觉得我应该会游泳，那么每个星期六早上去练习，这些事情都在为我学习游泳而努力；比如说，我觉得我应该会做饭…….这也是我觉得今年和往年以来最大的区别，相比往年的庸庸碌碌，今年的我好像更加充实了。</p><h3 id="跨出让你舒适的区域"><a href="#跨出让你舒适的区域" class="headerlink" title="跨出让你舒适的区域"></a>跨出让你舒适的区域</h3><p>回顾我们的工作生活，会发现，只要不是太傻的人，一般经过 3 个月左右的训练，通常能较好的适应自己的工作角色。因此，我们在公司的框架下工作，就会过得比较舒服，但这种状态是比较危险的。因为，一旦哪天突然掉到了地上，比如公司倒闭了，又或者被公司开除了，我们往往会变得无所适从。因此，为了跨出自己呆了近两年你的舒适区，我想在 2019 年我应该做出一些改变。为什么说是近两年的舒适区呢？从我大学毕业到 2019 年年初，刚好近两年的时间。大学刚毕业的时候，由于跨专业找开发的工作，找工作一直不顺利，因此也没有定下到底住哪里。大学室友看到我的情况说，要不你先住我这里，等找到工作后再说？我一口就答应了，根本没有给室友反悔的机会。我是真的太懒，如果有现成的住所，我是不会拒绝的。直到后来，我找到工作也没有再次换住所，而是选择安心住下了。兜兜转转过了近 2 年，舒适的居住环境，熟悉的工作环境，都快让自己忘记了自己已经是一个工作近 2 年的社会人了。莫名的危机感顿时笼罩了自己，从那一刻起，自己就决定要换一个生活环境、换一个工作环境。</p><h3 id="一定要改掉拖延症"><a href="#一定要改掉拖延症" class="headerlink" title="一定要改掉拖延症"></a>一定要改掉拖延症</h3><p>拖延症！拖延症！！拖延症！！！我该拿你怎么办呀。2019 年自己还是如愿以偿的没有改掉拖延症，很多事情都一定要到了非做不可的地方才回去执行。我个人感觉我可能不是单纯的拖延症，也有可能只是单纯的懒，不想做事情，然后拿拖延症当借口。我可太难了，明明知道这个习惯不好，可自己就是一直改不掉。2019 年我没有能如愿的改掉拖延症，希望 2020 年的我能够再接再厉，客服困难，抢抓机遇，迎接挑战，坚定信心把工作做好，坚决完成好脱贫攻坚的各项任务……. 坚决完成改掉拖延症的坏习惯。</p><h3 id="改掉不良的爱好习惯"><a href="#改掉不良的爱好习惯" class="headerlink" title="改掉不良的爱好习惯"></a>改掉不良的爱好习惯</h3><p>其实从上面很多没有完成的目标中，可以发现我其实有很多坏习惯：懒、拖延症、固执、依赖他人、脾气不好等等，好像也挺多的。但是这些坏习惯我能改掉的却是少之又少。我觉得养成一个习惯或者戒掉一个习惯都是需要长期坚持的过程，很可惜，2019 年的我并没有坚持好，因此很多坏习惯还在深深影响着我自己。但是我觉得，如果我能意识到这些坏习惯，那么在往后的日子中，我也会慢慢的改正这些坏习惯的，是吧！</p><h3 id="监督自己，把握时间养成习惯"><a href="#监督自己，把握时间养成习惯" class="headerlink" title="监督自己，把握时间养成习惯"></a>监督自己，把握时间养成习惯</h3><p>这一个目标好像和拖延症那个目标有些冲突了。按道理来说，拖延症的目标我没有完成，这个目标从性质上也应该是不完成状态啊。现在的我也不知道当时的我为什么给这个目标打上了对勾，可能是我坚持阅读了几本技术书籍的原因，可能是我坚持写博客的原因，可能是我每个星期坚持打扫房间的原因，可能是我每个星期坚持跑步的原因，可能是我每个星期六坚持做饭的原因，可能是我每个星期六坚持游泳的原因……. 哦吼，没想到，我的 2019 还听丰富的吗。当然，这里的丰富只是与我的 2018 相比。这么一看，可能当时我就是因为这些原因，才会把这项目标打上对勾的，起码，我对 2019 还是满意的。</p><h3 id="跑一次-2-个小时内的半程马拉松"><a href="#跑一次-2-个小时内的半程马拉松" class="headerlink" title="跑一次 2 个小时内的半程马拉松"></a>跑一次 2 个小时内的半程马拉松</h3><p>2019 年 11 月 17 日，我收到了这样的一条短信 “【微马城市】尊敬的陈星星：祝贺您完成了祥生 ·2019 诸暨西施马拉松。项目: 半程马拉松，参赛号: C3254，成绩 02:00:03，净时成绩: 01:57:52。此成绩仅供参考最终解释权归组委会所有。” 是的，我完成了人生第二次半程马拉松，也是我人生第一次半程马拉松跑进 2 个小时。跑步一直是我最喜欢的一项运动，而在马拉松中取得更好的 PB 更是我追求的目标。从报名到比赛，为了在接下来的半程马拉松中跑进 2 小时，我前前后后准备了 2 个月的时间。从每个星期坚持跑 2 次 5 公里，到每个星期坚持跑 2 次 7 公里，到每个星期坚持跑 2 次 10 公里，到每个星期坚持跑 2 次 14 公里，慢慢提升自己跑量。终于在诸暨西施马拉松我实现了对自己的超越，给自己交了一份满意的答卷。接下来，我的目标是 2020 年完成全程马拉松，为了达成这个目标，我给自己定下了，每个月跑量不少于 100 公里的目标。希望 2020 年的我能够为了全程马拉松，每个月都坚持达成目标。</p><p><img src="/media/15795992619147/20200311101853.png" alt="2019 诸暨西施马拉松，2019.11.17"></p><h3 id="学习游泳"><a href="#学习游泳" class="headerlink" title="学习游泳"></a>学习游泳</h3><p>如果说 2019 年，我做的最自豪的一件事，我想那应该是学会游泳。当初为什么要学习游泳的目的我忘记了，可能是单纯为了打发时间，可能是为了寻找一个娱乐项目…… 但是，当我迈入泳池开始扑腾的时候，我就知道我肯定会喜欢这项运动。为了更快的学会游泳，我从网上找游泳教程，然后每个星期坚持去泳池扑腾，就这样扑腾了进 2 个月时间，我终于学会了蛙泳，可能是我真的没有运动天赋，但是架不住我喜欢游泳啊。而且，这期间发生了非常有意思的事。和我同期的一个同事，听说我在学习游泳，然后就每个星期和我一起学习游泳，他还带上了我们公司另外的一个小伙伴，也就是我们的小师傅。自从有了小师傅，我们学习游泳的进度飞速的提升，可太幸福了。每次，游完泳我们还一起相约吃自助餐。我终于体会到在老公司那种，同事不仅仅是同事，而是一个可以交心的小伙伴的感觉，这种感觉还是非常神奇的，给我普通平凡的工作生活添加了些许色彩。</p><h3 id="爬华山"><a href="#爬华山" class="headerlink" title="爬华山"></a>爬华山</h3><p>如果说 2019 年我做的最自豪的一件事是学习游泳，那么，2019 年我最遗憾的一件事就是没有爬华山了。游遍中华五岳是我大学时的一个梦想，但是大学时间游完泰山，这个计划就搁置了，更多的原因还是因为经济问题，大学时的我们经济并不富裕。后来，我们工作后，更多的是时间上的不富裕。当时这个目标定下的时候，是我和另外两个基友，因此，我们完成这个目标也因该是我们三个。但是，因为时间难以协调，这个目标在 2019 年就被耽搁了。很遗憾，因为换工作的原因，在 2019 年不能去看看祖国的大好河山。</p><h3 id="换一份工作"><a href="#换一份工作" class="headerlink" title="换一份工作"></a>换一份工作</h3><p>上面提到了我换一个工作的强烈的意愿主要是跨出舒适的区域，为了这个目标，背面试题、投简历、面试、被拒，这四件事好像成了 2019 年上半年主旋律。面试的不顺一度让我非常怀疑自己能力，好在公司小伙伴的安慰以及并非裸辞的保障让我并没有那么焦虑。整个换工作的经历磕磕绊绊，因为工作经验的不足，导致面试机会的次数并不多。经历了长达 2 个多月的准备以及面试，在 2019 年 5 月 27 日终于如期的进入了新公司。我也彻底的告别了毕业后的第一家公司，从 2017 年 7 月 19 日至 2019 年 5 月 24 日，674 天，感谢魔蝎让我学会了在社会中跌跌撞撞的成长。</p><h3 id="学会做菜"><a href="#学会做菜" class="headerlink" title="学会做菜"></a>学会做菜</h3><p>其实学习做菜是我一直以来的目标，在 2018 年坚持过一段时间后就逐渐放弃了，可能是因为自己做的实在太难吃了吧。(┬＿┬) 2019 年，在住所和工作都安顿好后，学习做菜的念头有浮现在我的脑海中了。我是这么认为的，出门在外，学会做饭起码饿不死自己。面对自己越来越熟练的厨艺，我也越发的高兴起来，我又学会了一项生存技能。</p><p><img src="/media/15795992619147/20200323105402.png" alt="2019 菜谱大全，2019.12.31"></p><h3 id="带父母去体检"><a href="#带父母去体检" class="headerlink" title="带父母去体检"></a>带父母去体检</h3><p>三十而立，四十不惑，五十知天命，人过半百，在这个年龄，我们的父母，已经很苍老了。记忆中父母的身体总是很硬朗，能够为我们这个小家撑起半边天。从高中开始，我回到浙江读书，算算日子，我离开父母身边已经有近十年的时间了。虽然期间，也会有寒假、暑假的时间回到父母身边，但是生活的时间总是不回太长。当我工作后，父母因为家里的一些事情陆陆续续回来过一段时间，我才发现，父母是真的开始变老了。最明显的是，白头发开始变多了，面容也苍老了许多，这时，作为儿女就有一种无力感。我想，我能做的就是定期带父母去体检，保证他们身体的无恙，为了不在他们身边的自己心安。</p><p><img src="/media/15795992619147/20200323111307.png" alt="父母体检，2019.08.24"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与其说是 2019 年度总结，更像是 2019 年度流水账。但是 2019 年对于我来说，还是变化比较大的一年，也是我比较满意的一年，起码日子不会那么碌碌无为了。因为有了这么多需要实现的目标，生活而变得更加充实。</p><p>既然有了 2019 年人生小目标，按照历史传统照例当然也存在 2020 年人生小目标，接下来就是明年的 TODO-LIST：</p><p><img src="/media/15795992619147/20200311112542.png" alt="2020 人生小目标，2020.01.01"></p><p>希望 2020 年的我，再接再厉，不要因为经历的太少，鸡毛蒜皮都是烦恼。愿新年，胜旧年。2020，z.z.z — fating! </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在是 2020 年 1 月 22 日，戊戌狗年，腊月十七，星期三，也是今年我在公司上班的最后一天。临近年末，各个项目已经陆续的开始封版，我也开始光明正大的摸鱼了，终于体会到 “摸鱼一时爽，一直摸鱼一只爽”。哈哈哈哈哈，开玩笑。按道理来说，本来 2019 年度总结，我应该在 2019 年 12 月 31 日写完，然后在 2020 年 1 月 1 日发表出来，这样的节奏，生活才有仪式感。那么为什么不是这样的节奏进行呢？因为我的拖延症又又又犯了，我可太难了 (┬＿┬)。在 2019 年年末没有完成年终总结，本来打算就不写了。后来想想还是打算写一下，一方面是因为之前从来没有写过年终总结，另一方面是今年我的生活还是发生了很大的变化，是值得纪念的一年，因此还是想把我的 2019 年总结一下。那么，我就开始回顾一下我的 2019 年。&lt;/p&gt;
    
    </summary>
    
      <category term="生活杂谈" scheme="https://blog.maoning.vip/categories/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="年度总结" scheme="https://blog.maoning.vip/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
      <category term="2019" scheme="https://blog.maoning.vip/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（七）：透彻理解 Java 并发编程</title>
    <link href="https://blog.maoning.vip/archives/bdbfedfb.html"/>
    <id>https://blog.maoning.vip/archives/bdbfedfb.html</id>
    <published>2020-01-20T03:14:28.000Z</published>
    <updated>2020-10-12T08:35:40.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大，大量的时间都花费在磁盘 I/O、网络通信和数据库访问上。因此，让计算机同时处理几项任务是充分利用计算机处理器的能力最有效的手段。</p><p>服务端是 Java 语言最擅长的领域之一，而线程是 Java 语言中不可或缺的重要功能，它们能使复杂的异步代码变得更加简单，从而极大地简化了复杂系统的开发。此外，要想充分发挥多处理器的强大计算能力，最简单的方式就是使用线程。随着处理器数量的持续增长，如何高效地使用并发正变得越来越重要。</p><p>本章作为 Java 并发编程的开篇，首先大致介绍了一下线程以及线程安全的概念，然后详细介绍了一下 Java 内存模型，最后针对常见的 Java 并发编程进行问与答。</p><h2 id="线程原理和概念"><a href="#线程原理和概念" class="headerlink" title="线程原理和概念"></a>线程原理和概念</h2><p>当代操作系统，大多数都支持多任务处理。对于多任务的处理，有两个常见的概念：进程和线程。</p><p><strong>进程</strong> 是程序执行时的一个实例，是操作系统进行资源分配和调度的一个独立单位，这里的资源包括 CPU、内存、IO、磁盘、文件句柄以及安全证书等，进程之间切换时，操作系统需要分配和回收这些资源，所以其开销相对较大（远大于线程切换）。</p><p><strong>线程</strong> 也被称为轻量级进程。在大多数现代操作系统中，都是以线程为基本的调度单位。线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。多个线程在切换时，CPU 会根据其优先级和相互关系分配时间片。除时间切换之外，线程切换时一般没有其它资源（或只有很少的内存资源）需要切换，所以切换速度远远高于进程切换。</p><p>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程，一个进程至少有一个线程。进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度（线程是 CPU 调度的基本单位）。</p><p>实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p><p>协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了后，要主动通知系统切换到另外一个线程上。</p><p>抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>Java 语言定义了 5 种线程状态，在任何一个时间点，一个线程只能有且只有其中的一种状态，这 5 种状态分别如下：</p><ul><li><p>新建（New）：创建后尚未启动的线程处于这种状态。</p></li><li><p>运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能在等待着 CPU 为它分配执行时间。</p></li><li><p>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被去其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：</p><p>1、没有设置 Timeout 参数的 Object.wait() 方法。</p><p>2、没有设置 Timeout 参数的 Thread.join() 方法。</p><p>3、LockSupport.park() 方法。</p></li><li><p>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p><p>1、Thread.sleep() 方法。</p><p>2、设置了 Timeout 参数的 Object.wait() 方法。</p><p>3、设置了 Timeout 参数的 Thread.join() 方法。</p><p>4、LockSupport.parkNanos() 方法。</p><p>5、LockSupport.parkUntil() 方法。</p></li><li><p>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与 “等待状态” 的区别是：“阻塞状态”在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而 “等待状态” 则是等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，程序将进入这种状态。</p></li><li><p>结束（Terminated）：已终止线程的状态，线程已经结束执行。</p></li></ul><p><img src="/media/15942751192447/271641437997147.jpg" alt="Java 线程状态"></p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一堆上分配对象，这就需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。</p><p>《Java Concurrency In Practice》的作者 Brian Goetz 对 “线程安全” 有一个比较恰当的定义：“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。</p><p>多个线程访问了相同的资源，向这些资源做了写操作，对执行顺序有要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>临界区：incr 方法内部就是临界区域，关键部分代码的多线程并发执行，会对执行结果产生影响。即多线程情况下，会发生线程安全问题的区域。</p><p>竞态条件：可能发生在临界区域内的特殊条件。多线程执行 incr 方法中的 i++ 关键代码时，产生了竞态条件。即临界区内，引发线程安全问题的代码。</p><h3 id="Java-语言中的线程安全"><a href="#Java-语言中的线程安全" class="headerlink" title="Java 语言中的线程安全"></a>Java 语言中的线程安全</h3><p>按照线程安全的 “安全程度” 由强至弱来排序，我们可以将 Java 语言中各种操作共享的数据分为以下 5 类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>在 Java 语言中，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。</p><p>Java 语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任务影响才行。</p><p>在 Java API 中符合不可变要求的类型，包括：String、枚举类、java.lang.Number 的部分子类（如 Long、Double 等数值包装类型）。</p><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>绝对线程安全是指：不管运行环境如何，调用者都不需要任何额外的同步措施。在 Java API 中标注自己是线程安全的类，大多数都不是绝对线程安全。</p><p>例如，Vector 的 get()、remove()、和 size() 方法都是同步的，但是在多线程的环境中，如果不在方法调用端做额外的同步措施的话，一个线程循环读取元素，一个线程循环删除元素，这种场景仍然是不安全的，因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号 i 已经不再可用的话，再用 i 访问数据就会抛出一个 ArrayIndexOutOfBoundsException 。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、Hashtable、Collections 的 synchronizedCollection() 方法包装的集合等。</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</p><p>Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 Hashtable 相对应的集合类 ArrayList 和 HashMap 等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特征，线程对立这种排斥多线程的代码很少出现，而且通常都是有害的，应当尽量避免。</p><p>一个线程对立的例子是 Thread 类的 suspend() 和 resume()，如果有两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。常见的线程对立的操作还有 System.setIn()、System.setOut() 和 System.runFinalizersOnExit() 等。</p><h3 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><p>互斥同步（Mutual Exclusion &amp; Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号新的时候）线程使用。而互斥实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，互斥同步这 4 个字里面，互斥是方法，同步是目的。</p><h5 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h5><p>在 Java 中，最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指定了对象的参数，那就是这个对象的 reference；如果没有明确指定，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 Class 对象来作为锁对象。</p><p>根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit 指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，知道对象锁被另外一个线程释放为止。</p><h5 id="ReentrantLock-重入锁"><a href="#ReentrantLock-重入锁" class="headerlink" title="ReentrantLock 重入锁"></a>ReentrantLock 重入锁</h5><p>java.util.concurrent（J.U.C）包中的重入锁（ReentrantLock）在基本用法上与 synchronized 很相似，他们都具备一样的线程重入特征，只是代码写法上有点区别，一个表现为 API 层面的互斥 lock() 和 unlock() 方法配合 try/finally 语句块来完成），另一个表现为原声语句层面的互斥锁。与 synchronized 相比 ReentrantLock 增加了一些高级功能：等待可中断、可实现公平锁、以及锁可以绑定多个条件：</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁是指多个线程在等待同一锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现 一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而 ReentrantLock 则无须这样做，只需要多次调用 newCondition() 方法即可。</li></ul><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都需要进行加锁、用户态核心态转换 <sup>[1]</sup>、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，基于冲突检测的乐观并发策略为我们提供了另外一个选择。通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断重试，直到成功为止），这种乐观的并发策略的许多时间都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>“硬件指令的发展” 使操作和冲突检测这两个步骤具备原子性，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap，下文称 CAS）</li><li>加载链接 / 条件存储（Load-Linked/Store-Conditional，下文称 LL/SC）</li></ul><p>CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p><p>在 JDK 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 conpareAndSwapInt() 和 conpareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法调用的过程，或者可以认为是无条件内联进去了。</p><p>由于 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnsafe() 的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java API 来间接使用它，如 J.U.C 包里面的整数原子类，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p><p>尽管 CAS 看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且 CAS 从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然为，但是这段期间它的值曾经被改成了 B，后来又被改回为 A，那么 CAS 操作就会误认为它从来没有被改变过。这个漏洞称为 CAS 操作的 “ABA” 问题。J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证 CAS 的正确性。不过目前来说这个类比较鸡肋，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步的可能会比原子类更高效。</p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p><p>可重入代码（Reentrant Code）：可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特征，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入行：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p><p>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>Java 语言中，如果一个变量要被多线程访问，可以使用 volatile 关键字声明它为 “易变的”；如果一个变量要被某个线程独享，可以通过 java.lang.ThreadLocal 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 ThreadLocalMap 对象，这个对象存储了一组以 ThreadLocal.threadLocalHashCode 为键，以本地线程变量为值的 K-V 值对，ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的 threadLocalHashCode 值，使用这个值就可以在线程 K-V 值对中找回对应的本地线程变量。</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h3 id="现代计算机的内存模型"><a href="#现代计算机的内存模型" class="headerlink" title="现代计算机的内存模型"></a>现代计算机的内存模型</h3><p>“让计算机并发执行若干个运算任务” 与 “更充分地利用计算机处理的效能” 之间关系的复杂性来源是绝大数的运算任务都不可能只靠处理器 “计算” 就能完成，处理器至少要于内存交互，如读取运算数据、存储运算结果等。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现在计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲；将运算需要使用到的数据复制到缓冲中，让运算能够快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无需等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。</p><p><img src="/media/15942751192447/640.jpg" alt="现代计算机的内存模型"></p><p>除了增加高速缓存之外，为了使得处理器内部的单元能够尽量充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的（As-If-Serial 语义 <sup>[2]</sup>），但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化 <sup>[3]</sup>。</p><h3 id="JMM（Java-Memory-Model）"><a href="#JMM（Java-Memory-Model）" class="headerlink" title="JMM（Java Memory Model）"></a>JMM（Java Memory Model）</h3><p>由于主流程序语言（如 C/C++ 等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此某些场景就必须针对不同的平台来编写程序。</p><p>Java 虚拟机规范中定义了一种 Java 内存模型（Java Memory Model，JMM），JMM 是一种基于计算机内存模型（定义了共享内存系统中多线程程序读写操作行为的规范），屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。保证共享内存的原子性、可见性、有序性。</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java 内存模型的主要目标是定义程序中中各种变量（实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数）的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。</p><p>Java 内存模型规定了所有的变量都存储于主内存（Main Memory），每条线程还有自己的工作内存（Working Memory），线程的工作内存保留了被线程使用的变量的主内存副本拷贝。线程对变量的所有的操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="/media/15942751192447/v2-6e6ca5c13adc8f3b0c7d7c76b2d2a299_1440w.jpg" alt="Java Menory Model"></p><p>注意：这里所讲的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两则基本是没有关系的。</p><h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了一下 8 中操作来完成：</p><ul><li><p>lock（锁定）：作用于主内存的变量，它把一个变量表示为一条线程独占的状态。</p></li><li><p>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其它线程锁定。</p></li><li><p>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</p></li><li><p>load（载入）：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。</p></li><li><p>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个变量的值的字节码指令将会执行这个操作。</p></li><li><p>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码执行时执行这个操作。</p></li><li><p>store（存储）：作用于工作内存的变量，它把工作内存中的变量的值传送到主内存中，以便随后的 write 操作使用。</p></li><li><p>write（写入）：作用于主内存的变量，它把 store 操作从工作内存得到的变量的值放入主内存的变量中。</p></li></ul><p><img src="/media/15942751192447/731716-20170217120319488-552514268.png" alt="JMM 定义的内存间交互操作"></p><p>Java 内存模型还规定了执行上述 8 种基本操作时必须满足如下规则：</p><ul><li><p>不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</p></li><li><p>不允许一个线程丢弃它的最近的 assgin 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p></li><li><p>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或者 assign）的变量，换句话说，就是对一个变量实施 use、store 操作之前，必须先执行过了 assign 和 load 操作。</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其它线程锁定住的变量。</p></li><li><p>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</p></li></ul><p>以上 8 种内存访问操作以及上述规则限定，再加上 volatile 的一些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。</p><h4 id="对-volatile-型变量的特殊规则"><a href="#对-volatile-型变量的特殊规则" class="headerlink" title="对 volatile 型变量的特殊规则"></a>对 volatile 型变量的特殊规则</h4><p>关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制，当一个变量被定义成 volatile 之后，他将具备两种特性：</p><ul><li><p>保证此变量对所有线程的可见性：即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量是做不到这点，普通变量的值在线程在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一个线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。另外，Java 里面的运算并非原子操作，会导致 volatile 变量的运算在并发下一样是不安全的。</p></li><li><p>禁止指令重排序优化：普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致。</p></li></ul><p>由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用 synchronize 或 java.util.concurrent 中的原子类）来保证原子性：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>Volatile 型变量缺点：由于 Volatile 的 MESI 缓存一致性协议，需要不断的从主内存嗅探 <sup>[4]</sup>和 CAS 不断循环，无效交互会导致总线带宽达到峰值。</p><h4 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock、unlock、read、load、assign、use、store、write 这 8 个操作都具有原子性，但是对于 64 位的数据类型（long 和 double），在模型中特别定义了一条相对宽松的规则：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定。</p><p>Java 内存模型虽然允许虚拟机不把 long 和 double 变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还 “强烈建议” 虚拟机这样实现。</p><h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的，我们逐个看下哪些操作实现了这三个特性：</p><ul><li><p>原子性（Atomicity）：由 Java 内存模型来直接保证的原子性变量包括 read、load、assign、use、store 和 write，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大方位的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式的使用这两个操作，这两个字节码指令反应到 Java 代码中就是同步块——synchronized 关键字，因此在 synchronized 块之间的操作也具备原子性。</p></li><li><p>可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此，普通变量与 volatile 变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。除了 volatile 之外，Java 还有两个关键字能实现可见性，即 synchronized 和 final。同步快的可见性是由 “对一个变量执行 unlock 操作前，必须先把此变量同步回主内存” 这条规则获得的；而 final 关键字的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 “this” 的引用传递出去，那么在其他线程中就能看见 final 字段的值。</p></li><li><p>有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的线程操作都是无序的。前半句是指 “线程内表现为串行的语义”，后半句是指“指令重排序” 现象和 “工作内存与主内存同步延迟” 现象。Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由 “一个变量在同一个时刻只允许一条线程对其进行 lock 操作” 这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</p></li></ul><h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>如果 Java 内存模型中所有的有序性都仅仅靠 volatile 和 synchronize 来完成，那么有一些操作将会变得很烦琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个 “先行发生”（happens-before）的原则。</p><p>为了方便程序员开发，将底层的烦琐细节屏蔽掉，JMM 定义了 Happens-Before 原则。只要我们理解了 Happens-Before 原则，无需了解 JVM 底层的内存操作，就可以解决在并发编程中遇到的变量可见性问题。JVM 定义的 Happens-Before 原则是一组偏序关系：如果说操作 A 先行发生于操作 B，其实就是说发生在操作 B 之前，操作 A 产生的影响能被操作 B 观察到，“影响” 包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 线程 A 中执行</span><br><span class="line"><span class="attribute">i</span> = <span class="number">1</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 线程 B 中执行</span><br><span class="line"><span class="attribute">j</span> = i<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 线程 C 中执行</span><br><span class="line"><span class="attribute">i</span> = <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>例如：如果说线程 A 是先行发生于线程 B 的，那么可以确定在线程 B 执行之后 j=1，因为根据先行发生原则，A 操作 i = 1 的结果可以被 B 观察到，并且线程 C 还没有执行；那么如果线程 C 是在 A 与 B 之间，j 的值是多少呢？答案是不确定，1 和 2 都有可能，因为线程 C 对变量 i 的影响可能会被线程 B 观察到，也可能不会，这时候线程 B 就存在读取到过期数据的风险，不具备多线程安全性。</p><p>先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><ul><li><p>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。这是因为 Java 语言规范要求 JVM 在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。</p></li><li><p>管程锁定规则（Monitor Lock Rule）：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而 “后面” 是指时间上的先后顺序。</p></li><li><p>volatile 变量规则（Volatile Variable Rule）：对于一个 volatile 变量的写操作先行发生于后面对于这个变量的读操作，这里的 “后面” 同样是指时间上的先后顺序。</p></li><li><p>线程启动规则（Thread Start Rule）：Thread 对象的 start() 方法先行发生于此线程的每一个动作。</p></li><li><p>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。</p></li><li><p>线程中断规则（Thread Interruption Rule）：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事情的发生，可以用过 Thread.interrupred() 方法检测到是否有中断发生。</p></li><li><p>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。</p></li><li><p>传递性（Transitivity）：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。</p></li></ul><p>总结：时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。如果两个操作之间的关系不再以上规则中，并且无法通过以上规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://mp.weixin.qq.com/s/Oa3tcfAFO9IgsbE22C5TEg" target="_blank" rel="noopener">面试官想到，一个Volatile，敖丙都能吹半小时</a><br>[2]. <a href="https://www.cnblogs.com/zhguang/p/3330676.html" target="_blank" rel="noopener">Java系列笔记(5) - 线程</a><br>[3]. <a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机：JVM高级特性与最佳实践》，第五部分 高效并发</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 用户态核心态转换：Java 的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被 synchronized 修饰的 getter() 或 setter() 方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</small><br><small>[2]. As-If-Serial 语义：不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。编译器，处理器进行指令重排序都必须要遵守 as-if-serial 语义规则。为了遵守 as-if-serial 语义，编译器和处理器对存在依赖关系的操作，都不会对其进行重排序，因为这样的重排序很可能会改变执行的结果，但是对不存在依赖关系的操作，就有可能进行重排序。</small><br><small>[3]. 指令重排序优化：为了提高程序的执行效率，编译器在生成指令序列时，有可能对指令进行重排序。一般指令重排序可以分为如下三种：编译器重排序、指令级并行重排序、处理器重排序。Java 语言规范要求 JVM 只在单个线程内部维护一种类似串行的语义，即只要程序的最终结果与严格串行环境中执行的结果相同即可。</small><br><small>[4]. 嗅探：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</small></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li><li><a href="bdbfedfb.html">Java 并发编程之美（七）：透彻理解 Java 并发编程</a></li><li><a href="c0108a7c.html">Java 并发编程之美（八）：循序渐进学习 Java 锁机制</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个重要的原因是计算机的运算速度与它的存储和通信子系统速度的差
      
    
    </summary>
    
      <category term="并发" scheme="https://blog.maoning.vip/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="线程" scheme="https://blog.maoning.vip/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="https://blog.maoning.vip/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java 内存模型" scheme="https://blog.maoning.vip/tags/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="JMM" scheme="https://blog.maoning.vip/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Java 虚拟机（四）：Jvm 性能监控与调优</title>
    <link href="https://blog.maoning.vip/archives/3c79a541.html"/>
    <id>https://blog.maoning.vip/archives/3c79a541.html</id>
    <published>2020-01-06T04:32:59.000Z</published>
    <updated>2020-01-06T06:08:30.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>处理过线上问题的同学基本上都会遇到系统突然运行缓慢，CPU 100%，以及 Full GC 次数过多的问题。当然，这些问题的最终导致的直观现象就是系统运行缓慢，并且有大量的报警。给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC 日志、线程快照（threaddump/javacore 文件）、堆转侟快照（heapdump/hprof 文件）等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度。</p><p>对于线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。本文主要针对 JDK 的命令行工具，主要包括用于监视虚拟机和故障处理的工具。根据 JDK 的命令行工具提供解决问题的排查思路，从而定位出问题的代码点，进而提供解决该问题的思路。</p><a id="more"></a><h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><table><thead><tr><th>名称</th><th>主要作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool，显示指定系统内所有 HotSpot 虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，用于收集 HotSpot 虚拟机各方面的运行数据</td></tr><tr><td>jinfo</td><td>Configuration Info For Java，显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>Memory Map for Java，生成虚拟机的内存转储快照（heapdump 文件）</td></tr><tr><td>jhat</td><td>JVM Heap Dump Browser，用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用于可以在游览器上查看分析结果</td></tr><tr><td>jstack</td><td>Stack Trace for Java，显示虚拟机的线程快照</td></tr></tbody></table><p>这些命令行工具大多数是 jdk/lib/tools.jar 类库的一层薄包装而已，它们主要的功能代码是在 tools 类库中实现的。接来下介绍的 JDK 命令行工具大多都是基于 JDK 1.6，因此会存在个别参数在新版本 JDK 被淘汰的情况出现。所有的 JDK 工具都可以在 Oracle 官网的 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">Java Tools Reference</a> 文档中找到使用说明，这是主要参考，包括命令格式、参数内容、输出信息等等。</p><h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>jps 可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main() 函数所在的类）名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier，LVMID）。</p><p>查看 jps 的帮助信息：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos jvm]# jps -help</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] <span class="meta">[&lt;hostid&gt;]</span></span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>jps 命令格式：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ  <span class="keyword">jps </span>-lv</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-q</td><td style="text-align:center">只输出 LVMID，省略主类的名称</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">输出虚拟机进程启动时传递给主类 main() 函数的参数</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">输出虚拟机进程启动时 JVM 参数</td></tr></tbody></table><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。</p><p>查看 jstat 的帮助信息：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos jvm]<span class="comment"># jstat -help</span></span><br><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;<span class="built_in">count</span>&gt;]]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported <span class="keyword">by</span> <span class="keyword">the</span> -options option</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes <span class="keyword">the</span> following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">local</span> vm identifier <span class="keyword">for</span> <span class="keyword">the</span> target</span><br><span class="line">                Java virtual machine, typically a process <span class="built_in">id</span>; &lt;hostname&gt; <span class="keyword">is</span></span><br><span class="line">                <span class="keyword">the</span> <span class="built_in">name</span> <span class="keyword">of</span> <span class="keyword">the</span> host <span class="built_in">running</span> <span class="keyword">the</span> target Java virtual machine;</span><br><span class="line">                <span class="keyword">and</span> &lt;port&gt; <span class="keyword">is</span> <span class="keyword">the</span> port <span class="built_in">number</span> <span class="keyword">for</span> <span class="keyword">the</span> rmiregistry <span class="keyword">on</span> <span class="keyword">the</span></span><br><span class="line">                target host. See <span class="keyword">the</span> jvmstat documentation <span class="keyword">for</span> a more complete</span><br><span class="line">                description <span class="keyword">of</span> <span class="keyword">the</span> Virtual Machine Identifier.</span><br><span class="line">  &lt;lines&gt;       Number <span class="keyword">of</span> samples <span class="keyword">between</span> header lines.</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[<span class="string">"ms"</span>|<span class="string">"s"</span>]</span><br><span class="line">                Where &lt;n&gt; <span class="keyword">is</span> an <span class="built_in">integer</span> <span class="keyword">and</span> <span class="keyword">the</span> suffix specifies <span class="keyword">the</span> units <span class="keyword">as</span></span><br><span class="line">                milliseconds(<span class="string">"ms"</span>) <span class="keyword">or</span> seconds(<span class="string">"s"</span>). The default units are <span class="string">"ms"</span>.</span><br><span class="line">  &lt;<span class="built_in">count</span>&gt;       Number <span class="keyword">of</span> samples <span class="keyword">to</span> take <span class="keyword">before</span> terminating.</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly <span class="keyword">to</span> <span class="keyword">the</span> runtime system.</span><br></pre></td></tr></table></figure><p>jstat 命令格式：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每 250 毫秒查询一次进程 2764 垃圾收集状态，一共查询 20 次</span></span><br><span class="line">λ  jstat -gc <span class="number">2764</span> <span class="number">250</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td>-gc</td><td>监视 Java 堆状况，包括 Eden 区、两个 survivor 区、老年代、永久代等的容量、已用空间、GC 空间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代 GC 状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与 -gcnew 基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代 GC 状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与 -gcold 基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcpermcapacity</td><td>输出永久代使用到的最大、最小空间（JDK1.8 已废弃）</td></tr><tr><td>-gcmetacapacity</td><td>输出元数据空间使用到的最大、最小空间（JDK1.8 已废弃）</td></tr><tr><td>-compiler</td><td>输出 JIT 编译器编译过的方法、耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被 JIT 编译的方法</td></tr></tbody></table><p>特别说明：jstat 监视选项众多，由于版本原因无法逐一演示，感兴趣的朋友可以参考博客 <a href="https://www.jianshu.com/p/213710fb9e40" target="_blank" rel="noopener">《jvm 性能调优工具之 jstat》</a></p><h3 id="jinfo：Java-配置信息工具"><a href="#jinfo：Java-配置信息工具" class="headerlink" title="jinfo：Java 配置信息工具"></a>jinfo：Java 配置信息工具</h3><p>jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。使用 jps 命令的 -v 参数可以查看虚拟机启动时显示指定的参数列表，但如果想知道未被显示指定的参数的系统默认值，就只能使用 jinfo 的 -flag 选项进行查询了。</p><p>查看 jinfo 的帮助信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos jvm]# jinfo -help</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote<span class="built_in"> server IP </span><span class="keyword">or</span> hostname&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> remote <span class="builtin-name">debug</span> server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         <span class="keyword">to</span> <span class="builtin-name">print</span> the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    <span class="keyword">to</span> <span class="builtin-name">enable</span> <span class="keyword">or</span> <span class="builtin-name">disable</span> the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; <span class="keyword">to</span> <span class="builtin-name">set</span> the named VM flag <span class="keyword">to</span> the given value</span><br><span class="line">    -flags               <span class="keyword">to</span> <span class="builtin-name">print</span> VM flags</span><br><span class="line">    -sysprops            <span class="keyword">to</span> <span class="builtin-name">print</span> Java<span class="built_in"> system </span>properties</span><br><span class="line">    &lt;<span class="literal">no</span> option&gt;          <span class="keyword">to</span> <span class="builtin-name">print</span> both of the above</span><br><span class="line">    -h | -help           <span class="keyword">to</span> <span class="builtin-name">print</span> this help message</span><br></pre></td></tr></table></figure><p>jinfo 命令格式：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jinfo 查询进程 2764 虚拟机各项参数</span></span><br><span class="line">λ  jinfo -flags <span class="number">2764</span></span><br></pre></td></tr></table></figure><h3 id="jmap：Java-内存映像工具"><a href="#jmap：Java-内存映像工具" class="headerlink" title="jmap：Java 内存映像工具"></a>jmap：Java 内存映像工具</h3><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为 heapdump 或者 dump 文件）。如果不使用 jmap 命令，可以使用 -XX:+HeapDumpOnOutOfMemoryError 参数，让虚拟机在 OOM 异常出现之后自动生成 dump 文件。</p><p>jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalize 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。</p><p>查看 jmap 的帮助信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# jmap -help</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote<span class="built_in"> server IP </span><span class="keyword">or</span> hostname&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> remote <span class="builtin-name">debug</span> server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               <span class="keyword">to</span> <span class="builtin-name">print</span> same <span class="builtin-name">info</span> as Solaris pmap</span><br><span class="line">    -heap                <span class="keyword">to</span> <span class="builtin-name">print</span> java heap summary</span><br><span class="line">    -histo[:live]        <span class="keyword">to</span> <span class="builtin-name">print</span> histogram of java object heap; <span class="keyword">if</span> the <span class="string">"live"</span></span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             <span class="keyword">to</span> <span class="builtin-name">print</span> class loader statistics</span><br><span class="line">    -finalizerinfo       <span class="keyword">to</span> <span class="builtin-name">print</span> information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; <span class="keyword">to</span> dump java heap <span class="keyword">in</span> hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; <span class="keyword">if</span> <span class="keyword">not</span> specified,</span><br><span class="line">                                        all objects <span class="keyword">in</span> the heap are dumped.</span><br><span class="line">                           <span class="attribute">format</span>=b     binary format</span><br><span class="line">                           <span class="attribute">file</span>=&lt;file&gt;  dump heap <span class="keyword">to</span> &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,<span class="attribute">format</span>=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; <span class="keyword">or</span> -histo</span><br><span class="line">                         <span class="keyword">to</span> force a heap dump <span class="keyword">or</span> histogram when &lt;pid&gt; does <span class="keyword">not</span></span><br><span class="line">                         respond. The <span class="string">"live"</span> suboption is <span class="keyword">not</span> supported</span><br><span class="line">                         <span class="keyword">in</span> this mode.</span><br><span class="line">    -h | -help           <span class="keyword">to</span> <span class="builtin-name">print</span> this help message</span><br><span class="line">    -J&lt;flag&gt;             <span class="keyword">to</span> pass &lt;flag&gt; directly <span class="keyword">to</span> the runtime system</span><br></pre></td></tr></table></figure><p>jmap 命令格式：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jinfo 查询进程 2764 Java 堆详细信息</span></span><br><span class="line">λ  jmap -heap <span class="number">2764</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jinfo 生成进程 2764 Java 堆转储快照</span></span><br><span class="line">λ  jmap -<span class="keyword">dump</span>:live,format=b,<span class="keyword">file</span>=<span class="keyword">file</span>.<span class="keyword">dump</span> <span class="number">2764</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-dump</td><td>生成 Java 堆转储快照。格式为：-dump:[live,]format=b,file=&lt;filename>，其中 live 子参数说明是否只 dump 出存活的对象</td></tr><tr><td>-finalizerinfo</td><td>显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。只有在 Linux/Solaris 平台下有效</td></tr><tr><td>-heap</td><td>显示 Java 堆详细信息，如使用哪种回收器、参数配置、分代状况等。只有在 Linux/Solaris 平台下有效</td></tr><tr><td>-histo</td><td>显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td>-histo:live</td><td>与 -histo:live 功能一样，在统计之前 JVM 会先触发一次 FULL GC，线上慎用</td></tr><tr><td>-permstat</td><td>以 ClassLoader 为统计口径显示永久代内存状态。只有在 Linux/Solaris 平台下有效</td></tr><tr><td>-F</td><td>当虚拟机进程对 -dump 选项没有响应时，可使用这个选项强制生成 dump 快照。只有在 Linux/Solaris 平台下有效</td></tr></tbody></table><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>Sun JDK 提供 jhat（JVM Heap Analysis Tool）命令与 jmap 搭配使用，来分析 jmap 生成的堆转快照。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，可以在游览器中查看。</p><p>jhat 的分析功能相对来说比较简陋，在现实工作中，我们一般会使用 VisualVM、Eclipse Memory Analyzer、IBM HeapAnalyzer 等专业用于分析 dump 文件的工具。</p><p>查看 jhat 的帮助信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# jhat -help</span><br><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-<span class="builtin-name">debug</span> &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly <span class="keyword">to</span> the runtime system. <span class="keyword">For</span></span><br><span class="line">                          example, -J-mx512m <span class="keyword">to</span> use a maximum heap size of 512MB</span><br><span class="line">        -stack <span class="literal">false</span>:     Turn off<span class="built_in"> tracking </span>object allocation call stack.</span><br><span class="line">        -refs <span class="literal">false</span>:      Turn off<span class="built_in"> tracking </span>of references <span class="keyword">to</span> objects</span><br><span class="line">        -port &lt;port&gt;:     <span class="builtin-name">Set</span> the<span class="built_in"> port </span><span class="keyword">for</span> the HTTP server.  Defaults <span class="keyword">to</span> 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded <span class="keyword">from</span> the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects <span class="keyword">in</span></span><br><span class="line">                          both heap dumps with the same ID <span class="keyword">and</span> same class will</span><br><span class="line">                          be marked as <span class="keyword">not</span> being <span class="string">"new"</span>.</span><br><span class="line">        -<span class="builtin-name">debug</span> &lt;int&gt;:     <span class="builtin-name">Set</span> <span class="builtin-name">debug</span> level.</span><br><span class="line">                            0:  <span class="literal">No</span> <span class="builtin-name">debug</span> output</span><br><span class="line">                            1:  <span class="builtin-name">Debug</span> hprof file parsing</span><br><span class="line">                            2:  <span class="builtin-name">Debug</span> hprof file parsing, <span class="literal">no</span> server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          <span class="builtin-name">Print</span> this help <span class="keyword">and</span> exit</span><br><span class="line">        &lt;file&gt;            The file <span class="keyword">to</span> read</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump <span class="keyword">in</span> the file</span><br><span class="line">by appending <span class="string">"#&lt;number&gt;"</span> <span class="keyword">to</span> the file name, i.e. <span class="string">"foo.hprof#3"</span>.</span><br><span class="line"></span><br><span class="line">All boolean options<span class="built_in"> default </span><span class="keyword">to</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>jmap 命令格式：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// jhat 分析 <span class="keyword">file</span>.dump，屏幕显示“Server <span class="keyword">is</span> ready”的提示后，用户在游览器输入 http://localhos<span class="variable">t:7000</span>/ 就可以看到分析结果</span><br><span class="line">λ  jhat <span class="keyword">file</span>.dump</span><br></pre></td></tr></table></figure><h3 id="jstack：Java-堆栈跟踪工具"><a href="#jstack：Java-堆栈跟踪工具" class="headerlink" title="jstack：Java 堆栈跟踪工具"></a>jstack：Java 堆栈跟踪工具</h3><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为 threaddump 或者 javacore 文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</p><p>查看 jstack 的帮助信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# jstack -help</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote<span class="built_in"> server IP </span><span class="keyword">or</span> hostname&gt;</span><br><span class="line">        (<span class="keyword">to</span> connect <span class="keyword">to</span> a remote <span class="builtin-name">debug</span> server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  <span class="keyword">to</span> force a thread dump. Use when jstack &lt;pid&gt; does <span class="keyword">not</span> respond (process is hung)</span><br><span class="line">    -m  <span class="keyword">to</span> <span class="builtin-name">print</span> both java <span class="keyword">and</span> native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h <span class="keyword">or</span> -help <span class="keyword">to</span> <span class="builtin-name">print</span> this help message</span><br></pre></td></tr></table></figure><p>jstack 命令格式：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jstack 查看进程 2764 线程快照</span></span><br><span class="line">λ  jstack -l <span class="number">2764</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息</td></tr><tr><td>-m</td><td>如果调用本地方法的话，可以显示 C/C++ 的堆栈</td></tr></tbody></table><h2 id="JDK-可视化工具"><a href="#JDK-可视化工具" class="headerlink" title="JDK 可视化工具"></a>JDK 可视化工具</h2><p>JDK 中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole 和 VisualVM。</p><h3 id="JConsole：Java-监视与管理控制台"><a href="#JConsole：Java-监视与管理控制台" class="headerlink" title="JConsole：Java 监视与管理控制台"></a>JConsole：Java 监视与管理控制台</h3><p>JConsole（Java Monitoring and Management Console）是一种基于 JMX 的可视化监视、管理工具，它管理部分的功能是针对 JMX MBean 进行管理。</p><p><img src="/media/15470360146770/20191210171528.png" alt="通过 jconsole 命令启动 JConsole"></p><p><img src="/media/15470360146770/20191210155101.png" alt="JConsole Java 监视和管理控制台"></p><p>特殊说明：要对 Java 进程进行远程监控，在启动它的时候需要启用 JMX，对于 Java 进程开启远程调试可以参考博客<a href="https://www.jianshu.com/p/923580d3a5a2" target="_blank" rel="noopener">《Java - jmx远程调优》</a></p><h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序。VisualVM 除了运行监视、故障处理外，还提供了很多其他方面你的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 Jprofiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 不需要被监视的程序基于特殊 Agent 运行，因此它对对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。</p><p><img src="/media/15470360146770/20191210171124.png" alt="通过 jvisualvm 命令启动 VisualVM"></p><p><img src="/media/15470360146770/20191210171205.png" alt="Java VisualVM 监视和管理控制台"></p><h2 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h2><p>模拟环境：Centos7 1 核 2GB，Java 8</p><h3 id="JVM-调优之-jstack-找出最耗-CPU-的线程并定位代码"><a href="#JVM-调优之-jstack-找出最耗-CPU-的线程并定位代码" class="headerlink" title="JVM 调优之 jstack 找出最耗 CPU 的线程并定位代码"></a>JVM 调优之 jstack 找出最耗 CPU 的线程并定位代码</h3><p>笔者之前在一家互联网公司从事爬虫业务，在解析 HTML 时，经常由于网站返回的 HTML 网页结构不完整而导致解析框架死循环，从而导致 CPU 飚高，系统运行缓慢。</p><h4 id="场景模拟"><a href="#场景模拟" class="headerlink" title="场景模拟"></a>场景模拟</h4><p>场景模拟：在线上的环境中，一般 CPU 飙高极大的可能性是出现了死循环了。因此我们通过模拟死循环的方式模拟 CPU 飚高的情况，然后通过 jstack 找出最耗 CPU 的线程并定位代码。启动程序后，发现该程序 CPU 直线飙高，直接到达 100% 根本没有要下降的趋势，并且系统平均负载也直线飙高至 3.79，导致系统缓慢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nThreads = <span class="number">3</span>;</span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(nThreads);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h4><p>（1）  jstack 找出最耗 CPU 的线程并定位代码</p><p>① 通过 top 命令找到占用 CPU 最高的 pid[进程 ID]，定位到 pid 是 12870</p><p><img src="/media/15470360146770/20191211144353.png" alt="通过 top 命令找到占用 CPU 最高的 pid"></p><p>② 通过 top -Hp pid 查看该进程中占用 CPU  过高的 tid[线程 id]，定位到 tid 分别为 12894、12895、12896</p><p><img src="/media/15470360146770/20191211144748.png" alt="通过 top -Hp pid 查看该进程中占用 CPU  过高的 tid"></p><p>③ 通过 printf “0x%x\n” tid 把线程 id 转化为十六进制，转换后的十六进制 tid 分别为 0x325e、0x325f、0x3260</p><p>④ 通过 jstack pid |grep tid -A 30 定位线程堆栈信息，这里的 tid 指的是转换后的十六进制 tid，定位到导致 CPU 飚高的代码为 ExceptionHandler 类 27 行处，发现里面有一个死循环。</p><p><img src="/media/15470360146770/20191211145743.png" alt="jstack pid |grep tid -A 30"></p><p>（2） 通过在线可视化分析工具分析 threaddump </p><p><a href="https://fastthread.io/" target="_blank" rel="noopener">fastthread.io</a> 是一个在线线程日志分析网站，科学上网打开速度会更快。定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。比较好的是它会提供一些优化的建议，可以作为参考，而且各个部分的分析也比较详细。</p><p>① 通过 top 命令找到占用 CPU 最高的 pid[进程 ID]，定位到 pid 是 12870</p><p>② 通过 jstack -l pid &gt; file-path 抓取 thread dump 文件，即 jstack -l 12870 &gt; threaddump-1576050339106.tdump</p><p>③ 将 thread dump 文件上传至 fastthread 网站，查看分析结果</p><p><img src="/media/15470360146770/20191211152249.png" alt="根据 fastthread 分析结果找出最耗 CPU 的线程并定位代码"></p><h3 id="JVM-调优之-jstack-找出死锁线程并定位代码"><a href="#JVM-调优之-jstack-找出死锁线程并定位代码" class="headerlink" title="JVM 调优之 jstack 找出死锁线程并定位代码"></a>JVM 调优之 jstack 找出死锁线程并定位代码</h3><p>Deadlock：死锁线程，一般指多个线程调用间，进入相互资源占用，导致一直等待无法释放的情况。由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢。</p><h4 id="场景模拟-1"><a href="#场景模拟-1" class="headerlink" title="场景模拟"></a>场景模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock1());</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock2());</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Lock1 running"</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ExceptionHandler.obj1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock1 lock obj1"</span>);</span><br><span class="line">                        <span class="comment">// 获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (ExceptionHandler.obj2) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Lock1 lock obj2"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"Lock2 running"</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ExceptionHandler.obj2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock2 lock obj2"</span>);</span><br><span class="line">                        <span class="comment">// 获取obj2后先等一会儿，让Lock1有足够的时间锁住obj1</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">synchronized</span> (ExceptionHandler.obj1) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Lock2 lock obj1"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排查思路-1"><a href="#排查思路-1" class="headerlink" title="排查思路"></a>排查思路</h4><p>（1）  jstack 分析线程运行状况，找出死锁线程并定位代码</p><p>① 通过 top 命令找到占用 需要分析的 pid[进程 ID]，定位到 pid 是 7120</p><p>② 通过 jstack pid 定位线程堆栈信息，通过分析线程快照，可以很轻松的发现死锁状况</p><p><img src="/media/15470360146770/20200102191557.png" alt="jstack 分析线程死锁"></p><p>（2） 通过在线可视化分析工具分析 threaddump </p><p>① 通过 top 命令找到占用 CPU 最高的 pid[进程 ID]，定位到 pid 是 7120</p><p>② 通过 jstack -l pid &gt; file-path 抓取 thread dump 文件，即 jstack -l 7120 &gt; threaddump-1576050339106.tdump</p><p>③ 将 thread dump 文件上传至 fastthread 网站，查看分析结果</p><p><img src="/media/15470360146770/20200102205305.png" alt="根据 fastthread 分析结果找出死锁线程并定位代码"></p><h3 id="JVM-调优之-jstack-找出-Full-GC-次数过多并定位代码"><a href="#JVM-调优之-jstack-找出-Full-GC-次数过多并定位代码" class="headerlink" title="JVM 调优之 jstack 找出 Full GC 次数过多并定位代码"></a>JVM 调优之 jstack 找出 Full GC 次数过多并定位代码</h3><p>Full GC 次数过多，这种情况是最容易出现的，尤其是新功能上线时。对于 Full GC 较多的情况，其主要有如下两个特征：1、线上多个线程的 CPU 都超过了 100%，通过 jstack 命令可以看到这些线程主要是垃圾回收线程；2、通过 jstat 命令监控 GC 情况，可以看到 Full GC 次数非常多，并且次数在不断增加。</p><h4 id="排查思路-2"><a href="#排查思路-2" class="headerlink" title="排查思路"></a>排查思路</h4><p>（1）  jstack 分析线程运行状况，找出 Full GC 次数过多原因并定位代码</p><p>① 首先我们通过 top 命令查看当前 CPU 消耗过高的进程是哪个，从而得到进程 id；然后通过 top -Hp &lt;pid> 来查看该进程中有哪些线程 CPU 过高，一般超过 80% 就是比较高的，80% 左右是合理情况。这样我们就能得到 CPU 消耗比较高的线程 id。接着通过该线程 id 的十六进制表示在 jstack 日志中查看当前线程具体的堆栈信息</p><p>② 通过 jstack pid |grep tid -A 30 定位线程堆栈信息，这里的 tid 指的是转换后的十六进制 tid，定位到导致 CPU 飚高的线程为 “VM Thread”，而 VM Thread 指的就是垃圾回收的线程。这里我们基本上可以确定，当前系统缓慢的原因主要是垃圾回收过于频繁，导致 GC 停顿时间较长</p><p>③ 通过 jstat -gcutil pid 1000 10 查看 GC 的情况，可以看到，这里 FGC 指的是 Full GC 数量，若 FGC 过高，可能是由于内存溢出导致的系统缓慢，也可能是代码或者第三方依赖的包中有显示的 System.gc() 调用</p><p>④ 通过分析 dump 文件，确定由于内存溢出导致 Full GC 次数过多还是由于代码或者第三方依赖的包中有显示的 System.gc() 调用导致 Full GC 次数过多</p><p>（2） 通过在线可视化分析工具分析 gc.log </p><p><a href="https://gceasy.io/" target="_blank" rel="noopener">gceasy.io</a> 是一个在线 GC 日志分析工具，科学上网打开速度会更快。gceasy 可帮助您可帮助您分析程序运行时 GC 情况，您可以根据分析结果及时优化程序。</p><p>① 通过 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log 命令获取 gc 日志</p><p>② 将 gc.log 文件上传至 gceasy 网站，查看分析结果</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于 Full GC 次数过多，主要有以下两种原因：</p><ul><li>代码中一次获取了大量的对象，导致内存溢出，此时可以通过 eclipse 的 mat 工具查看内存中有哪些对象比较多。</li><li>内存占用不高，但是 Full GC 次数还是比较多，此时可能是显示的 System.gc() 调用导致 GC 次数过多，这可以通过添加 - XX:+DisableExplicitGC 来禁用 JVM 对显示 GC 的响应。</li></ul><h3 id="JVM-调优之-jmap-找出内存泄漏并定位代码"><a href="#JVM-调优之-jmap-找出内存泄漏并定位代码" class="headerlink" title="JVM 调优之 jmap 找出内存泄漏并定位代码"></a>JVM 调优之 jmap 找出内存泄漏并定位代码</h3><p>同样是笔者之前所在的爬虫业务，有个网站改版后，登录时采用 RSA 加密方式，笔者根据网站的加密方式改版后项目重新上线后，发现项目内存使用率每天都会增加一点，对于一个长期稳定运行 Java 项目而言，出现这种情况一般都有可能是出现了内存泄露。</p><h4 id="场景模拟-2"><a href="#场景模拟-2" class="headerlink" title="场景模拟"></a>场景模拟</h4><p>场景模拟：在线上的环境中，一个长期稳定运行的项目，内存使用率每天都增加，一般情况就是出现了内存泄露。而笔者所说的场景就是，网站采用 RSA 对网站的登录账号、密码进行加密，Java 默认的 RSA 实现是 “RSA/None/PKCS1Padding”（即 Cipher cipher = Cipher.getInstance(“RSA”);）；而该网站采用的 RSA 实现是 “RSA/None/NoPadding”（即 Cipher cipher = Cipher.getInstance(“RSA”, new org.bouncycastle.jce.provider.BouncyCastleProvider());）。项目长时间运行，就会出现 JceSecurity 占用的内存越来越多，而且不会释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PUBLIC_KEY = <span class="string">"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCO/qrEGrKGX06KP9Aks1BeP/2RTQkg/WXUQoCbtKQOqQQGY5N/ekCSW0Ow9ZAiEl3GMG/E7elNvEPV17bpRP3k+PFB0YxhgqOPLqxSN+57PUSUJU1rTkVY8mcu3eWrrGf2xpud1eXKEW3YeI95uCPyGPq4sO3NtHJY1xUTaFhG7QIDAQAB"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(encrypt(DEFAULT_PUBLIC_KEY, <span class="keyword">new</span> org.bouncycastle.jce.provider.BouncyCastleProvider(), <span class="string">"morning"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用publicKey来加密内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyString 公钥key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> provider        加密提供商</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content         内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String publicKeyString, Provider provider, String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>, provider);</span><br><span class="line">        PublicKey publicKey = KeyFactory.getInstance(<span class="string">"RSA"</span>, provider).generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(Base64.decodeBase64(publicKeyString)));</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(cipher.doFinal(content.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/15470360146770/20191211164804.png" alt="RSA 加密导致的内存泄漏"></p><h4 id="排查思路-3"><a href="#排查思路-3" class="headerlink" title="排查思路"></a>排查思路</h4><p>（1）   MAT 找出内存泄漏并定位代码</p><p>Eclipse Memory Analyzer Tool（MAT）是一个强大的基于 Eclipse 的内存分析工具，可以帮助我们找到内存泄露，减少内存消耗。MAT 是有两种安装方式的：一种安装方式是将 MAT 当做 eclipse 的插件进行安装：启动 Eclipse –&gt; Help –&gt; Eclipse Marketplace，然后搜索 Memory Analyzer，安装，重启 eclipse 即可；另外一种安装方式是将 MAT 作为一个独立的软件进行安装：去 <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">官网</a>，根据操作系统版本下载最新的 MAT。下载后解压就可以运行了。</p><p>① 通过 top 命令找到占用内存使用率持续增加的 pid[进程 ID]，定位到 pid 是 12870</p><p>② 通过 jmap -dump:[live,]format=b,file=&lt;filename> &lt;pid> 获取堆转储文件，即 jmap -dump:live,format=b,file=heapdump-1576054225319.hprof 12870</p><p>③ 将 heap dump 文件导入 MAT，查看分析结果</p><p>④ 加载后首页如下图，在首页上比较有用的是 Histogram 和 Leak Suspects。由下图看出这个类 javax.crypto.JceSecurity 占用 896.3 MB，表示这其中很多不能够被回对象的对象</p><p><img src="/media/15470360146770/20191211183328.png" alt="MAT 首页图"></p><p>⑤ 根据 Leak Suspects 快速查看泄露的可疑点，在 Leak Suspects 页面会给出可能的内存泄露，点击 Details 进入详情页面。在详情页面 Shortest Paths To the Accumulation Point 表示 GC root 到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达 GC root，则该内存消耗聚集点不会被当做垃圾被回收。由下图可以看到大量的 BouncyCastleProvider 对象没有被垃圾回收器回收，占用了大量内存空间。</p><p><img src="/media/15470360146770/20191211184331.png" alt="BouncyCastleProvider 对象占用大量内存空间从而导致内存泄漏"></p><p>（3） 通过在线可视化分析工具分析 heaphero </p><p><a href="https://heaphero.io/" target="_blank" rel="noopener">heaphero.io</a> 是一个在线内存分析工具，科学上网打开速度会更快。heaphero 可帮助您查找内存泄漏并减少内存消耗，运行报告以自动提取泄漏嫌疑者，主要展示项有：堆统计，大对象，字符串重复，低效率对象，线程数，及优化建议等。</p><p>① 通过 top 命令找到占用内存使用率持续增加的 pid[进程 ID]，定位到 pid 是 12870</p><p>② 通过 jmap -dump:[live,]format=b,file=&lt;filename> &lt;pid> 获取堆转储文件，即 jmap -dump:live,format=b,file=heapdump-1576054225319.hprof 12870</p><p>③ 将 heap dump 文件上传至 heaphero 网站，查看分析结果</p><p><img src="/media/15470360146770/20191211190821.png" alt="根据 heaphero 分析结果找出大对象"></p><p><img src="/media/15470360146770/20191211190958.png" alt="查看 JceSecurity 包含哪些对象"></p><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><p>（1）修改 provider 指定方式：Security.addProvider(new BouncyCastleProvider())</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PUBLIC_KEY = <span class="string">"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCO/qrEGrKGX06KP9Aks1BeP/2RTQkg/WXUQoCbtKQOqQQGY5N/ekCSW0Ow9ZAiEl3GMG/E7elNvEPV17bpRP3k+PFB0YxhgqOPLqxSN+57PUSUJU1rTkVY8mcu3eWrrGf2xpud1eXKEW3YeI95uCPyGPq4sO3NtHJY1xUTaFhG7QIDAQAB"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(encrypt(DEFAULT_PUBLIC_KEY, BouncyCastleProvider.PROVIDER_NAME, <span class="string">"morning"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用publicKey来加密内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyString 公钥key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> provider        加密提供商</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content         内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String publicKeyString, String provider, String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>, provider);</span><br><span class="line">        PublicKey publicKey = KeyFactory.getInstance(<span class="string">"RSA"</span>, provider).generatePublic(<span class="keyword">new</span> X509EncodedKeySpec(Base64.decodeBase64(publicKeyString)));</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(cipher.doFinal(content.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）把 BouncyCastleProvider 改成单例模式</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span> DEFAULT_PUBLIC_KEY = <span class="string">"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCO/qrEGrKGX06KP9Aks1BeP/2RTQkg/WXUQoCbtKQOqQQGY5N/ekCSW0Ow9ZAiEl3GMG/E7elNvEPV17bpRP3k+PFB0YxhgqOPLqxSN+57PUSUJU1rTkVY8mcu3eWrrGf2xpud1eXKEW3YeI95uCPyGPq4sO3NtHJY1xUTaFhG7QIDAQAB"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(encrypt(DEFAULT_PUBLIC_KEY, BouncyCastleProviderEnum.INSTANCE.getBouncyCastleProvider(), <span class="string">"morning"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == <span class="literal">null</span>) &#123;</span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> <span class="type">BouncyCastleProvider</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用publicKey来加密内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param publicKeyString 公钥key</span></span><br><span class="line"><span class="comment">     * @param provider        加密提供商</span></span><br><span class="line"><span class="comment">     * @param content         内容</span></span><br><span class="line"><span class="comment">     * @return byte[]</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encrypt(<span class="keyword">String</span> publicKeyString, Provider provider, <span class="keyword">String</span> content) throws Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>, provider);</span><br><span class="line">        PublicKey publicKey = KeyFactory.getInstance(<span class="string">"RSA"</span>, provider).generatePublic(<span class="keyword">new</span> <span class="type">X509EncodedKeySpec</span>(Base64.decodeBase64(publicKeyString)));</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(cipher.doFinal(content.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举实现单例模式.</span></span><br><span class="line"><span class="comment">     * 避免项目中出现反复 new BouncyCastleProvider() 导致内存泄漏.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">BouncyCastleProviderEnum</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 枚举类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 枚举类实例变量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> BouncyCastleProvider bouncyCastleProvider;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 枚举类构造方法，默认为private</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BouncyCastleProviderEnum() &#123;</span><br><span class="line">            bouncyCastleProvider = <span class="keyword">new</span> <span class="type">BouncyCastleProvider</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 枚举类成员方法.</span></span><br><span class="line"><span class="comment">         * 获取产生的bouncyCastleProvider变量.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @return BouncyCastleProvider</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> BouncyCastleProvider getBouncyCastleProvider() &#123;</span><br><span class="line">            <span class="keyword">return</span> bouncyCastleProvider;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/213710fb9e40" target="_blank" rel="noopener">jvm 性能调优工具之 jstat</a><br>[2]. <a href="https://www.cnblogs.com/qingshanli/p/9333487.html" target="_blank" rel="noopener">JDK的可视化工具系列 (四) JConsole、VisualVM</a><br>[3]. <a href="https://www.cnblogs.com/trust-freedom/p/6744948.html" target="_blank" rel="noopener">使用Eclipse Memory Analyzer Tool（MAT）分析线上故障(一) - 视图&amp;功能篇</a><br>[4]. <a href="http://cmsblogs.com/?p=5155" target="_blank" rel="noopener">一道必备面试题：系统CPU飙高和GC频繁，如何排查？</a></p><hr><h2 id="深入理解-Java-虚拟机系列"><a href="#深入理解-Java-虚拟机系列" class="headerlink" title="深入理解 Java 虚拟机系列"></a>深入理解 Java 虚拟机系列</h2><ul><li><a href="6cd92fa9.html">深入理解 Java 虚拟机（一）：Java 内存区域与内存溢出异常</a></li><li><a href="1a0b1a8e.html">深入理解 Java 虚拟机（二）：JVM 垃圾收集器</a></li><li><a href="2dc6708f.html">深入理解 Java 虚拟机（三）：内存分配与回收策略</a></li><li><a href="3c79a541.html">深入理解 Java 虚拟机（四）：Jvm 性能监控与调优</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;处理过线上问题的同学基本上都会遇到系统突然运行缓慢，CPU 100%，以及 Full GC 次数过多的问题。当然，这些问题的最终导致的直观现象就是系统运行缓慢，并且有大量的报警。给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC 日志、线程快照（threaddump/javacore 文件）、堆转侟快照（heapdump/hprof 文件）等。经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据、定位解决问题的速度。&lt;/p&gt;
&lt;p&gt;对于线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。本文主要针对 JDK 的命令行工具，主要包括用于监视虚拟机和故障处理的工具。根据 JDK 的命令行工具提供解决问题的排查思路，从而定位出问题的代码点，进而提供解决该问题的思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Jvm" scheme="https://blog.maoning.vip/categories/Jvm/"/>
    
    
      <category term="Jvm" scheme="https://blog.maoning.vip/tags/Jvm/"/>
    
      <category term="性能监控" scheme="https://blog.maoning.vip/tags/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    
      <category term="线上问题" scheme="https://blog.maoning.vip/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Git 在团队中的最佳实践（三）：如何优雅的使用 Git？</title>
    <link href="https://blog.maoning.vip/archives/97ab96a0.html"/>
    <id>https://blog.maoning.vip/archives/97ab96a0.html</id>
    <published>2019-12-23T02:23:44.000Z</published>
    <updated>2020-10-12T07:51:11.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本系列的前两篇博文中，笔者对 Git 以及 Git flow 进行了大致的介绍，相信各位读者已经对 Git 有了大致的了解。但是，在我们的日常工作中使用 Git 时常会遇到的各种突发状况，那么我们应该怎么合理的应对这些状况呢？俗话说，无规矩不成方圆，在团队协作中，如何规范 Git Commit 呢？本文将针对以上问题展开讨论，探讨一下在日常工作中，我们应该如何优雅的使用 Git？</p><a id="more"></a><h2 id="你可能会忽略的-Git-提交规范"><a href="#你可能会忽略的-Git-提交规范" class="headerlink" title="你可能会忽略的 Git 提交规范"></a>你可能会忽略的 Git 提交规范</h2><p>无规矩不成方圆，编程也一样。如果在团队协作中，大家都张扬个性，那么代码将会是一团糟，好好的项目就被糟践了。不管是开发还是日后维护，都将是灾难。对于 Git Commit 同样如此，统一 Git Commit 规范可以方便管理团队代码，方便后续进行 code review 以及生成 change log；统一 Git Commit 规范容易理解提交的信息。</p><h3 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h3><p>根据 Git flow 工作流分支模型将我们开发分支规范为五大分支：</p><ul><li>Master 分支 - 生产分支：最为稳定功能比较完整的随时可发布的代码，即代码开发完成，经过测试，没有明显的 bug，才能合并到 master 中。</li><li>Develop 分支 - 开发分支：用作平时开发的主分支，并一直存在，永远是功能最新最全的分支，所有的 feature、release 分支都是从 develop 分支上拉的。</li><li>Feature 分支 - 功能分支：这个分支主要是用来开发新的功能，一旦开发完成，通过测试没问题，我们合并回 develop 分支进入下一个 release。</li><li>Release 分支 - 发布分支：用于发布准备的专门分支。当开发进行到一定程度，或者说快到了既定的发布日，可以发布时，建立一个 release 分支并指定版本号（可以在 finish 的时候添加）。开发人员可以对 release 分支上的代码进行集中测试和修改 bug。全部完成经过测试没有问题后，将 release 分支上的代码合并到 master 分支和 develop 分支。</li><li>Hotfix 分支 - 热修复分支：用于修复线上代码的 bug。从 master 分支上拉，完成 hotfix 后，打上 tag 我们合并回 master 和 develop 分支。</li></ul><h3 id="标签规范"><a href="#标签规范" class="headerlink" title="标签规范"></a>标签规范</h3><p>采用三段式: v版本. 里程碑. 序号，例如 v1.2.1</p><ul><li>项目结构发生重大修改，增加第一个数字</li><li>发布新的功能，增加第二个数字</li><li>修复项目中的 bug，修改第三个数字</li></ul><h3 id="Git-Commit-信息规范"><a href="#Git-Commit-信息规范" class="headerlink" title="Git Commit 信息规范"></a>Git Commit 信息规范</h3><p>目前一般采用 Angular 的提交信息规范：信息分为 Header、Body、Footer 三部分</p><p>例子：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">refactor:</span> Restructure SQLRecognizer <span class="keyword">and</span> UndoExecutor (<span class="meta">#1883)</span></span><br></pre></td></tr></table></figure><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>Header 信息分为三部分 type(scope): subject</p><p>type（必须），用于说明 Git 提交信息的类别，有以下几个分类</p><table><thead><tr><th>Type</th><th><strong> 说明 </strong></th></tr></thead><tbody><tr><td>feat</td><td>新增功能</td></tr><tr><td>fix</td><td>修复 bug</td></tr><tr><td>docs</td><td>修改文档</td></tr><tr><td>refactor</td><td>重构代码，未新增任何功能或修复任何 bug</td></tr><tr><td>build</td><td>改变构建流程、新增依赖库</td></tr><tr><td>style</td><td>仅对样式做出修改（如空格和代码缩进等，不对逻辑进行修改）</td></tr><tr><td>perf</td><td>改善性能的修改</td></tr><tr><td>chore</td><td>非 src 或 test 下代码的修改</td></tr><tr><td>test</td><td>测试用例的修改</td></tr><tr><td>ci</td><td>自动化流程配置修改</td></tr><tr><td>revert</td><td>回滚到上一个版本</td></tr></tbody></table><p>scope（可选），用于说明 commit 的影响范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p>subject（必须），commit 的信息主题，尽量言简意赅，说明提交代码的主要变化。</p><h4 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h4><p>对本次提交的详细描述。</p><h4 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h4><ul><li>不兼容变动（需要说明变动信息）</li><li>关闭issue（需要输入issue信息）</li></ul><h2 id="使用-Git-时常会遇到的各种突发状况"><a href="#使用-Git-时常会遇到的各种突发状况" class="headerlink" title="使用 Git 时常会遇到的各种突发状况"></a>使用 Git 时常会遇到的各种突发状况</h2><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>【1】场景重现 one：当正在 feature 分支上开发某个新功能，这时项目中出现一个 bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用 git stash 命令将修改的内容保存至堆栈区，然后顺利切换到 hotfix 分支进行 bug 修复，修复完成后，再次切回到 feature 分支，从堆栈中恢复刚刚保存的内容。</p><p>【2】场景重现 two：由于疏忽，本应该在 feature 分支开发的内容，却在 develop 上进行了开发，需要重新切回到 feature 分支上进行开发，可以用 git stash 将内容保存至堆栈中，切回到 feature 分支后，再次恢复内容即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建 feature 分支</span></span><br><span class="line">$ git flow feature <span class="keyword">start</span> <span class="keyword">some</span>-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.在 feature 分支上开发某个新功能</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. git stash会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录，当前的工作目录就干净了。</span></span><br><span class="line">$ git stash <span class="keyword">save</span> <span class="string">"feat: add user (#1983)"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建 hotfix 分支</span></span><br><span class="line">$ git flow hotfix <span class="keyword">start</span> <span class="number">0.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 在 hotfix 分支上进行 bug 修复</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 完成 bug 修复，提交 hotfix 分支</span></span><br><span class="line">$ git flow hotfix <span class="keyword">finish</span> <span class="comment">--no-ff 0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 切换到 feature 分支</span></span><br><span class="line">$ git checkout <span class="keyword">some</span>-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 恢复工作进度到工作区，此命令的 stash@&#123;num&#125; 是可选项，在多个工作进度中可以选择恢复，不带此项则默认恢复最近的一次进度相当于 git stash pop stash@&#123;0&#125;</span></span><br><span class="line">$ git stash pop stash@&#123;<span class="keyword">num</span>&#125;</span><br></pre></td></tr></table></figure><p>git stash 常用命令指南</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存，save为可选项，message为本次保存的注释</span></span><br><span class="line"><span class="variable">$ </span>git stash [save message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有保存的记录列表</span></span><br><span class="line"><span class="variable">$ </span>git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次</span></span><br><span class="line"><span class="variable">$ </span>git stash pop stash@&#123;num&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复，num是可选项，通过git stash list可查看具体值。可回复多次</span></span><br><span class="line"><span class="variable">$ </span>git stash apply stash@&#123;num&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某个保存，num是可选项，通过git stash list可查看具体值</span></span><br><span class="line"><span class="variable">$ </span>git stash drop stash@&#123;num&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看堆栈中最新保存的 stash 和当前目录的差异，num是可选项，通过git stash list可查看具体值</span></span><br><span class="line"><span class="variable">$ </span>git stash show stash@&#123;num&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除所有保存</span></span><br><span class="line"><span class="variable">$ </span>git stash clear</span><br></pre></td></tr></table></figure><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>不知怎么，git rebase 命令被赋予了一个神奇的污毒声誉，初学者应该远离它，但它实际上可以让开发团队在使用时更加轻松。</p><p><strong>Rebase 的黄金法则</strong>：git rebase 的黄金法则是永远不要在公共分支上使用它。</p><p>【1】场景重现 one：当你在功能分支上开发新 feature 时，然后另一个团队成员在 master 分支提交了新的 commits，这会发生什么？这会导致分叉的历史记录，对于这个问题，使用 Git 作为协作工具的任何人来说都应该很熟悉。现在，假设在 master 分支上的新提交与你正在开发的 feature 相关。需要将新提交合并到你的 feature 分支中，你可以有两个选择：merge 或者 rebase。</p><p><img src="/media/15755331093489/20191205221813.png" alt="A forked commit history"></p><p><strong>Merge 方式</strong>：最简单的方式是通过 git merge 命令将 master 分支合并到 feature 分支中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout feature</span><br><span class="line">$ git <span class="keyword">merge</span> <span class="keyword">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将其浓缩为一行命令</span></span><br><span class="line">$ git <span class="keyword">merge</span> feature <span class="keyword">master</span></span><br></pre></td></tr></table></figure><p>这会在 feature 分支中创建一个新的 merge commit，它将两个分支的历史联系在一起。使用 merge 是很好的方式，因为它是一种 非破坏性的 操作，现有分支不会以任何方式被更改；另一方面，这也意味着 feature 分支每次需要合并上游更改时，它都将产生一个额外的合并提交。如果master 提交非常活跃，这可能会严重污染你的 feature 分支历史记录。尽管可以使用高级选项 git log 缓解此问题，但它可能使其他开发人员难以理解项目的历史记录。</p><p><img src="/media/15755331093489/20191205221821.png" alt="Merging master into the feature branch"></p><p><strong>Rebase 方式</strong>：作为 merge 的替代方法，你可以使用以下命令将 master 分支合并到  feature分支上</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout feature</span><br><span class="line">$ git rebase <span class="literal">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将其浓缩为一行命令</span></span><br><span class="line">$ git rebase <span class="keyword">master</span> <span class="title">feature</span></span><br></pre></td></tr></table></figure><p>这会将整个 feature 分支移动到 master 分支的顶端，从而有效地整合了所有 master 分支上的提交。但是，与 merge 提交方式不同，rebase 通过为原始分支中的每个提交创建全新的 commits 来 重写项目历史记录。</p><p><img src="/media/15755331093489/20191205221723.png" alt="Rebasing the feature branch onto master"></p><p>rebase 的主要好处是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase 会产生完美线性的项目历史记录，你可以在 feature 分支上没有任何分叉的情况下一直追寻到项目的初始提交。这样可以通过命令 git log，git bisect 和 gitk 更容易导航查看项目。</p><p>【2】场景重现 two：当你在功能分支上开发新 feature 时，多次提交了记录，这时，想要在在合并 feature 分支到 master 之前清理其杂乱的历史记录。</p><p> 交互式 rebase 使你有机会在将 commits 移动到新分支时更改这些 commits。这比自动 rebase 更强大，因为它提供了对分支提交历史的完全控制。</p><p>要使用交互式 rebase，需要使用 git rebase 和 -i 选项：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git checkout feature</span><br><span class="line"><span class="variable">$ </span>git rebase -i master</span><br></pre></td></tr></table></figure><p>这将打开一个文本编辑器，列出即将移动的所有提交：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick <span class="number">33</span>d5b7a <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#1</span></span><br><span class="line">pick <span class="number">9480</span>b3d <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#2</span></span><br><span class="line">pick <span class="number">5</span>c67e61 <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#3</span></span><br></pre></td></tr></table></figure><p>此列表准确定义了执行 rebase 后分支的外观。通过更改 pick命令或重新排序条目，你可以使分支的历史记录看起来像你想要的任何内容。例如，如果第二次提交 fix 了第一次提交中的一个小问题，您可以使用以下 fixup 命令将它们浓缩为一个提交：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick <span class="number">33</span>d5b7a <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#1</span></span><br><span class="line">fixup <span class="number">9480</span>b3d <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#2</span></span><br><span class="line">pick <span class="number">5</span>c67e61 <span class="keyword">Message</span> <span class="keyword">for</span> commit <span class="string">#3</span></span><br></pre></td></tr></table></figure><p>保存并关闭文件时，Git将根据您的指示执行 rebase，从而产生如下所示的项目历史记录：</p><p><img src="/media/15755331093489/20191205223502.png" alt="Squashing a commit with an interactive rebase"></p><p>消除这种无意义的提交使你的功能历史更容易理解。这是 git merge 根本无法做到的事情。至于 commits 条目前的 pick（ 保留该 commit ）、fixup（ 将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息 ）、squash（ 将该 commit 和前一个 commit 合并 ） 等命令，在 git 目录执行 git rebase -i 即可查看到，大家按需重排或合并提交即可，注释说明非常清晰，在此不做过多说明。</p><h3 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h3><p>git cherry-pick 可以理解为” 挑拣” 提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 git cherry-pick 了。</p><p>【1】场景重现 one：当正在 feature 分支上开发某个新功能，并且进行了多个提交。这时，你切到另外一个 feature 分支，想把之前 feature 分支上的某个提交复制过来，怎么办？这时候，神奇的 git cherry-pick 就闪亮的登场了。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick <span class="built_in">c2</span> <span class="built_in">c4</span></span><br></pre></td></tr></table></figure><p><img src="/media/15755331093489/20191206171140.png" alt="git cherry-pick 流程图"></p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。git reset是指将 HEAD 指针指到指定提交，历史记录中不会出现放弃的提交记录。</p><p>【1】场景重现 one：有时候，我们用 Git 的时候有可能 commit 提交代码后，发现这一次 commit 的内容是有错误的，那么有两种处理方法：1、修改错误内容，再次 commit 一次；2、使用 git reset 命令撤销这一次错误的 commit。第一种方法比较直接，但会多次一次 commit 记录。而我个人更倾向第二种方法，错误的 commit 没必要保留下来。那么今天来说一下 git reset。</p><p>Git reset 命令有三个主要选项：git reset –soft; git reset –mixed; git reset –hard;</p><ul><li>git reset –soft：软合并 - 保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区。重置位置的同时，保留 working Tree 工作目录和 index 暂存区的内容，只让 repository 中的内容和 reset 目标节点保持一致，因此原节点和 reset 节点之间的【差异变更集】会放入 index 暂存区中 (Staged files)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和 Reset 节点之间的所有差异都会放到暂存区中。</li><li>git reset –mixed： 混合合并（默认） - 保留工作目录， 并清空暂存区。重置位置的同时，只保留 Working Tree 工作目录的內容，但会将 Index 暂存区 和 Repository 中的內容更改和 reset 目标节点一致，因此原节点和 Reset 节点之间的【差异变更集】会放入 Working Tree 工作目录中。所以效果看起来就是原节点和 Reset 节点之间的所有差异都会放到工作目录中。</li><li>git reset –hard：强行合并 - 重置 stage 区和工作目录。重置位置的同时，直接将 working Tree 工作目录、 index 暂存区及 repository 都重置成目标 Reset 节点的內容， 所以效果看起来等同于清空暂存区和工作区。</li></ul><p><img src="/media/15755331093489/20191209101712.png" alt="git reset 流程图"></p><h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>git revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会重写提交历史。</p><p>【1】场景重现 one：改完代码匆忙提交，上线发现有问题，怎么办？赶紧回滚。改完代码测试也没有问题，但是上线发现你的修改影响了之前运行正常的代码报错，必须回滚。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销指定 commit 到当前 HEAD 之间所有的变化</span></span><br><span class="line"><span class="variable">$ </span>git revert [commit]..HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销指定 commit 到当前 HEAD 之间所有的变化 [不自动生成多个新的 commit，而是用一个 commit 完成]</span></span><br><span class="line"><span class="variable">$ </span>git revert -n [commit]..HEAD</span><br></pre></td></tr></table></figure><p>git revert 用于反转提交，用一个新提交来撤销某次提交，执行 git revert 命令时要求工作树必须是干净的。git revert 之后你再 git push 既可以把线上的代码更新。git revert 是放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在。</p><p><img src="/media/15755331093489/20191206113641.png" alt="git revert 流程图"></p><h2 id="强烈推荐"><a href="#强烈推荐" class="headerlink" title="强烈推荐"></a>强烈推荐</h2><p>如果你不能很好的应用 Git，那么这里为你提供一个非常棒的 Git 在线练习工具 <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">Learn Git Branching</a>。</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://ohshitgit.com" target="_blank" rel="noopener">Oh Shit, Git!?!</a></p><hr><h2 id="Git-在团队中的最佳实践系列"><a href="#Git-在团队中的最佳实践系列" class="headerlink" title="Git 在团队中的最佳实践系列"></a>Git 在团队中的最佳实践系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="c0dca125.html">Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</a></li><li><a href="97ab96a0.html">Git 在团队中的最佳实践（三）：如何优雅的使用 Git？</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在本系列的前两篇博文中，笔者对 Git 以及 Git flow 进行了大致的介绍，相信各位读者已经对 Git 有了大致的了解。但是，在我们的日常工作中使用 Git 时常会遇到的各种突发状况，那么我们应该怎么合理的应对这些状况呢？俗话说，无规矩不成方圆，在团队协作中，如何规范 Git Commit 呢？本文将针对以上问题展开讨论，探讨一下在日常工作中，我们应该如何优雅的使用 Git？&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://blog.maoning.vip/categories/Git/"/>
    
    
      <category term="Git" scheme="https://blog.maoning.vip/tags/Git/"/>
    
      <category term="实战指南" scheme="https://blog.maoning.vip/tags/%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/"/>
    
      <category term="规范" scheme="https://blog.maoning.vip/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>分布式设计之美（二）：微服务架构下分布式事务解决方案</title>
    <link href="https://blog.maoning.vip/archives/691d905d.html"/>
    <id>https://blog.maoning.vip/archives/691d905d.html</id>
    <published>2019-12-03T08:27:39.000Z</published>
    <updated>2020-01-20T03:22:46.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在微服务架构中，随着服务的逐步拆分，数据库私有已经成为共识，这也导致所面临的分布式事务问题成为微服务落地过程中一个非常难以逾越的障碍，但是目前尚没有一个完整通用的解决方案。</p><p>其实不仅仅是在微服务架构中，随着用户访问量的逐渐上涨，数据库甚至是服务的分片、分区、水平拆分、垂直拆分已经逐渐成为较为常用的提升瓶颈的解决方案，因此越来越多的原子操作变成了跨库甚至是跨服务的事务操作。最终结果是在对高性能、高扩展性、高可用性的追求的道路上，我们开始逐渐放松对一致性的追求，但是在很多场景下，尤其是账务，电商等业务中，不可避免的存在着一致性问题，使得我们不得不去探寻一种机制，用以在分布式环境中保证事务的一致性。</p><p>分布式事务有多种主流形态，包括：</p><ul><li>基于 2PC（两阶段提交）实现的分布式事务</li><li>基于 3PC（三阶段提交）实现的分布式事务</li><li>基于 TCC（补偿事务）实现的分布式事务</li><li>基于 Saga 实现的分布式事务</li><li>基于可靠消息（事务消息）最终一致性实现的分布式事务</li><li>基于本地消息（本地消息表）最终一致性实现的分布式事务</li></ul><p>接下来，本文将对这些形态的分布式事务进行剖析，然后讲解一下如何根据业务选择对应的分布式事务形态。</p><a id="more"></a><h2 id="本地数据库事务"><a href="#本地数据库事务" class="headerlink" title="本地数据库事务"></a>本地数据库事务</h2><p>数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有以下几个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durabilily），简称就是 ACID。</p><table><thead><tr><th></th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>A</td><td>Atomicity（原子性）</td><td>一个事务中的所有操作，要么全部完成，要么全部不完成，不会在中间某个环节结束。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</td></tr><tr><td>C</td><td>Consistency（一致性）</td><td>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</td></tr><tr><td>I</td><td>Isolation（隔离性）</td><td>数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</td></tr><tr><td>D</td><td>Durability（持久性）</td><td>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</td></tr></tbody></table><p>本地数据库事务操作也比较简单：开始一个事务，改变（插入，删除，更新）数据，然后提交事务（如果有异常时回滚事务）。MySQL 事务处理使用到 begin 开始一个事务，rollback 事务回滚，commit 事务确认。这里，事务提交后，通过 redo log 记录变更，通过 undo log 在失败时进行回滚，保证事务的原子性。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Connection con = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 工具类得到 connection 对象</span></span><br><span class="line">    con = JdbcUtils.getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭自动提交，开启事务</span></span><br><span class="line">    con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增、删、改 等操作</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功操作后提交事务</span></span><br><span class="line">    con.commit();</span><br><span class="line">    con.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有异常时回滚事务</span></span><br><span class="line">        con.rollback();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但随着业务数据规模的快速发展，数据量越来越大，单库单表逐渐成为瓶颈。所以我们对数据库进行了水平拆分，将原单库单表拆分成数据库分片。分库分表之后，原来在一个数据库上就能完成的写操作，可能就会跨多个数据库，这就产生了跨数据库事务问题。</p><h3 id="何时选择本地数据库事务？"><a href="#何时选择本地数据库事务？" class="headerlink" title="何时选择本地数据库事务？"></a>何时选择本地数据库事务？</h3><p>在条件允许的情况下，我们应该尽可能地使用单机事务，因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储 IO 消耗，在修改等量业务数据的情况下，单机事务将会有更高的性能。但单机数据库由于业务逻辑解耦等因素进行了数据库垂直拆分或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。</p><h2 id="分布式事务理论"><a href="#分布式事务理论" class="headerlink" title="分布式事务理论"></a>分布式事务理论</h2><p>微服务使得单体架构扩展为分布式架构，在扩展的过程中，逐渐丧失了单体架构中数据源单一，可以直接依赖于数据库进行事务操作的能力，而关系型数据库中，提供了强大的事务处理能力，可以满足 ACID（Atomicity，Consistency，Isolation，Durability）的特性，这种特性保证了数据操作的强一致性，这也是分布式环境中弱一致性以及最终一致性能够得以实现的基础。</p><p>数据一致性分为三个种类型：强一致性，弱一致性以及最终一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。数据库实现的就是强一致性，能够保证在写入一份新的数据，立即使其可见；最终一致性是弱一致性的强化版，系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。</p><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>CAP 定理是由加州大学伯克利分校 Eric Brewer 教授提出来的，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼：</p><ul><li>一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（对某个指定的客户端来说，读操作保证能返回最新的写操作结果）</li><li>可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（非故障的节点在合理的时间内返回合理的响应）</li><li>分区容错性（Partition tolerance）：系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。（分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务）</li></ul><p><img src="/media/15743169568096/b995ec3b909641ece87770f550a13dbd.png" alt="CAP 定理模型"></p><p>微服务作为分布式系统，同样受 CAP 原理的制约，在 CAP 理论中， C：Consistency、A：Availability、P：Partition tolerance 三者不可同时满足，而服务化中，更多的是提升 A 以及 P，在这个过程中不可避免的会降低对 C 的要求，因此，BASE 理论随之而来。</p><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论来源于 ebay 在 2008 年 ACM 中发表的论文，BASE 理论的基本原则有三个：Basically Available（基本可用），Soft state（软状态），Eventually consistent（最终一致性），主要目的是为了提升分布式系统的可伸缩性，论文同样阐述了如何对业务进行调整以及折中的手段，BASE 理论是对 CAP 定理中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><ul><li>Basically Available（基本可用）：整个系统在某些不可抗力的情况下，仍然能够保证 “可用性”，即一定时间内仍然能够返回一个明确的结果</li><li>Soft state（软状态）：同一数据的不同副本的状态，可以不需要实时一致</li><li>Eventually Consistent（最终一致性）：同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的</li></ul><p>在最终一致性的实现过程中，最基本的操作就是保证事务参与者的幂等性，所谓的幂等性，就是业务方能够使用相关的手段，保证单个事务多次提交依然能够保证达到同样的目的。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>现在，业内比较常用的分布式事务解决方案，包括强一致性的两阶段提交模式、三阶段提交模式，以及最终一致性的事务消息模式、补偿事务模式、本地消息表模式、SAGA 模式，我们会在后面的章节中详细介绍与实战。</p><h3 id="两阶段提交（2PC）-基于-2PC-实现的分布式事务"><a href="#两阶段提交（2PC）-基于-2PC-实现的分布式事务" class="headerlink" title="两阶段提交（2PC）- 基于 2PC 实现的分布式事务"></a>两阶段提交（2PC）- 基于 2PC 实现的分布式事务</h3><p>两阶段提交协议（The two-phase commit protocol，2PC）是 XA<sup>[1]</sup> 用于在全局事务中协调多个资源的机制，2PC 是一个非常经典的强一致、中心化的原子提交协议，。这里所说的中心化是指协议中有两类节点：一个是中心化协调者节点（coordinator）和 N 个参与者节点（partcipant）。在分布式系统中，每一个机器节点能够知道自己在执行事务操作过程是成功或失败，却无法直接获取其他分布式节点的执行结果。因此，为保持事务处理的 ACID，则引入协调者 (即 XA 协议中的事务管理器) 来统一调度所有分布式节点的执行逻辑，而被调度的分布式节点则称为参与者（即 XA 协议中的资源管理器）。</p><p>两阶段提交协议，事务管理器（协调者）分两个阶段来协调资源管理器（参与者），第一阶段准备资源，也就是预留事务所需的资源，如果每个资源管理器都资源预留成功，则进行第二阶段资源提交，否则协调资源管理器回滚资源。两阶段提交协议属于牺牲了一部分可用性来换取一致性的分布式事务方案。</p><p><img src="/media/15743169568096/250417-20171016132145537-970496141.png" alt="2PC 方案总体流程图"></p><h4 id="第一阶段：投票阶段"><a href="#第一阶段：投票阶段" class="headerlink" title="第一阶段：投票阶段"></a>第一阶段：投票阶段</h4><p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下：</p><ol><li>事务询问：协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果。</li><li>事执行事务：务参与者收到请求之后，执行事务但不提交，并将 Undo 和 Redo 信息记入事务日志中。</li><li>各参与者向协调者反馈事务询问的响应：参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。 </li></ol><h4 id="第二阶段：事务提交阶段"><a href="#第二阶段：事务提交阶段" class="headerlink" title="第二阶段：事务提交阶段"></a>第二阶段：事务提交阶段</h4><p>在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在三种可能性：（1）所有的参与者都回复能够正常执行事务；（2）一个或多个参与者回复事务执行失败；（3）协调者等待超时</p><p>对于第一种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如下：</p><ol><li>发送提交请求：协调者向各个参与者发送 commit 通知，请求提交事务。</li><li>参事务提交：参与者收到事务提交通知之后，执行 commit 操作，然后释放占有的资源。</li><li>反馈事务提交结果：参与者向协调者返回事务 commit 结果信息，即向协调者发送 Ack 消息。</li></ol><p><img src="/media/15743169568096/2pc-success.png" alt="2PC 方案事务提交流程流程图"></p><p>对于第二、三种情况，协调者均认为参与者无法成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，具体步骤如下：</p><ol><li>发送回滚请求：协调者向各个参与者发送事务 rollback 通知，请求回滚事务。</li><li>事务回滚：参与者收到事务回滚通知之后，执行 rollback 操作，然后释放占有的资源。</li><li>反馈事务回滚结果：参与者向协调者返回事务 rollback 结果信息，即向协调者发送 Ack 消息。</li></ol><p><img src="/media/15743169568096/2pc-failed.png" alt="2PC 方案事务回滚流程流程图"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>两阶段提交协议原理简单、易于实现，但是缺点也是显而易见的，主要缺点如下：</p><ul><li>单点问题：协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，就会影响整个数据库集群的正常运行，比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或回滚通知，那么参与者们将一直处于阻塞状态，整个数据库集群将无法提供服务。</li><li>同步阻塞：两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样效率极其低下。</li><li>数据不一致性：两阶段提交协议虽然是分布式数据强一致性所设计，但仍然存在数据不一致性的可能性，比如在第二阶段中，假设协调者发出了事务 commit 通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li></ul><h4 id="何时选择两阶段提交分布式事务？"><a href="#何时选择两阶段提交分布式事务？" class="headerlink" title="何时选择两阶段提交分布式事务？"></a>何时选择两阶段提交分布式事务？</h4><p>两阶段提交分布式事务，在prepare阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，对性能影响很大，不适合并发高以及子事务生命周长较长的业务场景；因此适用于参与者较少，单个本地事务执行时间较少，并且参与者自身可用性很高的场景，否则，其很可能导致性能下降严重。两阶段提交分布式事务方案属于牺牲了一部分可用性来换取的一致性。</p><h3 id="三阶段提交（3PC）-基于-3PC-实现的分布式事务"><a href="#三阶段提交（3PC）-基于-3PC-实现的分布式事务" class="headerlink" title="三阶段提交（3PC）- 基于 3PC 实现的分布式事务"></a>三阶段提交（3PC）- 基于 3PC 实现的分布式事务</h3><p>三阶段提交协议（The three-phase commit protocol，3PC）针对两阶段提交协议存在的问题，将两阶段提交协议的 “投票阶段” 过程一分为二，在两阶段提交协议的基础上增加了 “预询盘” 阶段，以及超时策略使得原先在两阶段提交协议中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的 “不确定状态” 所产生的可能相当长的延时的问题得以解决，从而来减少整个集群的阻塞时间，提升系统性能。三阶段提交协议的三个阶段分别为：can_commit，pre_commit，do_commit。</p><h4 id="第一阶段：can-commit-阶段"><a href="#第一阶段：can-commit-阶段" class="headerlink" title="第一阶段：can_commit 阶段"></a>第一阶段：can_commit 阶段</h4><p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的，具体步骤如下：</p><ol><li>事务询问：协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复。</li><li>各参与者向协调者反馈事务询问的响应：各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息。</li></ol><h4 id="第二阶段：pre-commit-阶段"><a href="#第二阶段：pre-commit-阶段" class="headerlink" title="第二阶段：pre_commit 阶段"></a>第二阶段：pre_commit 阶段</h4><p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有三种：（1）所有的参与者都返回确定信息；（2）一个或多个参与者返回否定信息；（3）协调者等待超时</p><p>针对第一种情况，协调者会向所有参与者发送事务执行请求，具体步骤如下：</p><ol><li>发送预提交请求：协调者向所有的事务参与者发送事务执行通知。</li><li>事务预提交：参与者收到通知后，执行事务但不提交，并将 Undo 和 Redo 信息记录到事务日志中。</li><li>各参与者向协调者反馈事务执行的响应：参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令，提交（commit）或中止（abort）。 </li></ol><p>针对第二、三种情况，协调者认为事务无法正常执行，于是向各个参与者发出 abort 通知，请求退出预备状态，具体步骤如下：</p><ol><li>发送中断请求：协调者向所有事务参与者发送 abort 通知。</li><li>中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</li></ol><p><img src="/media/15743169568096/3pc-fail-1.png" alt="3PC 方案 pre_commit 阶段失败流程流程图"></p><h4 id="第三阶段：do-commit-阶段"><a href="#第三阶段：do-commit-阶段" class="headerlink" title="第三阶段：do_commit 阶段"></a>第三阶段：do_commit 阶段</h4><p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为三种情况：（1）所有的参与者都回复能够正常执行事务；（2）一个或多个参与者回复事务执行失败；（3）协调者等待超时</p><p>对于第一种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如下：</p><ol><li>发送提交请求：协调者向各个参与者发送 commit 通知，请求提交事务。</li><li>参事务提交：参与者收到事务提交通知之后，执行 commit 操作，然后释放占有的资源。</li><li>反馈事务提交结果：参与者向协调者返回事务 commit 结果信息，即向协调者发送 Ack 消息。</li></ol><p><img src="/media/15743169568096/3pc-success.png" alt="3PC 方案事务提交流程流程图"></p><p>对于第二、三种情况，协调者均认为参与者无法成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，具体步骤如下：</p><ol><li>发送回滚请求：协调者向各个参与者发送事务 rollback 通知，请求回滚事务。</li><li>事务回滚：参与者收到事务回滚通知之后，执行 rollback 操作，然后释放占有的资源。</li><li>反馈事务回滚结果：参与者向协调者返回事务 rollback 结果信息，即向协调者发送 Ack 消息。</li></ol><p><img src="/media/15743169568096/3pc-fail-2.png" alt="3PC 方案事务回滚流程流程图"></p><p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交协议中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>相比较 2PC 而言，3PC 对于协调者（Coordinator）和参与者（Partcipant）都设置了超时时间，而 2PC 只有协调者才拥有超时机制。这一优化主要避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地 commit 从而进行释放资源，而这种机制也侧面降低了整个事务的阻塞时间和范围。3PC 在去除阻塞的同时也引入了新问题，当参与者接收到 preCommit 消息后，如果网络出现分区，此时协调者所在节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p><h4 id="何时选择三阶段提交分布式事务？"><a href="#何时选择三阶段提交分布式事务？" class="headerlink" title="何时选择三阶段提交分布式事务？"></a>何时选择三阶段提交分布式事务？</h4><p>两阶段提交协议中所存在的长时间阻塞状态发生的几率还是非常低的，所以虽然三阶段提交协议相对于两阶段提交协议对于数据强一致性更有保障，但是因为效率问题，两阶段提交协议在实际系统中反而更加受宠。</p><h3 id="补偿事务（TCC）-基于-TCC-实现的分布式事务"><a href="#补偿事务（TCC）-基于-TCC-实现的分布式事务" class="headerlink" title="补偿事务（TCC）- 基于 TCC 实现的分布式事务"></a>补偿事务（TCC）- 基于 TCC 实现的分布式事务</h3><p>TCC（Try-Confirm-Cancel）实际上是服务化的两阶段提交协议，是一种达到最终一致性的补偿性事务，相对于 XA 等传统模型，其特征在于它不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。其核心思想是：”针对每个操作都要注册一个与其对应的确认和补偿（撤销）操作”。它分为三个阶段：Try、Confirm、Cancel，业务开发者需要实现这三个服务接口：</p><ul><li>Try 阶段：完成所有业务检查，预留必须的业务资源，所有参与者的 Try 接口都成功了，事务管理器会提交事务，并调用每个参与者的 Confirm 接口真正提交业务操作，否则调用每个参与者的 Cancel 接口回滚事务。</li><li>Confirm 阶段：真正执行的业务逻辑，不做任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必须能成功。另外，Confirm 操作需满足幂等性，保证一笔分布式事务能且只能成功一次。</li><li>Cancel 阶段：释放 Try 阶段预留的业务资源。同样的，Cancel 操作也需要满足幂等性。</li></ul><p>事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的 try 接口，完成一阶段准备。之后事务协调器会根据 try 接口返回情况，决定调用 confirm 接口或者 cancel 接口。如果接口调用失败，会进行重试。事务协调器记录了全局事务的推进状态以及各子事务的执行状态，负责推进各个子事务共同进行提交或者回滚。同时负责在子事务处理超时后不停重试，重试不成功后转手工处理，用以保证事务的最终一致性。 </p><p><img src="/media/15743169568096/1334519-20180307150648591-1729601878.png" alt="TCC 方案整体流程图"></p><h4 id="业务场景介绍"><a href="#业务场景介绍" class="headerlink" title="业务场景介绍"></a>业务场景介绍</h4><p>假设现在有一个电商系统，里面有一个支付订单的场景。那对一个订单支付之后，我们需要做下面的步骤：</p><p>[1] 更改订单的状态为“已支付” - 对本地的的订单数据库修改订单状态为 “已支付”<br>[2] 扣减商品库存 - 调用库存服务扣减库存<br>[3] 给会员增加积分 - 调用积分服务增加积分<br>[4] 创建销售出库单通知仓库发货 - 调用仓储服务通知发货</p><p>对于分布式事务来说，上面那几个步骤，要么全部成功，如果任何一个服务的操作失败了，就全部一起回滚，撤销已经完成的操作。</p><h5 id="TCC-实现阶段一：Try"><a href="#TCC-实现阶段一：Try" class="headerlink" title="TCC 实现阶段一：Try"></a>TCC 实现阶段一：Try</h5><p><strong>订单服务</strong>：修改订单的状态为支付中 OrderStatus.UPDATING<br><strong>库存服务</strong>：库存数量不变，可销售库存数量减 1，设计一个单独的冻结库存的字段 freeze_inventory 数量加 1，表示有 1 个库存被冻结<br><strong>积分服务</strong>：会员积分不变，设计一个单独的预增加积分字段 prepare_add_credit 数量设置为 10，表示有 10 个积分准备增加<br><strong>仓储服务</strong>：先创建一个销售出库单，但是这个销售出库单的状态是 “UNKNOWN”未知</p><h5 id="TCC-实现阶段二：Confirm"><a href="#TCC-实现阶段二：Confirm" class="headerlink" title="TCC 实现阶段二：Confirm"></a>TCC 实现阶段二：Confirm</h5><p><strong>订单服务</strong>：修改订单的状态为已支付 OrderStatus.PAYED<br><strong>库存服务</strong>：将冻结库存的字段 freeze_inventory 数量清空，表示正式完成了库存的扣减<br><strong>积分服务</strong>：将预增加积分字段 prepare_add_credit 10 个积分扣掉，然后加入实际的会员积分字段中<br><strong>仓储服务</strong>：将销售出库单的状态正式修改为 “CREATED” 已创建，可以供仓储管理人员查看和使用</p><h5 id="TCC-实现阶段三：Cancel"><a href="#TCC-实现阶段三：Cancel" class="headerlink" title="TCC 实现阶段三：Cancel"></a>TCC 实现阶段三：Cancel</h5><p><strong>订单服务</strong>：修改订单的状态为已取消 OrderStatus.CANCELED<br><strong>库存服务</strong>：将冻结库存的字段 freeze_inventory 1 个库粗扣掉，然后加入可销售库存字段中<br><strong>积分服务</strong>：将预增加积分字段 prepare_add_credit 10 个积分扣掉<br><strong>仓储服务</strong>：将销售出库单的状态正式修改为 “CANCELED” 已取消</p><p>如果使用基于 TCC 实现的分布式事务，最好选择某种 TCC 分布式事务框架， 事务的 Try、Confirm、Cancel 三个状态交给框架来感知 。服务调用链路依次执行 Try 逻辑，如果都正常的话，TCC 分布式事务框架推进执行 Confirm 逻辑，完成整个事务；如果某个服务的 Try 逻辑有问题，TCC 分布式事务框架感知到之后就会推进执行各个服务的 Cancel 逻辑，撤销之前执行的各种操作。这里笔者给大家推荐几个比较不错的 TCC 框架：ByteTCC，TCC-transaction，Himly。</p><h4 id="TCC-异常控制"><a href="#TCC-异常控制" class="headerlink" title="TCC 异常控制"></a>TCC 异常控制</h4><p>在微服务架构下，很有可能出现网络超时、重发，机器宕机等一系列的异常 Case。一旦遇到这些 Case，就会导致我们的分布式事务执行过程出现异常。最常见的主要是这三种异常，分别是空回滚、幂等、悬挂。</p><h5 id="允许空回滚"><a href="#允许空回滚" class="headerlink" title="允许空回滚"></a>允许空回滚</h5><p>什么是空回滚？事务协调器在调用 TCC 服务的一阶段 Try 操作时，可能会出现因为丢包而导致的网络超时，此时事务管理器会触发二阶段回滚，调用 TCC 服务的 Cancel 操作，而 Cancel 操作调用未出现超时。</p><p>TCC 服务在未收到 Try 请求的情况下收到 Cancel 请求，这种场景被称为空回滚；空回滚在生产环境经常出现，用户在实现 TCC 服务时，应允许允许空回滚的执行，即收到空回滚时返回成功。</p><p><img src="/media/15743169568096/1553570682221-18bc59aa-3ffb-4eeb-acdd-9441678807fa.png" alt="TCC 空回滚流程"></p><h5 id="防悬挂控制"><a href="#防悬挂控制" class="headerlink" title="防悬挂控制"></a>防悬挂控制</h5><p>事务协调器在调用 TCC 服务的一阶段 Try 操作时，可能会出现因网络拥堵而导致的超时，此时事务管理器会触发二阶段回滚，调用 TCC 服务的 Cancel 操作，Cancel 调用未超时；在此之后，拥堵在网络上的一阶段 Try 数据包被 TCC 服务收到，出现了二阶段 Cancel 请求比一阶段 Try 请求先执行的情况，此 TCC 服务在执行晚到的 Try 之后，将永远不会再收到二阶段的 Confirm 或者 Cancel ，造成 TCC 服务悬挂。</p><p>用户在实现  TCC 服务时，要允许空回滚，但是要拒绝执行空回滚之后 Try 请求，要避免出现悬挂。</p><p><img src="/media/15743169568096/1553570682237-7c484aae-f28e-4f55-a42d-4be6af6f4c1a.png" alt="TCC 悬挂流程"></p><h5 id="幂等控制"><a href="#幂等控制" class="headerlink" title="幂等控制"></a>幂等控制</h5><p>无论是网络数据包重传，还是异常事务的补偿执行，都会导致 TCC 服务的 Try、Confirm 或者 Cancel 操作被重复执行；用户在实现 TCC 服务时，需要考虑幂等控制，即 Try、Confirm、Cancel 执行一次和执行多次的业务结果是一样的。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>TCC 方案的处理流程与 2PC 方案的处理流程类似，不过 2PC 通常都是在跨库的 DB 层面，而 TCC 本质上就是一个应用层面的 2PC，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据库操作的粒度，使得降低锁冲突、提高吞吐量成为可能。当然 TCC 方案也有不足之处，集中表现在以下两个方面：</p><ul><li>对应用的侵入性强：业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，应用侵入性较强，改造成本高。</li><li>实现难度较大：需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm 和 cancel 接口必须实现幂等。</li></ul><h4 id="何时选择基于-TCC-实现的分布式事务？"><a href="#何时选择基于-TCC-实现的分布式事务？" class="headerlink" title="何时选择基于 TCC 实现的分布式事务？"></a>何时选择基于 TCC 实现的分布式事务？</h4><p>TCC 方案适用于时效性要求高，如转账、支付等场景，因此 TCC 方案在电商、金融领域落地较多，但是上述原因导致 TCC 方案大多被研发实力较强、有迫切需求的大公司所采用。微服务倡导服务的轻量化、易部署，而 TCC 方案中很多事务的处理逻辑需要应用自己编码实现，对业务的侵入强，复杂且开发量大。因此，TCC 实际上是最为复杂的一种情况，其能处理所有的业务场景，但无论出于性能上的考虑，还是开发复杂度上的考虑，都应该尽量避免该类事务。</p><h3 id="SAGA-基于-Saga-实现的分布式事务"><a href="#SAGA-基于-Saga-实现的分布式事务" class="headerlink" title="SAGA - 基于 Saga 实现的分布式事务"></a>SAGA - 基于 Saga 实现的分布式事务</h3><p>Saga 事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的 Hector Garcia-Molina 和 Kenneth Salem 等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么 Sagas 工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p><p>Saga 的具体实现分为两种：协同式（Choreography） 以及 编排式（Orchestration）</p><h4 id="协同式（Choreography）"><a href="#协同式（Choreography）" class="headerlink" title="协同式（Choreography）"></a>协同式（Choreography）</h4><p>这种模式下不存在协调器的概念，每个节点均对自己的上下游负责，在监听处理上游节点事件的同时，对下游节点发布事件。  把 Saga 的决策和执行顺序逻辑分布在 Saga 的每一个参与方中，它们通过交换事件的方式来进行沟通。</p><p><img src="/media/15743169568096/879e4b44135373054caa605edc7e4c76.png" alt="Saga 协同式模式流程图"></p><h4 id="编排式（Orchestration）"><a href="#编排式（Orchestration）" class="headerlink" title="编排式（Orchestration）"></a>编排式（Orchestration）</h4><p>把 Saga 的决策和执行顺序逻辑集中在一个 Saga 编排器类中。Saga 编排器发出命令式消息给每个 Saga 参与方，指示这些参与方服务完成具体操作。该中心节点，即协调器知道整个事务的分布状态，相比于无中心节点方式，该方式有着许多优点：（1）能够避免事务之间的循环依赖关系；（2）参与者只需要执行命令 / 回复，降低参与者的复杂性；（3）开发测试门槛低；（4）在添加新步骤时，事务复杂性保持线性，回滚更容易管理。因此大多数 Saga 模型实现均采用了这种思路。</p><p><img src="/media/15743169568096/1dd14fd07a4f58fed17297fab33fd651.png" alt="Saga 编排式模式流程图"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>Saga 方案的优点在于其降低了事务粒度，使得事务扩展更加容易，同时采用了异步化方式提升性能。但是其缺点在于很多时候很难定义补偿接口，回滚代价高，而且由于 Saga 在执行过程中采用了先提交后补偿的思路进行操作，所以单个子事务在并发提交时的隔离性很难保证。</p><h4 id="何时选择基于-Saga-实现的分布式事务？"><a href="#何时选择基于-Saga-实现的分布式事务？" class="headerlink" title="何时选择基于 Saga 实现的分布式事务？"></a>何时选择基于 Saga 实现的分布式事务？</h4><p>Saga 方案适用于无需马上返回业务发起方最终状态的场景，例如：你的请求已提交，请稍后查询或留意通知之类的场景。Saga 方案中所有的本地子事务执行过程中，都无需等待其调用的子事务执行，减少了加锁的时间，这在事务流程较多较长的业务中性能优势更为明显。同时，其利用队列进行进行通讯，具有削峰填谷的作用。因此该形式适用于不需要同步返回发起方执行最终结果、可以进行补偿、对性能要求较高、不介意额外编码的业务场景。</p><h3 id="事务消息-基于可靠消息最终一致性实现的分布式事务"><a href="#事务消息-基于可靠消息最终一致性实现的分布式事务" class="headerlink" title="事务消息 - 基于可靠消息最终一致性实现的分布式事务"></a>事务消息 - 基于可靠消息最终一致性实现的分布式事务</h3><p>基于普通消息的最终一致性分布式事务方案存在的一致性问题：（1）以订单创建为例，订单系统先创建订单(本地事务)，再发送消息给下游处理；如果订单创建成功，然而消息没有发送出去，那么下游所有系统都无法感知到这个事件，会出现脏数据；（2）如果先发送订单消息，再创建订单；那么就有可能消息发送成功，但是在订单创建的时候却失败了，此时下游系统却认为这个订单已经创建，也会出现脏数据。</p><p>此时可能有同学会想，我们可否将消息发送和业务处理放在同一个本地事务中来进行处理，如果业务消息发送失败，那么本地事务就回滚，这样是不是就能解决消息发送的一致性问题呢？</p><table><thead><tr><th><strong>可能的情况</strong></th><th><strong>一致性</strong></th></tr></thead><tbody><tr><td>订单处理成功，然后突然宕机，事务未提交，消息没有发送出去</td><td>一致</td></tr><tr><td>订单处理成功，由于网络原因或者 MQ 宕机，消息没有发送出去，事务回滚</td><td>一致</td></tr><tr><td>订单处理成功，消息发送成功，但是 MQ 由于其他原因，导致消息存储失败，事务回滚</td><td>一致</td></tr><tr><td>订单处理成功，消息存储成功，但是 MQ 处理超时，从而 ACK 确认失败，导致发送方本地事务回滚</td><td>不一致</td></tr></tbody></table><p>对于消息发送的异常情况分析，我们可以看到，使用基于普通消息的最终一致性分布式事务方案无论如何，都无法保证业务处理与消息发送两边的一致性，其根本的原因就在于：远程调用，结果最终可能为成功、失败、超时；而对于超时的情况，处理方最终的结果可能是成功，也可能是失败，调用方是无法知晓的。为了保证两边数据的一致性，我们只能从其他地方寻找新的突破口。</p><h4 id="事物消息"><a href="#事物消息" class="headerlink" title="事物消息"></a>事物消息</h4><p>由于传统的处理方式无法解决消息生成者本地事务处理成功与消息发送成功两者的一致性问题，因此事务消息就诞生了，事务消息特性可以看作是两阶段协议的消息实现方式，用以确保在以消息中间件解耦的分布式系统中本地事务的执行和消息的发送，可以以原子的方式进行。</p><p>事务消息作为一种异步确保型事务，本质就是为了解决本地事务执行与消息发送的原子性问题。目前，事务消息在多种分布式消息中间件中均有实现，但是其实现方式思路却各有不同。</p><h4 id="传统事务消息实现"><a href="#传统事务消息实现" class="headerlink" title="传统事务消息实现"></a>传统事务消息实现</h4><p>传统事务消息实现，一种思路是依赖于 AMQP 协议用来确保消息发送成功，AMQP 模式下需要在发送事务消息时进行两阶段提交，首先进行 tx_select 开启事务，然后再进行消息发送，最后进行消息的 commit 或者是 rollback。这个过程可以保证在消息发送成功的同时本地事务也一定成功执行，但事务粒度不好控制，而且会导致性能急剧下降，同时依然无法解决本地事务执行与消息发送的原子性问题。</p><p>还有另外一种思路，就是通过保证多条消息的同时可见性来保证事务一致性。但是此类消息事务实现机制更多的是用到事务循环（consume-transform-produce）场景中，其本质还是用来保证消息自身事务，并没有把外部事务包含进来。</p><h4 id="RocketMQ-事务消息实现"><a href="#RocketMQ-事务消息实现" class="headerlink" title="RocketMQ 事务消息实现"></a>RocketMQ 事务消息实现</h4><p>RocketMQ 事务消息设计则主要是为了解决 Producer 端的消息发送与本地事务执行的原子性问题，RocketMQ 的设计中 broker 与 producer 端的双向通信能力，使得 broker 天生可以作为一个事务协调者存在；而 RocketMQ 本身提供的存储机制，则为事务消息提供了持久化能力；RocketMQ 的高可用机制以及可靠消息设计，则为事务消息在系统在发生异常时，依然能够保证事务的最终一致性达成。</p><p>RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p><p><img src="/media/15743169568096/66b6ae1dec5b96084c3a6d29174a20e3.png" alt="RocketMQ 事务消息实现流程"></p><ol><li>事务发起方首先发送 prepare 消息到 MQ。</li><li>在发送 prepare 消息成功后执行本地事务。</li><li>根据本地事务执行结果返回 commit 或者是 rollback。</li><li>如果消息是 rollback，MQ 将删除该 prepare 消息不进行下发，如果是 commit 消息，MQ 将会把这个消息发送给 consumer 端。</li><li>如果执行本地事务过程中，执行端挂掉，或者超时，MQ 将会不停的询问其同组的其它 producer 来获取状态。</li><li>consumer 端的消费成功机制有 MQ 保证。</li></ol><p>在具体实现上，RocketMQ 通过使用 Half Topic 以及 Operation Topic 两个内部队列来存储事务消息推进状态。其中，Half Topic 对应队列中存放着 prepare 消息，Operation Topic 对应的队列则存放了 prepare message 对应的 commit/rollback 消息，消息体中则是 prepare message 对应的 offset，服务端定期扫描消息集群中的事物消息，比对两个队列的差值来找到尚未提交的超时事务，进行回查。</p><p>从用户侧来说，用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可；而在 service 层，则对事务消息的两阶段提交进行了抽象，同时针对超时事务实现了回查逻辑，通过不断扫描当前事务推进状态，来不断反向请求 Producer 端获取超时事务的执行状态，在避免事务挂起的同时，也避免了 Producer 端的单点故障。而在存储层，RocketMQ 通过 Bridge 封装了与底层队列存储的相关操作，用以操作两个对应的内部队列，用户也可以依赖其它存储介质实现自己的 service，RocketMQ 会通过 ServiceProvider 加载进来。 </p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>总结一下关于事物消息的常见问题：</p><ol><li>如果 consumer 消费失败，是否需要 producer 做回滚呢？</li></ol><p>答：事务消息适用于上游事务对下游事务无依赖的场景，即 producer 不会因为 consumer 消费失败而做回滚，采用事务消息的应用，其所追求的是高可用和最终一致性，消息消费失败的话，MQ 自己会负责重推消息，直到消费成功。因此，事务消息是针对生产端而言的，而消费端，消费端的一致性是通过 MQ 的重试机制来完成的。</p><ol start="2"><li>如果 consumer 端因为业务异常而导致回滚，那么岂不是两边最终无法保证一致性?</li></ol><p>答：基于消息的最终一致性方案必须保证消费端在业务上的操作没障碍，它只允许系统异常的失败，不允许业务上的失败，比如在你业务上抛出个 NPE 之类的问题，导致你消费端执行事务失败，那就很难做到一致了。</p><h4 id="何时选择基于可靠消息的最终一致性实现的分布式事务？"><a href="#何时选择基于可靠消息的最终一致性实现的分布式事务？" class="headerlink" title="何时选择基于可靠消息的最终一致性实现的分布式事务？"></a>何时选择基于可靠消息的最终一致性实现的分布式事务？</h4><p>事务消息较好的解决了事务的最终一致性问题，事务发起方仅需要关注本地事务执行以及实现回查接口给出事务状态判定等实现，而且在上游事务峰值高时，可以通过消息队列，避免对下游服务产生过大压力。所以，事务消息不仅适用于上游事务对下游事务无依赖的场景，还可以与一些传统分布式事务架构相结合，而 MQ 的服务端作为天生的具有高可用能力的协调者，使基于可靠消息的最终一致性分布式事务解决方案，用以满足各种场景下的分布式事务需求。</p><p>不过这种方式技术实现的难度比较大，目前主流的开源 MQ（ActiveMQ、RabbitMQ、Kafka、RocketMQ）中只有 RocketMQ 实现对事物消息的支持，其余 MQ 均未实现对事务消息的支持，因此，如果我们希望强依赖一个 MQ 的事务消息来做到消息最终一致性的话，在目前的情况下，技术选型上只能去选择 RocketMQ 来解决。</p><h3 id="本地消息表-基于本地消息最终一致性实现的分布式事务"><a href="#本地消息表-基于本地消息最终一致性实现的分布式事务" class="headerlink" title="本地消息表 - 基于本地消息最终一致性实现的分布式事务"></a>本地消息表 - 基于本地消息最终一致性实现的分布式事务</h3><p>由于并非所有的 MQ 都支持事务消息，假如我们不选择 RocketMQ 来作为系统的 MQ，是否能够做到消息的最终一致性呢？答案是可以的。</p><p>基于 MQ 事物消息的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。因此，我们可以以事物消息的实现方式去看待基于本地消息表的分布式事务方案。</p><p>本地消息表这种实现方式应该是业界使用最多的，该方案也是目前我参与的项目组所使用的分布式事务方案，其核心思想是将分布式事务拆分成本地事务进行处理，通过消息日志的方式来异步执行，这种思路是来源于 ebay。</p><p><img src="/media/15743169568096/3.jpg" alt="本地消息表方案实现流程图"></p><p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，保证了业务与消息同时成功持久化；通过定时任务轮询事务消息表的数据发送事务消息，如果消息投递失败，依靠重试机制重试发送，发送成功后将消息状态更新或者消息清除；事务被动方基于消息中间件消费事务消息表中的事务，如果处理失败，那么依赖 MQ 本身的重试来完成重试执行，同时需要注意重试的幂等行设计；如果是业务上面的失败，可以给事务主动发起方发送一个业务补偿消息，通知事务主动发起方进行回滚等操作。事务主动发起和事务被动方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。这样设计可以避免”业务处理成功 + 事务消息发送失败”，或”业务处理失败 + 事务消息发送成功”的棘手情况出现，保证 2 个系统事务的数据一致性。</p><h4 id="何时选择基于本地消息最终一致性实现的分布式事务？"><a href="#何时选择基于本地消息最终一致性实现的分布式事务？" class="headerlink" title="何时选择基于本地消息最终一致性实现的分布式事务？"></a>何时选择基于本地消息最终一致性实现的分布式事务？</h4><p>基于本地消息最终一致性分布式事务是一种非常经典的分布式事务实现方案，基本避免了分布式事务，实现了“最终一致性”。该方法从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。但是该方案与具体的业务场景绑定，耦合性强，不可公用。 消息数据与业务数据同库，占用业务系统资源。 业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</p><p>基于消息实现的事务适用于分布式事务的提交或回滚只取决于事务发起方的业务需求，其他数据源的数据变更跟随发起方进行的业务场景。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>上述几种的分布式事务方案中，笔者大致总结了其设计思路、流程、优势、劣势、使用场景等，相信读者已经有了一定的理解。其实分布式系统的事务一致性本身是一个技术难题，目前没有一种很简单很完美的方案能够应对所有场景。笔者认为对于分布式事务具体还是要使用者根据不同的业务场景去抉择，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。</p><p>微服务兴起这几年涌现出不少分布式事务框架，比如 <a href="https://github.com/liuyangming/ByteTCC" target="_blank" rel="noopener">ByteTCC</a>、<a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="noopener">TCC-transaction</a>、<a href="https://github.com/QNJR-GROUP/EasyTransaction" target="_blank" rel="noopener">TCC-transaction</a> 以及最近很火爆的 <a href="https://github.com/seata/seata" target="_blank" rel="noopener">Seata</a>。目前笔者也在阅读、研究 Seata 源码，如果诸位对分布式事务感兴趣，我想 Seata 框架是一个值得研究的框架！</p><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://www.zhenchao.org/2016/08/23/protocol/2pc-and-3pc/" target="_blank" rel="noopener">对分布式事务及两阶段提交、三阶段提交的理解</a><br>[2]. <a href="http://www.zhenchao.org/2016/08/23/protocol/2pc-and-3pc/#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE%EF%BC%883PC%EF%BC%9AThree-Phrase-Commit%EF%BC%89" target="_blank" rel="noopener">分布式事务：两阶段提交与三阶段提交</a><br>[3]. <a href="https://yq.aliyun.com/articles/624058" target="_blank" rel="noopener">里程碑 | Apache RocketMQ 正式开源分布式事务消息</a><br>[4]. <a href="https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/" target="_blank" rel="noopener">分布式事务 Seata Saga 模式首秀以及三种模式详解 | Meetup#3 回顾</a><br>[5]. <a href="https://www.sofastack.tech/blog/sofa-channel-4-retrospect/" target="_blank" rel="noopener">分布式事务 Seata TCC 模式深度解析 | SOFAChannel#4 直播整理</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. XA：为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义分布式事务处理模型 DTP（Distributed Transaction Processing Reference Model），DTP 模型定义 TM 和 RM 之间通讯的接口规范叫 XA。XA 协议由 Tuxedo 首先提出的，并交给 X/Open 组织，作为资源管理器 RM（Resource Manager）与事务管理器 TM（Transaction Manager）之间进行通信的接口标准。目前，Oracle、Informix、DB2 和 Sybase 等各大数据库厂家都提供对 XA 的支持。XA 协议采用两阶段提交方式来管理分布式事务。在 XA 规范中，数据库充当 RM 角色，应用需要充当 TM 的角色，即生成全局的 txId，调用 XAResource 接口，把多个本地事务协调为全局统一的分布式事务。</small></p><hr><h2 id="分布式设计之美系列"><a href="#分布式设计之美系列" class="headerlink" title="分布式设计之美系列"></a>分布式设计之美系列</h2><ul><li><a href="e8097e40.html">分布式设计之美（一）：主流分布式锁实现方案</a></li><li><a href="691d905d.html">分布式设计之美（二）：微服务架构下分布式事务解决方案</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在微服务架构中，随着服务的逐步拆分，数据库私有已经成为共识，这也导致所面临的分布式事务问题成为微服务落地过程中一个非常难以逾越的障碍，但是目前尚没有一个完整通用的解决方案。&lt;/p&gt;
&lt;p&gt;其实不仅仅是在微服务架构中，随着用户访问量的逐渐上涨，数据库甚至是服务的分片、分区、水平拆分、垂直拆分已经逐渐成为较为常用的提升瓶颈的解决方案，因此越来越多的原子操作变成了跨库甚至是跨服务的事务操作。最终结果是在对高性能、高扩展性、高可用性的追求的道路上，我们开始逐渐放松对一致性的追求，但是在很多场景下，尤其是账务，电商等业务中，不可避免的存在着一致性问题，使得我们不得不去探寻一种机制，用以在分布式环境中保证事务的一致性。&lt;/p&gt;
&lt;p&gt;分布式事务有多种主流形态，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 2PC（两阶段提交）实现的分布式事务&lt;/li&gt;
&lt;li&gt;基于 3PC（三阶段提交）实现的分布式事务&lt;/li&gt;
&lt;li&gt;基于 TCC（补偿事务）实现的分布式事务&lt;/li&gt;
&lt;li&gt;基于 Saga 实现的分布式事务&lt;/li&gt;
&lt;li&gt;基于可靠消息（事务消息）最终一致性实现的分布式事务&lt;/li&gt;
&lt;li&gt;基于本地消息（本地消息表）最终一致性实现的分布式事务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，本文将对这些形态的分布式事务进行剖析，然后讲解一下如何根据业务选择对应的分布式事务形态。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://blog.maoning.vip/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="2PC" scheme="https://blog.maoning.vip/tags/2PC/"/>
    
      <category term="TCC" scheme="https://blog.maoning.vip/tags/TCC/"/>
    
      <category term="RocketMQ" scheme="https://blog.maoning.vip/tags/RocketMQ/"/>
    
      <category term="Saga" scheme="https://blog.maoning.vip/tags/Saga/"/>
    
  </entry>
  
  <entry>
    <title>Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</title>
    <link href="https://blog.maoning.vip/archives/d63e1e23.html"/>
    <id>https://blog.maoning.vip/archives/d63e1e23.html</id>
    <published>2019-11-20T10:49:08.000Z</published>
    <updated>2019-11-20T11:09:50.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开始本章的讲解之前，我们首先从宏观角度回顾一下 Redis 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？</p><p>Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。</p><p>在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。</p><a id="more"></a><h2 id="Redis-HA-实践（Redis-Sentinel）"><a href="#Redis-HA-实践（Redis-Sentinel）" class="headerlink" title="Redis HA 实践（Redis Sentinel）"></a>Redis HA 实践（Redis Sentinel）</h2><h3 id="Redis-Sentinel-概述"><a href="#Redis-Sentinel-概述" class="headerlink" title="Redis Sentinel 概述"></a>Redis Sentinel 概述</h3><p>Sentinel（哨岗、哨兵）是 Redis 的高可用（high availability）解决方案：由一个或多个 Sentinel 实例（instance）组成的 Sentinel 系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><p><img src="/media/15729465186457/20191105190000.jpg" alt="20191105190000"></p><p><img src="/media/15729465186457/20191105190002.jpg" alt="20191105190002"></p><p>当 server1 的下线时长超过用户设定的下线时长上限时，Sentinel 系统就会对 server1 执行故障转移操作：</p><ul><li>首先，Sentinel 系统会挑选 server1 属下的其中一个从服务器，并将这个被选中的从服务升级为新的主服务器。</li><li>之后，Sentinel 系统会向 server1 属下的所有从服务器发送新的复制指令，让他们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li><li>另外，Sentinel 还会继续监视已下线的 server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li></ul><p>Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务：</p><ul><li>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul><h3 id="Redis-Sentinel-重点总结"><a href="#Redis-Sentinel-重点总结" class="headerlink" title="Redis Sentinel 重点总结"></a>Redis Sentinel 重点总结</h3><ul><li>Sentinel 只是一个运行在特殊模式下的 Redis 服务器，因此初始化服务器时将普通 Redis 服务器使用的代码替换成 Sentinel 专门代码，它使用了和普通模式不同的命令表，所以 Sentinel 模式能够使用的命令和普通 Redis 服务器能够使用的命令不同。</li><li>Sentinel 会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接，其中命令连接用于向主服务器发送命令请求，而订阅连接则用于接收指定频道的消息。</li><li>Sentinel 通过主服务器发送 INFO 命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构，以及连向这些从服务器的命令连接和订阅连接。在一般情况下，Sentinel 以每十秒一次的频率向被监视的主服务器和从服务器发送 INFO 命令，当主服务器处于下线状态，或者 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</li><li>对于监视同一个主服务器和从服务器的多个 Sentinel 来说，它们会以每两秒一次的频率，通过向被监视服务器的 _sentinel_:hello 频道发送消息来向其他 Sentinel 宣告自己的存在。每个 Sentinel 也会从 _sentinel_:hello 频道中接收其他 Sentinel 发来的消息，并根据这些消息为其他 Sentinel 创建相应的实例结构以及命令连接。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接，Sentinel 与 Sentinel 之间则只创建命令连接。</li><li>Sentinel 以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 PING 命令，并根据实例对 PING 命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向 Sentinel 发送无效回复时，Sentinel 会将这个实例判断为主观下线。</li><li>当 Sentinel 将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其它 Sentinel 进行询问，看它们是否同意这个主服务器已经进入主观下线状态。当 Sentinel 收集到足够多的的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。  </li><li>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头 Sentinel<sup>[1]</sup>，并由领头 Sentinel 对下线主服务器进行故障转移操作。</li></ul><h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a>Redis Sentinel 搭建</h3><h4 id="Redis-Sentinel-部署技巧及其环境"><a href="#Redis-Sentinel-部署技巧及其环境" class="headerlink" title="Redis Sentinel 部署技巧及其环境"></a>Redis Sentinel 部署技巧及其环境</h4><ul><li>一个健壮的部署至少需要三个哨兵实例，并且使用奇数个 Sentinel。</li><li>三个哨兵实例应该放置在客户使用独立方式确认故障的计算机或虚拟机中，例如不同的物理机或不同可用区域的虚拟机。</li><li>哨兵配置文件中只需要配置主从复制中的主副本 ip 和端口即可，当主从进行切换时哨兵会自动修改哨兵配置文件中的主副本 ip 为新在主副本 ip。 </li></ul><p><img src="/media/15729465186457/20170405093045288.png" alt="20170405093045288"></p><p>由于本人没有这么多服务器，因此在一台机器上模拟一个 Redis Sentinel 集群。</p><table><thead><tr><th><strong>角色</strong></th><th><strong>IP 地址</strong></th><th><strong>端口号</strong></th></tr></thead><tbody><tr><td>Redis Master</td><td>127.0.0.1</td><td>6380</td></tr><tr><td>Redis Slave-01</td><td>127.0.0.1</td><td>6381</td></tr><tr><td>Redis Slave-02</td><td>127.0.0.1</td><td>6382</td></tr><tr><td>Redis Slave-03</td><td>127.0.0.1</td><td>6383</td></tr><tr><td>Redis Sentinel-01</td><td>127.0.0.1</td><td>26381</td></tr><tr><td>Redis Sentinel-02</td><td>127.0.0.1</td><td>26382</td></tr><tr><td>Redis Sentinel-03</td><td>127.0.0.1</td><td>26383</td></tr></tbody></table><h4 id="Redis-Sentinel-安装指南"><a href="#Redis-Sentinel-安装指南" class="headerlink" title="Redis Sentinel 安装指南"></a>Redis Sentinel 安装指南</h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># mkdir /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># wget http://download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># tar -zvxf redis-5.0.6.tar.gz -C /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># cd /usr/local/redis/redis-5.0.6/</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-5.0</span><span class="number">.6</span>]<span class="meta"># make PREFIX=/usr/local/redis install</span></span><br></pre></td></tr></table></figure><p>2、设置 Redis 主服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span></span><br><span class="line">[root@VM_24_98_centos redis-master]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/redis.conf /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span>/</span><br><span class="line">[root@VM_24_98_centos redis-master]# vim /usr/<span class="keyword">local</span>/redis/redis-master/redis<span class="number">-6380</span>/redis.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Master 主服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启远程连接</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-master/redis-6380/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-master/redis-6380/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-master/redis-6380/</span><br><span class="line"><span class="comment"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="comment"># 开启 AOF 持久化</span></span><br><span class="line">appendonly <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Master 主服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6380</span>]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6380</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6380&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:master</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:5c1034ac4dec31d6a4ae883e1eaacca3a78bc3b6</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:0</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:0</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:0</span></span><br><span class="line"><span class="section">repl_backlog_histlen:0</span></span><br></pre></td></tr></table></figure><p>3、设置 Redis 从服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span></span><br><span class="line">[root@VM_24_98_centos redis-slave]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/redis.conf /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-slave]# vim /usr/<span class="keyword">local</span>/redis/redis-slave/redis<span class="number">-6381</span>/redis.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Slave 从服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启远程连接</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6381</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-slave/redis-6381/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-slave/redis-6381/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-slave/redis-6381/</span><br><span class="line"><span class="comment"># 主从复制 Master 节点地址 + 端口</span></span><br><span class="line">replicaof 127.0.0.1 6380</span><br><span class="line"><span class="comment"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="comment"># 开启 AOF 持久化</span></span><br><span class="line">appendonly <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Slave 从服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6381</span>]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-6381/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-6381</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-slave/redis-6381/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6381 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6381&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:slave</span></span><br><span class="line"><span class="section">master_host:127.0.0.1</span></span><br><span class="line"><span class="section">master_port:6380</span></span><br><span class="line"><span class="section">master_link_status:up</span></span><br><span class="line"><span class="section">master_last_io_seconds_ago:5</span></span><br><span class="line"><span class="section">master_sync_in_progress:0</span></span><br><span class="line"><span class="section">slave_repl_offset:14</span></span><br><span class="line"><span class="section">slave_priority:100</span></span><br><span class="line"><span class="section">slave_read_only:1</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:8ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:14</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:1</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:1</span></span><br><span class="line"><span class="section">repl_backlog_histlen:14</span></span><br></pre></td></tr></table></figure><p>e. 同理，从服务器 redis-6382、redis-6383 按照上面的步骤部署。</p><p>4、Redis Sentinel 部署</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis]# mkdir -p /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span></span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# cp -r /usr/<span class="keyword">local</span>/redis/redis<span class="number">-5.0</span><span class="number">.6</span>/sentinel.conf /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span>/</span><br><span class="line">[root@VM_24_98_centos redis-sentinel]# vim /usr/<span class="keyword">local</span>/redis/redis-sentinel/redis<span class="number">-26381</span>/sentinel.conf</span><br></pre></td></tr></table></figure><p>b. 设置 Redis Sentinel 哨兵服务器配置环境</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 26381</span><br><span class="line"><span class="comment"># 守护进程</span></span><br><span class="line">daemonize <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-sentinel/redis-26381/redis.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-sentinel/redis-26381/redis.log</span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-sentinel/redis-26381/</span><br><span class="line"><span class="comment"># 指定监控 master&#123;2 表示多少个 sentinel 同意&#125;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6380 2</span><br><span class="line"><span class="comment"># 安全信息</span></span><br><span class="line">sentinel auth-pass mymaster foobared</span><br></pre></td></tr></table></figure><p>c. 启动 Redis Sentinel 哨兵服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-26381</span>]<span class="meta"># /usr/local/redis/bin/redis-sentinel /usr/local/redis/redis-sentinel/redis-26381/sentinel.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-26381</span>]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 26381</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:26381&gt; INFO SENTINEL</span></span><br><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line"><span class="section">sentinel_masters:1</span></span><br><span class="line"><span class="section">sentinel_tilt:0</span></span><br><span class="line"><span class="section">sentinel_running_scripts:0</span></span><br><span class="line"><span class="section">sentinel_scripts_queue_length:0</span></span><br><span class="line"><span class="section">sentinel_simulate_failure_flags:0</span></span><br><span class="line"><span class="section">master0:name=mymaster,status=ok,address=127.0.0.1:6380,slaves=3,sentinels=1</span></span><br></pre></td></tr></table></figure><p>e. 同理，哨兵服务器 redis-26382、redis-26383 按照上面的步骤部署</p><p>f. 查看 Redis Master 主服务器连接状况</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6380</span>&gt; INFO REPLICATION</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">3</span></span><br><span class="line">slave0:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6383</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">slave1:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6381</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">slave2:ip=<span class="number">127.0</span>.<span class="number">0.1</span>,<span class="keyword">port</span>=<span class="number">6382</span>,<span class="keyword">state</span>=online,offset=<span class="number">20836</span>,lag=<span class="number">0</span></span><br><span class="line">master_replid:cc8ef3fe2e51a714f5b73b2fbe3bd697cacbc453</span><br><span class="line">master_replid2:<span class="number">8</span>ecb8d89dba51e54aabb1c7feeda42fe6e6a8dc0</span><br><span class="line">master_repl_offset:<span class="number">20836</span></span><br><span class="line">second_repl_offset:<span class="number">1522</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">1</span></span><br><span class="line">repl_backlog_histlen:<span class="number">20836</span></span><br></pre></td></tr></table></figure><h3 id="Redis-Sentinel-场景测试"><a href="#Redis-Sentinel-场景测试" class="headerlink" title="Redis Sentinel 场景测试"></a>Redis Sentinel 场景测试</h3><p>模拟场景：Redis Master 节点挂掉，查看 Redis 集群状态。</p><p>Step1、关掉 Master 节点</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta">127.0.0.1:6380&gt;</span> SHUTDOWN</span><br></pre></td></tr></table></figure><p>Step2、通过哨兵查看集群状态</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 26381</span></span><br><span class="line"><span class="section">127.0.0.1:26381&gt; INFO SENTINEL</span></span><br><span class="line"><span class="comment"># Sentinel</span></span><br><span class="line"><span class="section">sentinel_masters:1</span></span><br><span class="line"><span class="section">sentinel_tilt:0</span></span><br><span class="line"><span class="section">sentinel_running_scripts:0</span></span><br><span class="line"><span class="section">sentinel_scripts_queue_length:0</span></span><br><span class="line"><span class="section">sentinel_simulate_failure_flags:0</span></span><br><span class="line"><span class="section">master0:name=mymaster,status=ok,address=127.0.0.1:6381,slaves=3,sentinels=3</span></span><br></pre></td></tr></table></figure><p>通过 Sentinel 信息可以看到，Master 节点已经自动切换到 6381 端口了，说明主节点挂掉后，6381 Slave 节点自动升级成为了 Master 节点。</p><p>通过 Sentinel 日志文件显示了 failover 的过程：</p><p><img src="/media/15729465186457/20191119161856.png" alt="20191119161856"></p><p>Step3、启动 6380 Redis 服务，然后查看节点角色，此时 6380 变成了 Slave，6381 为 Master 节点</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-master/redis-6380/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6380 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6380&gt; INFO REPLICATION</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line"><span class="section">role:slave</span></span><br><span class="line"><span class="section">master_host:127.0.0.1</span></span><br><span class="line"><span class="section">master_port:6381</span></span><br><span class="line"><span class="section">master_link_status:up</span></span><br><span class="line"><span class="section">master_last_io_seconds_ago:1</span></span><br><span class="line"><span class="section">master_sync_in_progress:0</span></span><br><span class="line"><span class="section">slave_repl_offset:782228</span></span><br><span class="line"><span class="section">slave_priority:100</span></span><br><span class="line"><span class="section">slave_read_only:1</span></span><br><span class="line"><span class="section">connected_slaves:0</span></span><br><span class="line"><span class="section">master_replid:84aa69ee0b191bba31162c26c4ddb1c87a705f7e</span></span><br><span class="line"><span class="section">master_replid2:0000000000000000000000000000000000000000</span></span><br><span class="line"><span class="section">master_repl_offset:782228</span></span><br><span class="line"><span class="section">second_repl_offset:-1</span></span><br><span class="line"><span class="section">repl_backlog_active:1</span></span><br><span class="line"><span class="section">repl_backlog_size:1048576</span></span><br><span class="line"><span class="section">repl_backlog_first_byte_offset:777789</span></span><br><span class="line"><span class="section">repl_backlog_histlen:4440</span></span><br></pre></td></tr></table></figure><h2 id="Redis-HA-实践（Redis-Cluster）"><a href="#Redis-HA-实践（Redis-Cluster）" class="headerlink" title="Redis HA 实践（Redis Cluster）"></a>Redis HA 实践（Redis Cluster）</h2><h3 id="Redis-Cluster-概述"><a href="#Redis-Cluster-概述" class="headerlink" title="Redis Cluster 概述"></a>Redis Cluster 概述</h3><p>Redis 集群是 Redis 提供的分布式数据库方案，集群通过分片（sharding）而非一致性哈希（consistency hashing）来进行数据分享，并提供复制和故障转移功能。Redis Cluster，主要是针对海量数据 + 高并发 + 高可用的场景。Redis Cluster 支撑 N 个 Redis Master Node，每个 Master Node 都可以挂载多个 Slave Node。Redis Cluster 节点间采用 Gossip 协议<sup>[2]</sup>进行通信。</p><p><strong>节点</strong>：一个 Redis 集群通常由多个节点（node）组成，连接各个节点的工作可以使用 CLUSTER MEET \&lt;ip> \&lt;port> 命令来完成，将各个独立的节点连接起来，构成一个包含多个节点的集群。向一个节点 node 发送 CLUSTER MEET 命令，可以让 node 节点与 ip 和 port 所指定的节点进行握手（handshake），当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</p><p><img src="/media/15729465186457/20191120113607.png" alt="20191120113607"></p><p><strong>槽指派</strong>：Redis 集群通过分片的方式来保存数据库中的键值对，集群的整数据库被分为 16384 个槽（slot），数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。Redis 集群有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中任何一个槽没有得到处理，那么集群处于下线状态（fail）。</p><p><img src="/media/15729465186457/20191120114329.png" alt="20191120114329"></p><h3 id="Redis-Cluster-重点总结"><a href="#Redis-Cluster-重点总结" class="headerlink" title="Redis Cluster 重点总结"></a>Redis Cluster 重点总结</h3><ul><li>节点通过握手来将其他节点添加到自己所处的集群当中。</li><li>集群中的 16384（2的14次方）个槽可以分别指派给集群中的各个节点，每个节点都会记录哪些槽指派给了自己，而哪些槽又被指派给其他节点。</li><li>节点在接到一个命令请求时，会先检查这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端转向至正在负责相关槽的节点。</li><li>对 Redis 集群的重新分片工作是由 redis-trib 负责执行的，重新分片的关键是将属于某个槽的所有键值对从一个节点转移至另外一个节点。重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</li><li>如果节点 A 正在迁移槽 i 至节点 B，那么当节点 A 没能在自己的数据库中找到命令指定的数据库键时，节点 A 会向客户端返回一个 ASK 错误，指引客户端到节点 B 继续查找指定的数据库键。</li><li>MOVED 错误表示槽的负责权已经从一个节点转移到了另外一个节点，而 ASK 错误只是两个节点在迁移槽的过程中使用的一种临时措施。</li><li>Redis 集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点用于复制主节点，并在主节点下线时，代替主节点继续处理命令请求。</li><li>集群中的节点通过发送和接收消息来进行通信，常见的消息包括 MEET、PING、PONG、PUBLISH、FAIL 五种。</li></ul><h3 id="Redis-Cluster-搭建"><a href="#Redis-Cluster-搭建" class="headerlink" title="Redis Cluster 搭建"></a>Redis Cluster 搭建</h3><h4 id="Redis-Cluster-部署技巧及其环境"><a href="#Redis-Cluster-部署技巧及其环境" class="headerlink" title="Redis Cluster 部署技巧及其环境"></a>Redis Cluster 部署技巧及其环境</h4><ul><li>Redis 集群至少需要 3 个节点，因为投票容错机制要求超过半数节点认为某个节点挂了该节点才是挂了，所以 2 个节点无法构成集群。</li><li>要保证集群的高可用，需要每个节点都有从节点，也就是备份节点，即三主三从，所以 Redis 集群至少需要 6 台服务器。</li><li>Redis 5.0 开始不再使用 Ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</li><li>不支持多数据库空间，集群模式下只能使用 db0 空间。</li></ul><p><img src="/media/15729465186457/20181225100026745.png" alt="20181225100026745"></p><p>由于资源有限，因此在一台机器上模拟一个 Redis Cluster。</p><table><thead><tr><th><strong>角色</strong></th><th><strong>IP 地址</strong></th><th><strong>端口号</strong></th></tr></thead><tbody><tr><td>Redis Cluster-Master-01-6391</td><td>127.0.0.1</td><td>6391</td></tr><tr><td>Redis Cluster-Master-02-6393</td><td>127.0.0.1</td><td>6393</td></tr><tr><td>Redis Cluster-Master-02-6395</td><td>127.0.0.1</td><td>6395</td></tr><tr><td>Redis Cluster-Slave-01-6394</td><td>127.0.0.1</td><td>6394</td></tr><tr><td>Redis Cluster-Slave-02-6396</td><td>127.0.0.1</td><td>6396</td></tr><tr><td>Redis Cluster-Slave-03-6392</td><td>127.0.0.1</td><td>6392</td></tr></tbody></table><h4 id="Redis-Cluster-安装指南"><a href="#Redis-Cluster-安装指南" class="headerlink" title="Redis Cluster 安装指南"></a>Redis Cluster 安装指南</h4><p>1、下载 Redis 服务软件包到服务器，解压后并编译安装。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># mkdir /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># wget http://download.redis.io/releases/redis-5.0.6.tar.gz</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># tar -zvxf redis-5.0.6.tar.gz -C /usr/local/redis</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># cd /usr/local/redis/redis-5.0.6/</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> redis<span class="number">-5.0</span><span class="number">.6</span>]<span class="meta"># make PREFIX=/usr/local/redis install</span></span><br></pre></td></tr></table></figure><p>2、设置 Redis Cluster  服务器</p><p>a. 创建目录以及复制配置文件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# <span class="keyword">mkdir</span> -p /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391</span><br><span class="line">[root@VM_24_98_centos ~]# cp -r /usr/<span class="keyword">local</span>/redis/redis-5.0.6/redis.<span class="keyword">conf</span> /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391/</span><br><span class="line">[root@VM_24_98_centos ~]# vim /usr/<span class="keyword">local</span>/redis/redis-<span class="keyword">cluster</span>/redis-6391/redis.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>b. 设置 Redis Cluster 服务器配置环境</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 开启远程连接</span></span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="keyword">protected</span>-mode no</span><br><span class="line"><span class="meta"># 端口号</span></span><br><span class="line">port <span class="number">6391</span></span><br><span class="line"><span class="meta"># 守护进程</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="meta"># 进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/redis.pid</span><br><span class="line"><span class="meta"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/redis.log</span><br><span class="line"><span class="meta"># 工作目录</span></span><br><span class="line">dir /usr/local/redis/redis-cluster/redis<span class="number">-6391</span>/</span><br><span class="line"><span class="meta"># 主服务器密码</span></span><br><span class="line">masterauth foobared</span><br><span class="line"><span class="meta"># 认证密码</span></span><br><span class="line">requirepass foobared</span><br><span class="line"><span class="meta"># 开启 AOF 持久化</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta"># 每秒调用一次 fsync</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># 开启集群</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta"># 集群的配置文件，首次启动会自动创建</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"><span class="meta"># 集群节点连接超时时间，15秒</span></span><br><span class="line">cluster-node-timeout <span class="number">15000</span></span><br></pre></td></tr></table></figure><p>c. 启动 Redis Cluster 服务器</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-6391/redis.conf</span></span><br><span class="line">[root<span class="symbol">@VM_24_98_centos</span> ~]<span class="meta"># ps -ef |grep redis</span></span><br></pre></td></tr></table></figure><p>d. 客户端测试连接</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-6391/redis.conf</span></span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6391 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="section">127.0.0.1:6391&gt; CLUSTER INFO</span></span><br><span class="line"><span class="section">cluster_state:fail</span></span><br><span class="line"><span class="section">cluster_slots_assigned:0</span></span><br><span class="line"><span class="section">cluster_slots_ok:0</span></span><br><span class="line"><span class="section">cluster_slots_pfail:0</span></span><br><span class="line"><span class="section">cluster_slots_fail:0</span></span><br><span class="line"><span class="section">cluster_known_nodes:1</span></span><br><span class="line"><span class="section">cluster_size:0</span></span><br><span class="line"><span class="section">cluster_current_epoch:0</span></span><br><span class="line"><span class="section">cluster_my_epoch:0</span></span><br><span class="line"><span class="section">cluster_stats_messages_sent:0</span></span><br><span class="line"><span class="section">cluster_stats_messages_received:0</span></span><br></pre></td></tr></table></figure><p>e. 同理，集群服务器 redis-6392、redis-6393 、redis-6394、redis-6395、redis-6396 按照上面的步骤部署</p><p>3、Redis 5.0 开始不再使用 ruby 搭建集群，而是直接使用客户端命令 redis-cli 来创建。</p><p>a. 创建顺序三主三从，前面三个是主后面三个是从。由于我们设置了redis集群的密码，所以要带上密码。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster create <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6393</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6395</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6392</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6394</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6396</span> --cluster-replicas <span class="number">1</span> -a foobared</span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120150814.png" alt="20191120150814"></p><p>b. 客户端测试连接</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:<span class="number">16384</span></span><br><span class="line">cluster_slots_ok:<span class="number">16384</span></span><br><span class="line">cluster_slots_pfail:<span class="number">0</span></span><br><span class="line">cluster_slots_fail:<span class="number">0</span></span><br><span class="line">cluster_known_nodes:<span class="number">6</span></span><br><span class="line">cluster_size:<span class="number">3</span></span><br><span class="line">cluster_current_epoch:<span class="number">6</span></span><br><span class="line">cluster_my_epoch:<span class="number">1</span></span><br><span class="line">cluster_stats_messages_ping_sent:<span class="number">1153</span></span><br><span class="line">cluster_stats_messages_pong_sent:<span class="number">1241</span></span><br><span class="line">cluster_stats_messages_sent:<span class="number">2394</span></span><br><span class="line">cluster_stats_messages_ping_received:<span class="number">1236</span></span><br><span class="line">cluster_stats_messages_pong_received:<span class="number">1153</span></span><br><span class="line">cluster_stats_messages_meet_received:<span class="number">5</span></span><br><span class="line">cluster_stats_messages_received:<span class="number">2394</span></span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> slave c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">5</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574234725711</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574234724000</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574234724708</span> <span class="number">6</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,master - <span class="number">0</span> <span class="number">1574234725000</span> <span class="number">1</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574234723000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br></pre></td></tr></table></figure><h3 id="Redis-Cluster-场景测试"><a href="#Redis-Cluster-场景测试" class="headerlink" title="Redis Cluster 场景测试"></a>Redis Cluster 场景测试</h3><p>（1）模拟场景：Redis Cluster 中 某个 Master 节点挂掉，查看 Redis Cluster 状态。</p><p>Step1、关掉 Cluster-Master-6391 节点</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]<span class="comment"># /usr/local/redis/bin/redis-cli -h 127.0.0.1 -p 6391 -a  foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta">127.0.0.1:6391&gt;</span> SHUTDOWN</span><br></pre></td></tr></table></figure><p>Step2、查看集群状态</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6393</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6393</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574236204772</span> <span class="number">4</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574236206778</span> <span class="number">6</span> connected</span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> master - <span class="number">0</span> <span class="number">1574236201000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574236206000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> master,fail - <span class="number">1574236049092</span> <span class="number">1574236047289</span> <span class="number">1</span> disconnected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> myself,master - <span class="number">0</span> <span class="number">1574236204000</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br></pre></td></tr></table></figure><p>通过 CLUSTER NODES 信息可以看到，Cluster-Master-01-6391 主节点处于下线状态（fail），其 Cluster-Master-01-6391 节点的从节点 Cluster-Slave-01-6394 变为主节点；说明主节点挂掉后，6394 Slave 节点自动升级成为了 Master 节点。</p><p>Step3、启动 6391 Redis 服务，然后查看节点角色，此时 6391 变成了 Slave，6394 为 Master 节点</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/redis-<span class="number">6391</span>/redis.conf</span><br><span class="line"></span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">43</span>c325955c74f0ed79de6850dca8a509195acb<span class="number">13 127.0.0</span>.<span class="number">1</span>:<span class="number">6392@16392</span> slave <span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">0</span> <span class="number">1574238264397</span> <span class="number">4</span> connected</span><br><span class="line">c54ebef126b30b5bd9cb157ccc0b6ddb<span class="number">952a1f50</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,slave cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">0</span> <span class="number">1574238261000</span> <span class="number">1</span> connected</span><br><span class="line"><span class="number">3</span>a32043079bf6af3723230ee3e6412e84dd<span class="number">66180 127.0</span>.<span class="number">0.1:6396</span>@<span class="number">16396</span> slave c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">0</span> <span class="number">1574238265400</span> <span class="number">6</span> connected</span><br><span class="line">c8daea9291a5cfdf0b3e032bc3a80d7e3cbc75cc <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">2</span> connected <span class="number">5461-10922</span></span><br><span class="line"><span class="number">718</span>f66ab8b3574597a97b90f8257773d<span class="number">0483c556</span> <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574238263000</span> <span class="number">3</span> connected <span class="number">10923-16383</span></span><br><span class="line">cdfd726c3c35586770412cade1fe5c56d4285b0e <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> master - <span class="number">0</span> <span class="number">1574238264000</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">5460</span></span><br></pre></td></tr></table></figure><p>（2）模拟场景：为 Redis Cluster 添加一个新主（master）节点 </p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器  Cluster-Master-04-6397</p><p>Step2、将 Cluster-Master-04-6397 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6397</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span>  -a foobared</span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120164716.png" alt="20191120164716"></p><p>Step3、为节点  Cluster-Master-04-6397 分配 slots（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos redis-cluster]# /usr/<span class="keyword">local</span>/redis/bin/redis-cli <span class="comment">--cluster reshard 127.0.0.1:6391 -a foobared</span></span><br></pre></td></tr></table></figure><p><img src="/media/15729465186457/20191120173744.png" alt="20191120173744"></p><p>（3）模拟场景：为 Redis Cluster 某个 Master 节点添加 一个新从（slave）节点 </p><p>Step1、按照上面的步骤新增一 Redis Cluster 服务器  Cluster-Slave-04-6398</p><p>Step2、将 Cluster-Slave-04-6398 节点加入 Redis Cluster 中（127.0.0.1:6391 为集群中任意可用的节点）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这种方法随机为 <span class="number">6398</span> 指定一个 master</span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> --cluster-slave -a foobared</span><br><span class="line"></span><br><span class="line">// 这种方式将为 <span class="number">6398</span> 指定某个 master-id</span><br><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-<span class="keyword">cli</span> --cluster <span class="keyword">add</span>-node <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6398</span>  <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6391</span> --cluster-slave --cluster-master-id 5cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c -a foobared</span><br></pre></td></tr></table></figure><p>Step3、查看集群状态</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_24_98_centos ~]# /usr/local/redis/bin/redis-cli -h <span class="number">127.0.0.1</span> -p <span class="number">6391</span> -a  foobared</span><br><span class="line"></span><br><span class="line"><span class="number">127.0.0.1</span>:<span class="number">6391</span>&gt; CLUSTER NODES</span><br><span class="line"><span class="number">5</span>cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">127.0.0.1</span>:<span class="number">6397@16397</span> master - <span class="number">0</span> <span class="number">1574243297701</span> <span class="number">7</span> connected <span class="number">0</span>-<span class="number">1364 5461</span>-<span class="number">6826 10923</span>-<span class="number">12287</span></span><br><span class="line"><span class="number">207628</span>f6fb8b3bb9a22db757507350fb<span class="number">880d4990</span> <span class="number">127.0.0.1</span>:<span class="number">6396@16396</span> slave <span class="number">94</span>af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">0</span> <span class="number">1574243294000</span> <span class="number">6</span> connected</span><br><span class="line"><span class="number">94</span>af5d349465be57400b6a4a1d770d56ad3d94ce <span class="number">127.0.0.1</span>:<span class="number">6393@16393</span> master - <span class="number">0</span> <span class="number">1574243296700</span> <span class="number">2</span> connected <span class="number">6827-10922</span></span><br><span class="line"><span class="number">2</span>e0134b0a87a73903d4774b6b37dd<span class="number">43e78e93733</span> <span class="number">127.0.0.1</span>:<span class="number">6391@16391</span> myself,master - <span class="number">0</span> <span class="number">1574243292000</span> <span class="number">1</span> connected <span class="number">1365-5460</span></span><br><span class="line"><span class="number">21</span>a288afc7b6addebcd943ca606dd34f6b9c99db <span class="number">127.0.0.1</span>:<span class="number">6398@16398</span> slave <span class="number">5</span>cf471cf39f0104f69d06c80d0dfdcc8aaa96b7c <span class="number">0</span> <span class="number">1574243295697</span> <span class="number">7</span> connected</span><br><span class="line"><span class="number">63</span>bc9da88066b475bd878a56a11dd<span class="number">18023b211b6</span> <span class="number">127.0.0.1</span>:<span class="number">6394@16394</span> slave <span class="number">2</span>e0134b0a87a73903d4774b6b37dd<span class="number">43e78e93733</span> <span class="number">0</span> <span class="number">1574243295000</span> <span class="number">5</span> connected</span><br><span class="line">c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">127.0.0.1</span>:<span class="number">6395@16395</span> master - <span class="number">0</span> <span class="number">1574243296000</span> <span class="number">3</span> connected <span class="number">12288-16383</span></span><br><span class="line">f6a7c788d9e5d40bc62a3723ba02c25607cc<span class="number">2825 127.0</span>.<span class="number">0.1:6392</span>@<span class="number">16392</span> slave c3d20b7f2df806ec87f3d45a7e334b5a2d3abe5b <span class="number">0</span> <span class="number">1574243293694</span> <span class="number">4</span> connected</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.cnblogs.com/xybaby/p/10124083.html" target="_blank" rel="noopener">一文搞懂 Raft 算法</a><br>[2]. <a href="https://www.cnblogs.com/chenmh/p/5578376.html" target="_blank" rel="noopener">Redis 哨兵模式实现主从故障互切换</a><br>[3]. <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a><br>[4]. <a href="https://www.bangbangde.com/post/gossip.html" target="_blank" rel="noopener">redis cluster 的Gossip协议介绍</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 领头 Sentinel：Sentinel 系统选举领头 Sentinel 的方式是对 Raft 算法的领头选举方法的实现，Raft 算法是一个共识算法，是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。</small><br><small>[2]. Gossip 协议：Gossip protocol 也叫 Epidemic Protocol（流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法” 等。Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个“最终一致性协议”。</small></p><hr><h2 id="Redis-深度探险系列"><a href="#Redis-深度探险系列" class="headerlink" title="Redis 深度探险系列"></a>Redis 深度探险系列</h2><ul><li><a href="8fb486e9.html">Redis 深度探险（一）：那些绕不过去的 Redis 知识点</a></li><li><a href="e993c76c.html">Redis 深度探险（二）：Redis 深入之道</a></li><li><a href="14348371.html">Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</a></li><li><a href="d63e1e23.html">Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开始本章的讲解之前，我们首先从宏观角度回顾一下 Redis 实现高可用相关的技术。它们包括：持久化、复制、哨兵和集群，在本系列的前篇文章介绍了持久化以及复制的原理以及实现。本文将对剩下的两种高可用技术哨兵、集群进行讲解，讲一讲它们是如何进一步提高系统的高可用性？&lt;/p&gt;
&lt;p&gt;Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制来解决这个问题。&lt;/p&gt;
&lt;p&gt;在 Redis 3.0 之前，使用哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://blog.maoning.vip/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://blog.maoning.vip/tags/Redis/"/>
    
      <category term="高可用" scheme="https://blog.maoning.vip/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
      <category term="集群" scheme="https://blog.maoning.vip/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="哨兵" scheme="https://blog.maoning.vip/tags/%E5%93%A8%E5%85%B5/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构（二）：大白话布隆过滤器 Bloom Filter</title>
    <link href="https://blog.maoning.vip/archives/6e0aae0d.html"/>
    <id>https://blog.maoning.vip/archives/6e0aae0d.html</id>
    <published>2019-10-11T10:12:18.000Z</published>
    <updated>2019-10-11T10:31:56.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“一个网站有 20 亿 url 存在一个黑名单中，这个黑名单要怎么存？若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？并且需在给定内存空间（比如：500M）内快速判断出。” 这是一道经常在面试中出现的算法题。</p><p>很多人脑海中首先想到的可能是 HashSet，因为 HashSet 的底层是采用 HashMap 实现的，理论上时间复杂度为：O(1)。达到了快速的目的，但是空间复杂度呢？URL 字符串通过 Hash 得到一个 Integer 的值，Integer 占 4 个字节，那 20 亿个 URL 理论上需要：4 字节 (byte) * 20 亿  =  80 亿 (byte)  ≈ 7.45G   的内存空间，不满足空间复杂度的要求。</p><p>还有一种方法就是位图法<sup>[1]</sup>，每个 URL 取整数哈希值，置于位图相应的位置上，看上去是可行的。但位图适合对海量的、取值分布很均匀的集合去重。位图法的所占空间随集合内最大元素的增大而增大，即空间复杂度随集合内最大元素增大而线性增大。要设计冲突率很低的哈希函数，势必要增加哈希值的取值范围，4G 的位图最大值是 320 亿左右，为 50 亿条 URL 设计冲突率很低、最大值为 320 亿的哈希函数比较困难。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。因此，出于性能和内存占用的考虑，在这里使用布隆过滤器才是最好的解决方案：布隆过滤器是对位图的一种改进。</p><p>这里就引出本文要介绍的 “布隆过滤器”。</p><a id="more"></a><h2 id="Bloom-Filter-概述"><a href="#Bloom-Filter-概述" class="headerlink" title="Bloom Filter 概述"></a>Bloom Filter 概述</h2><p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><h2 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h2><p>布隆过滤器的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>Bloom Filter 跟单哈希函数 Bit-Map 不同之处在于：Bloom Filter 使用了 k 个哈希函数，每个字符串跟 k 个 bit 对应，从而降低了冲突的概率。</p><p><img src="/media/15697553373443/740591-20180623183045586-692673875.jpg" alt="740591-20180623183045586-692673875"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主要是解决大规模数据下不需要精确过滤的场景。</p><ul><li>检查垃圾邮件地址：如果用哈希表，每存储一亿个 email 地址，就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。而 Bloom Filter 只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。布隆过滤器决不会漏掉任何一个在黑名单中的可疑地址。至于误判问题，常见的补救办法是在建立一个小的白名单，存储那些可能被误判的清白邮件地址。</li><li>解决缓存穿透：缓存穿透，是指查询一个数据库中不一定存在的数据。正常情况下，查询先进行缓存查询，如果 key 不存在或者 key 已经过期，再对数据库进行查询，并将查询到的对象放进缓存。如果每次都查询一个数据库中不存在的 key，由于缓存中没有数据，每次都会去查询数据库，很可能会对数据库造成影响。缓存穿透的一种解决办法是为不存在的 key 缓存一个空值，直接在缓存层返回。这样做的弊端就是缓存太多空值占用了太多额外的空间，这点可以通过给缓存层空值设立一个较短的过期时间来解决。另一种解决办法就是使用布隆过滤器，查询一个 key 时，先使用布隆过滤器进行过滤，如果判断请求查询 key 值存在，则继续查询数据库；如果判断请求查询不存在，直接丢弃。</li><li>Key-Value 缓存系统的 Key 校验：在很多 Key-Value 系统中也使用了布隆过滤器来加快查询过程，如 Hbase，Accumulo，Leveldb，一般而言，Value 保存在磁盘中，访问磁盘需要花费大量时间，然而使用布隆过滤器可以快速判断某个 Key 对应的 Value 是否存在，因此可以避免很多不必要的磁盘 IO 操作，只是引入布隆过滤器会带来一定的内存消耗。</li><li>Google 的 BigTable：Google 的 BigTable 也使用了布隆过滤器，以减少不存在的行或列在磁盘上的 I/O。</li><li>新闻客户端推荐系统：推荐系统给用户推荐新闻，避免重复推送。</li><li>爬虫 URL 地址去重：爬虫时判断某个 URL 是否已经被爬取过。</li><li>单词拼写检查</li><li>黑名单过滤</li><li>…</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="HashSet-实现"><a href="#HashSet-实现" class="headerlink" title="HashSet 实现"></a>HashSet 实现</h3><p>利用 HashSet 实现黑名单过滤，写入和判断元素是否存在都有对应的 API，所以实现起来也比较简单。</p><p>通过单元测试演示 HashSet 实现黑名单过滤功能；同时为了前后的对比将堆内存写死（-Xms64m -Xmx64m），为了方便调试加入了 GC 日志的打印（-XX:+PrintHeapAtGC），以及内存溢出后 Dump 内存（-XX:+HeapDumpOnOutOfMemoryError）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-Xms64m</span> <span class="selector-tag">-Xmx64m</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+PrintHeapAtGC</span> <span class="selector-tag">-XX</span><span class="selector-pseudo">:+HeapDumpOnOutOfMemoryError</span></span><br></pre></td></tr></table></figure><p>1、写入 100 条数据时：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> void testHashSet() &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="keyword">Integer</span>&gt; hashSet = new HashSet&lt;&gt;(<span class="number">10000000</span>);</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        hashSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    long <span class="keyword">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, <span class="keyword">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、写入 1000 W 条数据时：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> void testHashSet() &#123;</span><br><span class="line">    long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    Set&lt;<span class="keyword">Integer</span>&gt; hashSet = new HashSet&lt;&gt;(<span class="number">10000000</span>);</span><br><span class="line">    for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        hashSet.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">Assert</span>.assertTrue(hashSet.<span class="keyword">contains</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    long <span class="keyword">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, <span class="keyword">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后马上就内存溢出，可见在内存有限的情况下我们不能使用这种方式。</p><p><img src="/media/15697553373443/20191008192956.png" alt="20191008192956"></p><h3 id="Guava-中的布隆过滤器"><a href="#Guava-中的布隆过滤器" class="headerlink" title="Guava 中的布隆过滤器"></a>Guava 中的布隆过滤器</h3><p>BloomFilter 实现的一个重点就是怎么利用 hash 函数把数据映射到 bit 数组中。Guava 的实现是对元素通过 MurmurHash3 计算 hash 值，将得到的 hash 值取高 8 个字节以及低 8 个字节进行计算，以得当前元素在 bit 数组中对应的多个位置。</p><p>Guava 会通过你预计的数量以及误报率帮你计算出你应当会使用的数组大小 numBits 以及需要计算几次 Hash 函数 numHashFunctions 。</p><p>1、组件依赖：通过 Maven 引入 Guava 开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现布隆过滤器</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGuava</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期数据量</span></span><br><span class="line">    <span class="keyword">long</span> expectedInsertions = <span class="number">10000000</span>;</span><br><span class="line">    <span class="comment">// 预期误判率</span></span><br><span class="line">    <span class="keyword">double</span> fpp = <span class="number">0.001</span>;</span><br><span class="line">    <span class="comment">// 创建存储 Integer 数据的布隆过滤器</span></span><br><span class="line">    BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), expectedInsertions, fpp);</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断过滤器中是否存在元素</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"预期数据量：%s，判断数量：%s，预期误判率：%s，存在比率：%s \n"</span>, <span class="number">10000000</span>, count, fpp, count * <span class="number">1.0</span> / expectedInsertions);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断误判比例</span></span><br><span class="line">    <span class="keyword">int</span> fppCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000000</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">            fppCount++;</span><br><span class="line">            System.<span class="keyword">out</span>.println(i + <span class="string">"误判了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"预期数据量：%s，误判数量：%s，预期误判率：%s，实际误判率：%s \n"</span>, <span class="number">10000000</span>, fppCount, fpp, fppCount * <span class="number">1.0</span> / expectedInsertions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.<span class="keyword">out</span>.printf(<span class="string">"执行时间：%s \n"</span>, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：我们的定义了一个预期数据量为 1000 W、预期误判率为 0.001 的布隆过滤器，接下来向布隆过滤器中插入了 0-10000000 数据，然后用 0- 10000000 以及 10000000-20000000 数据来测试误判率。</p><p>（1）经过测试：“预期数据量：10000000，判断数量：10000000，预期误判率：0.001，存在比率：1.0 ”，可发现当过滤器判断 0-10000000 的数据时，存在比率为 1.0，即布隆过滤器对于已经见过的元素肯定不会误判，它只会误判那些没见过的元素。</p><p>（2）经过测试：“预期数据量：10000000，误判数量：10132，预期误判率：0.001，实际误判率：0.0010132” ，符合预期误判率：0.001。</p><h3 id="Redis-中的布隆过滤器"><a href="#Redis-中的布隆过滤器" class="headerlink" title="Redis 中的布隆过滤器"></a>Redis 中的布隆过滤器</h3><h4 id="安装-Rebloom-插件"><a href="#安装-Rebloom-插件" class="headerlink" title="安装 Rebloom 插件"></a>安装 Rebloom 插件</h4><p>1、安装 Rebloom 插件：Redis 安装在这里就不介绍了，这里讲一下 Rebloom 插件安装。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下载 Rebloom 源文件</span></span><br><span class="line"><span class="symbol">$</span> git clone git:<span class="comment">//github.com/RedisLabsModules/rebloom</span></span><br><span class="line"><span class="comment">// 进入 Rebloom 目录</span></span><br><span class="line"><span class="symbol">$</span> cd rebloom</span><br><span class="line"><span class="comment">// 编译插件</span></span><br><span class="line"><span class="symbol">$</span> make</span><br></pre></td></tr></table></figure><p>2、加载 Rebloom 插件方法</p><p>（1）、在启动的 client 中使用 MODULE LOAD 命令去加载（重启 Redis 后失效）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE LOAD <span class="regexp">/usr/</span>lib64<span class="regexp">/redis/m</span>odules<span class="regexp">/rebloom/</span>redisbloom.so</span><br></pre></td></tr></table></figure><p>（2）、命令行加载 Rebloom 插件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/redis-server /</span>etc<span class="regexp">/redis.conf --loadmodule /u</span>sr<span class="regexp">/lib64/</span>redis<span class="regexp">/modules/</span>rebloom<span class="regexp">/redisbloom.so</span></span><br></pre></td></tr></table></figure><p>（3）、在 redis.conf 文件中加入配置信息</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadmodule <span class="regexp">/usr/</span>lib64<span class="regexp">/redis/m</span>odules<span class="regexp">/rebloom/</span>redisbloom.so</span><br></pre></td></tr></table></figure><p>3、通过命令测试 Redis Bloom Filter</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的布隆过滤器，并设置一个期望的错误率和初始大小。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.RESERVE</span> userid <span class="number">0.01</span> <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 往过滤器中添加元素。如果 key 不存在，过滤器会自动创建。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.ADD</span> userid <span class="string">'101310299'</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.MADD</span> userid <span class="string">'101310299'</span> <span class="string">'101310366'</span> <span class="string">'101310211'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断过滤器中是否存在该元素，不存在返回 0，存在返回 1。</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.EXISTS</span> userid <span class="string">'101310299'</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; BF<span class="selector-class">.EXISTS</span> userid <span class="string">'101310299'</span> <span class="string">'10saa'</span> <span class="string">'101310211'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取该 Bloom Filter 使用的内存大小</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; Memory Usage userid</span><br></pre></td></tr></table></figure><h4 id="通过-Java-代码实现布隆过滤器"><a href="#通过-Java-代码实现布隆过滤器" class="headerlink" title="通过 Java 代码实现布隆过滤器"></a>通过 Java 代码实现布隆过滤器</h4><p>1、组件依赖：通过 Maven 引入 Redisson <sup>[2]</sup>开源组件，在 pom.xml 文件加入下面的代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、代码实现：通过 Java 代码实现布隆过滤器</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testRedis() &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Redis 连接信息</span></span><br><span class="line">    Config <span class="built_in">config</span> = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="built_in">config</span>.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>)</span><br><span class="line">            .setPassword(<span class="string">"password"</span>)</span><br><span class="line">            .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Redisson 客户端</span></span><br><span class="line">    RedissonClient redissonClient = Redisson.create(<span class="built_in">config</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redisson 利用 Redis 实现了 Java 分布式布隆过滤器（Bloom Filter）</span></span><br><span class="line">    RBloomFilter&lt;Integer&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">"userid"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预期数据量</span></span><br><span class="line">    <span class="keyword">long</span> expectedInsertions = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">// 预期误判率</span></span><br><span class="line">    <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line">    <span class="comment">// 初始化布隆过滤器，预计统计元素数量为 10000，期望误差率为 0.001</span></span><br><span class="line">    bloomFilter.tryInit(expectedInsertions, fpp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expectedInsertions; i++) &#123;</span><br><span class="line">        bloomFilter.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断误判比例</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">if</span> (bloomFilter.contains(i)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            System.out.<span class="built_in">println</span>(i + <span class="string">"误判了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">"预期数据量：%s，误判数量：%s，预期误判率：%s，实际误判率：%s \n"</span>, expectedInsertions, count, fpp, count * <span class="number">1.0</span> / <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.out.printf(<span class="string">"执行时间：%s \n"</span>, <span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：Redisson 利用 Redis 实现了 Java 分布式布隆过滤器（Bloom Filter），通过 RedissonClient 初始化布隆过滤器，预计统计元素数量为 10000，期望误差率为 0.001。“预期数据量：10000，误判数量：51，预期误判率：0.001，实际误判率：0.00255 ”。我们看到了误判率大约 0.255%，比预计的 0.1% 高，不过布隆的概率是有误差的，只要不比预计误判率高太多，都是正常现象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在使用 Bloom Filter 时，绕不过的两点是预估数据量 n 以及期望的误判率 fpp，在实现 Bloom Filter 时，绕不过的两点就是 hash 函数的选取以及 bit 数组的大小。</p><p>期望的误判率越低，需要的空间越大。预估数据量，当实际数量超出这个数值时，误判率会上升。因此用户在使用之前一定要尽可能地精确估计好元素数量，还需要加上一定的冗余空间以避免实际元素可能会意外高出估计值很多导致误判率升高。</p><p>布隆过滤器的空间占用有一个简单的计算公式，但是推导比较繁琐，这里就省去推导过程了，感兴趣的读者可以点击「延伸阅读」深入理解公式的推导过程。虽然存在布隆过滤器的空间占用的计算公司，但是有很多现成的网站已经支持计算空间占用的功能了，我们只要把参数输进去，就可以直接看到结果，比如 <a href="https://krisives.github.io/bloom-calculator/" target="_blank" rel="noopener">布隆计算器</a>。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html" target="_blank" rel="noopener">布隆过滤器 (Bloom Filter) 详解</a>：详解布隆过滤器的相关算法和参数设计。</li><li><a href="https://zh.wikipedia.org/zh-hans/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">Murmur 哈希</a>：Murmur 哈希，于 2008 年被发明。这个算法 hbase、redis、kafka 都在使用。</li><li><a href="https://zh.wikipedia.org/zh-hans/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">Counting Bloom Filter</a>：要实现删除元素，可以采用 Counting Bloom Filter。它将标准布隆过滤器位图的每一位扩展为一个小的计数器 (Counter)，插入元素时将对应的 k 个 Counter 的值分别加 1，删除元素时则分别减 1。</li><li><a href="https://juejin.im/post/5cfb9c74e51d455d6d5357db" target="_blank" rel="noopener">布谷鸟过滤器</a>：为了解决布隆过滤器不能删除元素的问题，布谷鸟过滤器横空出世。相比布谷鸟过滤器而言布隆过滤器有以下不足：查询性能弱、空间利用效率低、不支持反向操作（删除）以及不支持计数。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://crossoverjie.top/2018/11/26/guava/guava-bloom-filter/" target="_blank" rel="noopener">如何判断一个元素在亿级数据中是否存在？</a><br>[2]. <a href="https://www.cnblogs.com/z941030/p/9218356.html" target="_blank" rel="noopener">大数据量下的集合过滤—Bloom Filter</a><br>[3]. <a href="https://my.oschina.net/LucasZhu/blog/1813110" target="_blank" rel="noopener">布隆过滤器 (Bloom Filter) 的原理、实现和探究</a></p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 位图法：位图法就是 BitMap 的缩写，所谓 BitMap，就是用每一位来存放某种状态，适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在的。</small><br><small>[2]. Redisson：<br>Redisson 在基于 NIO 的 Netty 框架上，充分的利用了 Redis 键值数据库提供的一系列优势，在 Java 实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</small></p><hr><h2 id="大话数据结构系列"><a href="#大话数据结构系列" class="headerlink" title="大话数据结构系列"></a>大话数据结构系列</h2><ul><li><a href="9c51d4e.html">大话数据结构（一）：那些年面试常见的 Java 排序算法</a></li><li><a href="6e0aae0d.html">大话数据结构（二）：大白话布隆过滤器 Bloom Filter</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;“一个网站有 20 亿 url 存在一个黑名单中，这个黑名单要怎么存？若此时随便输入一个 url，你如何快速判断该 url 是否在这个黑名单中？并且需在给定内存空间（比如：500M）内快速判断出。” 这是一道经常在面试中出现的算法题。&lt;/p&gt;
&lt;p&gt;很多人脑海中首先想到的可能是 HashSet，因为 HashSet 的底层是采用 HashMap 实现的，理论上时间复杂度为：O(1)。达到了快速的目的，但是空间复杂度呢？URL 字符串通过 Hash 得到一个 Integer 的值，Integer 占 4 个字节，那 20 亿个 URL 理论上需要：4 字节 (byte) * 20 亿  =  80 亿 (byte)  ≈ 7.45G   的内存空间，不满足空间复杂度的要求。&lt;/p&gt;
&lt;p&gt;还有一种方法就是位图法&lt;sup&gt;[1]&lt;/sup&gt;，每个 URL 取整数哈希值，置于位图相应的位置上，看上去是可行的。但位图适合对海量的、取值分布很均匀的集合去重。位图法的所占空间随集合内最大元素的增大而增大，即空间复杂度随集合内最大元素增大而线性增大。要设计冲突率很低的哈希函数，势必要增加哈希值的取值范围，4G 的位图最大值是 320 亿左右，为 50 亿条 URL 设计冲突率很低、最大值为 320 亿的哈希函数比较困难。这就会带来一个问题，如果查找的元素数量少但其中某个元素的值很大，比如数字范围是 1 到 1000 亿，那消耗的空间不容乐观。因此，出于性能和内存占用的考虑，在这里使用布隆过滤器才是最好的解决方案：布隆过滤器是对位图的一种改进。&lt;/p&gt;
&lt;p&gt;这里就引出本文要介绍的 “布隆过滤器”。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="https://blog.maoning.vip/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://blog.maoning.vip/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="排序算法" scheme="https://blog.maoning.vip/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出集合框架（二）：为并发而生的 ConcurrentHashMap</title>
    <link href="https://blog.maoning.vip/archives/91027543.html"/>
    <id>https://blog.maoning.vip/archives/91027543.html</id>
    <published>2019-09-27T08:26:53.000Z</published>
    <updated>2019-11-20T11:16:39.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ConcurrentHashMap 从 JDK 1.5 开始随 java.util.concurrent 包一起引入 JDK 中，主要为了解决 HashMap 线程不安全和 Hashtable 效率不高的问题。</p><p>HashMap 是我们日常开发中最常见的一种容器，根据键值对键的哈希值来确定值对键在集合中的存储位置，因此具有良好的存取和查找功能。但众所周知，它在高并发的情境下是线程不安全的。尤其是在 JDK 1.8 之前，rehash 的过程中采用头插法转移结点，高并发下，多个线程同时操作一条链表将直接导致闭链，易出现逆序且环形链表死循环问题，导致死循环并占满 CPU。JDK 1.8 以来，对 HashMap 的内部进行了很大的改进，采用数组 + 链表 + 红黑树的形式来进行数据的存储。rehash 的过程也进行了改动，基于复制的算法思想，不直接操作原链，而是定义了两条链表分别完成对原链的结点分离操作，在多线程的环境下，采用了尾插法，扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致，所有即使是多线程的情况下也是安全的。JDK 1.8 中的 HashMap 虽然不会导致死循环，但是因为 HashMap 多线程下内存不共享的问题，两个线程同时指向一个 hash 桶数组时，会导致数据覆盖的问题，所以 HashMap 是依旧是线程不安全的。</p><p>HashTable 是线程安全的容器，它在所有涉及到多线程的操作都加上了 synchronized 关键字来锁住整个 table，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的，因此 Hashtable 已经是 Java 中的遗留容器，已经不推荐使用。</p><p>因此在多线程条件下，需要满足线程安全，我们可使用 Collections.synchronizedMap 方法构造出一个同步的 Map，使 HashMap 具有线程安全的能力；或者直接使用线程安全的 ConcurrentHashMap。本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 HashMap 很多。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>线程不安全的 HashMap</li></ul><p>由于 HashMap 是非线程安全的容器，遇到多线程操作同一容器的场景，可能会导致数据不一致： JDK 1.7 中 HashMap 采用了数组 + 链表的数据结构，有线程安全问题（统计不准确，丢失数据，环形链表死循环导致 Cpu 100%），JDK 1.8 中 HashMap 采用了数组 + 链表 + 红黑树的结构，有线程安全问题（统计不准确，丢失数据）。</p><ul><li>效率低下的 HashTable 容器</li></ul><p>HashTable 容器使用 synchronized 关键字来保证线程安全，但在线程竞争激烈的情况下 HashTable 的效率非常低下。因为当一个线程访问 HashTable 的同步方法时，其他线程访问 HashTable 的同步方法时，可能会进入阻塞或轮询状态。如线程 1 使用 put 进行添加元素，线程 2 不但不能使用 put 方法添加元素，并且也不能使用 get 方法来获取元素，所以竞争越激烈效率越低。</p><h2 id="JDK-1-7-基于分段锁的-ConcurrentHashMap"><a href="#JDK-1-7-基于分段锁的-ConcurrentHashMap" class="headerlink" title="JDK 1.7 基于分段锁的 ConcurrentHashMap"></a>JDK 1.7 基于分段锁的 ConcurrentHashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashTable 容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问 HashTable 的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是 ConcurrentHashMap 所使用的锁分段技术。JDK1.7 中的 ConcurrentHashMap 的底层数据结构是数组 + 链表。与 HashMap 不同的是，ConcurrentHashMap 最外层不是一个大的数组，而是一个 Segment 的数组。每个 Segment 包含一个与 HashMap 数据结构差不多的链表数组。</p><p>JDK 1.7 中 ConcurrentHashMap 采用 Segment 分段锁的数据结构，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如 size() 和 containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这种做法，就称之为“分离锁”（lock striping）<sup>[1]</sup> 。</p><p>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， 每个 Segment 守护者一个 HashEntry 数组里的元素, 当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</p><p><img src="/media/15640353314189/926638-20170809132445011-2033999443.png" alt="926638-20170809132445011-2033999443"></p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap&lt;K</span>, <span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">AbstractMap&lt;K</span>, <span class="title">V&gt;</span></span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">ConcurrentMap&lt;K</span>, <span class="title">V&gt;</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整个 hashmap 分成几个小的 map，每个 segment 都是一个锁；与 hashtable 相比，这么设计的目的是对于 put, remove 等操作，可以减少并发冲突，对不属于同一个片段的节点可以并发操作，大大提高了性能</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Segment</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] segments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本质上 Segment 类就是一个小的 hashmap，里面 table 数组存储了各个节点的数据，继承了 ReentrantLock, 可以作为互拆锁使用</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// count 用来统计该段数据的个数，它是 volatile，它用来协调修改和读取操作，以保证读取操作能够读取到几乎最新的修改。协调方式是这样的，每次修改操作做了结构上的改变，如增加 / 删除节点(修改节点的值不算结构上的改变)，都要写 count 值，每次读取操作开始都要读取 count 的值。这利用了 Java 5 中对 volatile 语义的增强，对同一个 volatile 变量的写和读存在 happens-before 关系。</span></span><br><span class="line">transient volatileint count;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// modCount 统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变</span></span><br><span class="line">        transient int modCount;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// threashold 用来表示需要进行 rehash 的界限值</span></span><br><span class="line">        transient int threshold;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// table 数组存储段中节点，每个数组元素是个 hash 链，用 HashEntry 表示。table 也是 volatile，这使得能够读取到最新的 table 值而不需要同步</span></span><br><span class="line">        transient volatile <span class="type">HashEntry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt;[] table;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// loadFactor 表示负载因子。</span></span><br><span class="line">        <span class="keyword">final</span> float loadFactor;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本节点，存储 Key，value 值，可以看到除了 value 不是 final 的，其它值都是 final 的，这意味着不能从 hash 链的中间或尾部添加或删除节点，因为这需要修改 next 引用值，所有的节点的修改只能从头部开始。对于 put 操作，可以一律添加到 Hash 链的头部。但是对于 remove 操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。为了确保读操作能够看到最新的值，将 value 设置成 volatile，这避免了加锁。</span></span><br><span class="line">    static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> int hash;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">K</span> key;</span><br><span class="line">        volatile <span class="type">V</span> value;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">HashEntry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>它把区间按照并发级别（concurrentLevel），分成了若干个 segment。默认情况下内部按并发级别为 16 来创建。对于每个 segment 的容量，默认情况也是 16。concurrentLevel，segment 可以通过构造函数设定的。通过按位与的哈希算法来定位 segments 数组的索引，必须保证 segments 数组的长度是 2 的 N 次方（power-of-two size），所以必须计算出一个是大于或等于 concurrencyLevel 的最小的 2 的 N 次方值来作为 segments 数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验参数</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 并发级别数大于最大Segment数量</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    Segment&lt;K, V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K, V&gt;(loadFactor, (<span class="keyword">int</span>) (cap * loadFactor),</span><br><span class="line">                    (HashEntry&lt;K, V&gt;[]) <span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K, V&gt;[] ss = (Segment&lt;K, V&gt;[]) <span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/15640353314189/f7e40dd35ad859e5cafbfd091341e14e061.jpg" alt="f7e40dd35ad859e5cafbfd091341e14e061"></p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>对于读操作，通过 Key 哈希值的高 N 位对 Segment 个数取模从而得到该 Key 应该属于哪个 Segment，接着如同操作 HashMap 一样操作这个 Segment。Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该键值对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该 Segment 的安全性。为了保证不同的值均匀分布到不同的 Segment，需要通过如下方法计算哈希值。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">private</span> int hash(Object k) &#123;</span><br><span class="line">  <span class="attribute">int</span> h = hashSeed;</span><br><span class="line">  <span class="attribute">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k instanceof String)) &#123;</span><br><span class="line">    <span class="attribute">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> k.hashCode();</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;  <span class="number">15</span>)<span class="regexp"> ^</span> 0xffffcd7d;</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">  <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">  <span class="attribute">h</span> += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">  <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>Segment 继承自 ReentrantLock，所以我们可以很方便的对每一个 Segment 上锁。</p><p>对于读操作，获取 Key 所在的 Segment 时，需要保证可见性。具体实现上可以使用 volatile 关键字，也可使用锁。但使用锁开销太大，而使用 volatile 时每次写操作都会让所有 CPU 内缓存无效，也有一定开销。ConcurrentHashMap 使用如下方法保证可见性，取得最新的 Segment。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K, V&gt; <span class="title">segmentForHash</span>(<span class="params"><span class="keyword">int</span> h</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    <span class="keyword">return</span> (Segment&lt;K, V&gt;) UNSAFE.getObjectVolatile(segments, u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于写操作，并不要求同时获取所有 Segment 的锁，因为那样相当于锁住了整个 Map。它会先获取该 Key-Value 对所在的 Segment 的锁，获取成功后就可以像操作一个普通的 HashMap 一样操作该 Segment，并保证该 Segment 的安全性。<br>同时由于其它 Segment 的锁并未被获取，因此理论上可支持 concurrencyLevel（等于 Segment 的个数）个线程安全的并发读写。</p><p>获取锁时，并不直接使用 lock 来获取，因为该方法获取锁失败时会挂起（参考可重入锁）。事实上，它使用了自旋锁，如果 tryLock 获取锁失败，说明锁被其它线程占用，此时通过循环再次以 tryLock 的方式申请锁。如果在循环过程中该 Key 所对应的链表头被修改，则重置 retry 次数。如果 retry 次数超过一定值，则使用 lock 方法申请锁。</p><p>这里使用自旋锁是因为自旋锁的效率比较高，但是它消耗 CPU 资源比较多，因此在自旋次数超过阈值时切换为互斥锁。</p><h3 id="size-操作"><a href="#size-操作" class="headerlink" title="size 操作"></a>size 操作</h3><p>put、remove 和 get 操作只需要关心一个 Segment，而 size 操作需要遍历所有的 Segment 才能算出整个 Map 的大小。一个简单的方案是，先锁住所有 Sgment，计算完后再解锁。但这样做，在做 size 操作时，不仅无法对 Map 进行写操作，同时也无法进行读操作，不利于对 Map 的并行操作。</p><p>为更好支持并发操作，ConcurrentHashMap 会在不上锁的前提逐个 Segment 计算 3 次 size，如果某相邻两次计算获取的所有 Segment 的更新次数（每个 Segment 都与 HashMap 一样通过 modCount 跟踪自己的修改次数，Segment 每修改一次其 modCount 加一）相等，说明这两次计算过程中无更新操作，则这两次计算出的总 size 相等，可直接作为最终结果返回。如果这三次计算过程中 Map 有更新，则对所有 Segment 加锁重新计算 Size。该计算方法代码如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size() &#123;</span><br><span class="line">  <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">sum</span>;         <span class="comment">// sum of modCounts</span></span><br><span class="line">  <span class="keyword">long</span> last = <span class="number">0</span>L;   <span class="comment">// previous sum</span></span><br><span class="line">  <span class="keyword">int</span> retries = <span class="number">-1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">          ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">sum</span> = <span class="number">0</span>L;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      overflow = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">        Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">        <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">sum</span> += seg.modCount;</span><br><span class="line">          <span class="keyword">int</span> c = seg.<span class="keyword">count</span>;</span><br><span class="line">          <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">            overflow = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">sum</span> == last)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      last = <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">        segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-8-基于-CAS-的-ConcurrentHashMap"><a href="#Java-8-基于-CAS-的-ConcurrentHashMap" class="headerlink" title="Java 8 基于 CAS 的 ConcurrentHashMap"></a>Java 8 基于 CAS 的 ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>JDK 1.7 中 ConcurrentHashMap 为实现并行访问，引入了 Segment 这一结构，实现了分段锁，理论上最大并发度与 Segment 个数相等。JDK 1.8 中 ConcurrentHashMap 为进一步提高并发性，摒弃了分段锁的方案，而是直接使用一个大的数组。</p><p>JDK 1.8 中 ConcurrentHashMap 参考了 JDK 1.8  HashMap 的实现，采用了数组 + 链表 + 红黑树的实现方式进行数据存储，提高哈希碰撞下的寻址性能，在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）；进一步提高并发性，取消了基于 Segment 的分段锁思想，改用 CAS<sup>[2]</sup> + synchronized 控制并发操作，在某些方面提升了性能。对于读操作，通过 Key 的哈希值与数组长度取模确定该 Key 在数组中的索引。对于写操作，如果 Key 对应的数组元素为 null，则通过 CAS 操作将其设置为当前值。如果 Key 对应的数组元素不为 null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。</p><p><img src="/media/15640353314189/926638-20170809132741792-1171090777.png" alt="926638-20170809132741792-1171090777"></p><h4 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h4><p><strong><u>Node</u></strong> ：Node 是最核心的内部类，它包装了 key-value 键值对，所有插入 ConcurrentHashMap 的数据都包装在这里面。它与 HashMap 中的定义很相似，但是但是有一些差别它对 value 和 next 属性设置了 volatile 同步锁，它不允许调用 setValue 方法直接改变 Node 的 value 域，它增加了 find 方法辅助 map.get() 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">static <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="type">K,V</span>&gt; <span class="title">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="type">K,V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> int hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// 带有同步锁的 value[value 和 next 都会在扩容时发生变化，所以加上 volatile 来保持可见性和禁止重排序]</span></span><br><span class="line">    <span class="keyword">volatile</span> V <span class="keyword">val</span>;</span><br><span class="line">    <span class="comment">// 带有同步锁的 next 指针</span></span><br><span class="line">    <span class="keyword">volatile</span> ConcurrentHashMap.Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V <span class="keyword">val</span>, ConcurrentHashMap.Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">val</span> = <span class="keyword">val</span>;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K getKey()       &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V getValue()     &#123; <span class="keyword">return</span> <span class="keyword">val</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> int hashCode()   &#123; <span class="keyword">return</span> key.hashCode() ^ <span class="keyword">val</span>.hashCode(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String toString()&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + <span class="keyword">val</span>; &#125;</span><br><span class="line">    <span class="comment">// 不允许直接改变 value 的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V setValue(V value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> boolean equals(Object o) &#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o instanceof Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = <span class="keyword">val</span>) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Virtualized support for map.get(); overridden in subclasses.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ConcurrentHashMap.Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">        ConcurrentHashMap.Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="literal">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><u>TreeNode</u></strong>：树节点类，当链表长度过长的时候，会转换为 TreeNode。但是与 HashMap 不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成 TreeNode 放在 TreeBin 对象中，由 TreeBin 完成对红黑树的包装。而且 TreeNode 在 ConcurrentHashMap 集成自 Node 类，而并非 HashMap 中的集成自 LinkedHashMap.Entry&lt;K,V&gt; 类，也就是说 TreeNode 带有 next 指针，这样做的目的是方便基于 TreeBin 的访问。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes for use in TreeBins</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">ConcurrentHashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line"><span class="comment">// 存储当前节点的父节点</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">// 存储当前节点的左孩子</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; left;</span><br><span class="line">    <span class="comment">// 存储当前节点的右孩子</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; right;</span><br><span class="line">    <span class="comment">// 存储当前节点的前一个节点</span></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">// 存储当前节点的颜色（红、黑）</span></span><br><span class="line">    boolean red;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> <span class="keyword">val</span>, <span class="type">ConcurrentHashMap</span>.<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next,</span><br><span class="line">             <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, <span class="keyword">val</span>, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ConcurrentHashMap</span>.<span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; find(int h, <span class="type">Object</span> k) &#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the TreeNode (or null if not found) for the given key</span></span><br><span class="line"><span class="comment">     * starting at given root.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; findTreeNode(int h, <span class="type">Object</span> k, <span class="type">Class</span>&lt;?&gt; kc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            do  &#123;</span><br><span class="line">                int ph, dir; <span class="type">K</span> pk; <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; q;</span><br><span class="line">                <span class="type">ConcurrentHashMap</span>.<span class="type">TreeNode</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                        (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp;</span><br><span class="line">                        (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><p>concurrencyLevel，能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数，在 JDK 1.8  之前实际上就是 ConcurrentHashMap 中的分段锁个数，即 Segment[] 的数组长度。在 JDK 1.8 里，仅仅是为了兼容旧版本而保留，唯一的作用就是保证构造 map 时初始容量不小于 concurrencyLevel。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node 数组最大容量：2^30=1073741824</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认初始值，必须是 2 的幕数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 数组可能最大值，需要与 toArray（）相关方法关联</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 并发级别，遗留下来的，为兼容以前的版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75</span>f;</span><br><span class="line"><span class="comment">// 链表转红黑树阀值 &gt; 8 链表转换为红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 树转链表阀值，小于等于 6（tranfer 时，lc、hc=0 两个计数器分别 ++ 记录原 bin、新 binTreeNode 数量，&lt;=UNTREEIFY_THRESHOLD 则 untreeify(lo)）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 2^15-1，help resize 的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 32-16=16，sizeCtl 中记录 size 大小的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"><span class="comment">// forwarding nodes 的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 树根节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">// ReservationNode 的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 可用处理器数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = <span class="keyword">Runtime</span>.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// 存放 node 的数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"><span class="comment">/* 控制标识符，用来控制 table 的初始化和扩容的操作，不同的值有不同的含义</span></span><br><span class="line"><span class="comment"> * 当为负数时：-1 代表正在初始化，-N 代表有 N-1 个线程正在 进行扩容</span></span><br><span class="line"><span class="comment"> * 当为 0 时：代表当时的 table 还没有被初始化</span></span><br><span class="line"><span class="comment"> * 当为正数时：表示初始化或者下一次进行扩容的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h3 id="寻址方式-1"><a href="#寻址方式-1" class="headerlink" title="寻址方式"></a>寻址方式</h3><p>JDK 1.8 的 ConcurrentHashMap 同样是通过 Key 的哈希值与数组长度取模确定该 Key 在数组中的索引。同样为了避免不太好的 Key 的 hashCode 设计，它通过如下方法计算得到 Key 的最终哈希值。不同的是，JDK 1.8 的 ConcurrentHashMap 作者认为引入红黑树后，即使哈希冲突比较严重，寻址效率也足够高，所以作者并未在哈希值的计算上做过多设计，只是将 Key 的 hashCode 值与其高 16 位作异或并保证最高位为 0（从而保证最终结果为正整数）。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步方式-1"><a href="#同步方式-1" class="headerlink" title="同步方式"></a>同步方式</h3><p>对于写操作，如果 Key 对应的数组元素为 null，则通过 CAS 操作将其设置为当前值。如果 Key 对应的数组元素（也即链表表头或者树的根元素）不为 null，则对该元素使用 synchronized 关键字申请锁，然后进行操作。如果该 put 操作使得当前链表长度超过一定阈值，则将该链表转换为树，从而提高寻址效率。</p><p>对于读操作，由于数组被 volatile 关键字修饰，因此不用担心数组的可见性问题。同时每个元素是一个 Node 实例（Java 7 中每个元素是一个 HashEntry），它的 Key 值和 hash 值都由 final 修饰，不可变更，无须关心它们被修改后的可见性问题。而其 Value 及对下一个元素的引用由 volatile 修饰，可见性也有保障。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Key 对应的数组元素的可见性，由 Unsafe 的 getObjectVolatile 方法保证。它是对 tab[i] 进行原子性的读取，因为我们知道 putVal 等对 table 的桶操作是有加锁的，那么一般情况下我们对桶的读也是要加锁的，但是我们这边为什么不需要加锁呢？因为我们用了 Unsafe<sup>[3]</sup> 的 getObjectVolatile，因为 table 是 volatile 类型，所以对 tab[i] 的原子请求也是可见的。因为如果同步正确的情况下，根据 happens-before 原则，对 volatile 域的写入操作 happens-before 于每一个后续对同一域的读操作。所以不管其他线程对 table 链表或树的修改，都对 get 读取可见。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获得数组中位置i上的节点</span><br><span class="line">static final <span class="tag">&lt;K,V&gt;</span> <span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt; tabAt(<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;[] tab, int i) &#123;</span><br><span class="line">  return (<span class="keyword">Node</span><span class="title">&lt;K</span>,V&gt;)U.getObjectVolatile(tab, ((long)i <span class="tag">&lt;&lt; ASHIFT) + ABASE);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="size-操作-1"><a href="#size-操作-1" class="headerlink" title="size 操作"></a>size 操作</h3><p>put 方法和 remove 方法都会通过 addCount 方法维护 Map 的 size。size 方法通过 sumCount 获取由 addCount 方法维护的 Map 的 size。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">final <span class="keyword">long</span> <span class="title">sumCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="comment">// 变化的数量</span></span><br><span class="line">    CounterCell[] <span class="keyword">as</span> = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">as</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">as</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = <span class="keyword">as</span>[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析-ConcurrentHashMap"><a href="#源码分析-ConcurrentHashMap" class="headerlink" title="源码分析 ConcurrentHashMap"></a>源码分析 ConcurrentHashMap</h2><h3 id="initTable-方法"><a href="#initTable-方法" class="headerlink" title="initTable()方法"></a>initTable()方法</h3><p>该方法的核心思想就是，只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度。这样，保证了表同时只会被一个线程初始化。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="comment">// 如果表为空才进行初始化操作</span></span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl 小于零说明已经有线程正在进行初始化操作，当前线程应该放弃 CPU 的使用</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 否则说明还未有线程对表进行初始化，那么本线程就来做这个工作，CAS 方法把 sizectl 置为-1，表示本线程正在进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            <span class="comment">// 保险起见，再次判断下表是否为空</span></span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    <span class="comment">// sc 大于零说明容量已经初始化了，否则使用默认容量 16</span></span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">// 根据容量构建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="comment">// 将这个数组赋值给 table，table 是 volatile 的</span></span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="comment">// 计算阈值，等效于 n*0.75</span></span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="comment">// 设置阈值</span></span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-Object-key-方法"><a href="#get-Object-key-方法" class="headerlink" title="get(Object key)方法"></a>get(Object key)方法</h3><p>get 方法比较简单，给定一个 key 来确定 value 的时候，必须满足两个条件 key 相同 、hash 值相同，对于节点可能在链表或树上的情况，需要分别去查找。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V <span class="built_in">get</span>(Object <span class="built_in">key</span>) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="built_in">tab</span>; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    <span class="comment">// 计算 hash 值</span></span><br><span class="line">    int h = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    <span class="comment">// 根据 hash 值确定节点位置</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, (n - <span class="number">1</span>) &amp; h)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果搜索到的节点 key 与传入的 key 相同且不为 null, 直接返回这个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 eh&lt;0 说明这个节点在树上，调用树的 find 方法寻找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, <span class="built_in">key</span>)) != <span class="built_in">null</span> ? p.val : <span class="built_in">null</span>;</span><br><span class="line">        <span class="comment">// 否则遍历链表 找到对应的值并返回</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == <span class="built_in">key</span> || (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的 get 操作的流程很简单，可以分为三个步骤来描述：</p><ul><li>计算 hash 值，定位到该 table 索引位置，如果是首节点符合就返回</li><li>如果遇到扩容的时候，会调用标志正在扩容节点 ForwardingNode 的 find 方法，查找该节点，匹配就返回</li><li>以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回 null</li></ul><h3 id="put-K-key-V-value-方法"><a href="#put-K-key-V-value-方法" class="headerlink" title="put(K key, V value)方法"></a>put(K key, V value)方法</h3><p>假设 table 已经初始化完成，put 操作采用 CAS+synchronized 实现并发插入或更新操作，具体实现如下。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public V <span class="built_in">put</span>(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">putVal</span>(<span class="built_in">key</span>, value, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation for put and putIfAbsent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">final V <span class="built_in">putVal</span>(K <span class="built_in">key</span>, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    <span class="comment">// 不允许 key 或 value 为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="built_in">null</span> || value == <span class="built_in">null</span>) throw <span class="keyword">new</span> <span class="built_in">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算 hash 值，两次 hash，减少 hash 冲突，可以均匀分布</span></span><br><span class="line">    int hash = <span class="built_in">spread</span>(<span class="built_in">key</span>.<span class="built_in">hashCode</span>());</span><br><span class="line">    int binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环 何时插入成功 何时跳出；因为如果其他线程正在修改 tab，那么尝试就会失败，所以这边要加一个 for 循环，不断的尝试</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] <span class="built_in">tab</span> = table; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        int n, i, fh;</span><br><span class="line">        <span class="comment">// 如果 table 为空的话，初始化 table，属于懒汉模式初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="built_in">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = <span class="built_in">initTable</span>();</span><br><span class="line">        <span class="comment">// 根据 hash 值计算出在 table 里面的位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = <span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="built_in">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果这个位置没有值，通过 CAS 操作将其设置为当前值，不需要加锁</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">casTabAt</span>(<span class="built_in">tab</span>, i, <span class="built_in">null</span>,</span><br><span class="line">                    new Node&lt;K, V&gt;(hash, <span class="built_in">key</span>, value, <span class="built_in">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到表连接点时，需要进行整合表的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">        <span class="comment">// 由于检测到当前哈希表正在扩容，于是让当前线程去协助扩容</span></span><br><span class="line">            tab = <span class="built_in">helpTransfer</span>(<span class="built_in">tab</span>, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="built_in">null</span>;</span><br><span class="line">            <span class="comment">// 这个地方设计非常的巧妙，内置锁 synchronized 锁住了 f,因为 f 是指定特定的tab[i]的；结点上锁，这里的结点可以理解为 hash 值相同组成的链表的头结点</span></span><br><span class="line">            <span class="built_in">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">tabAt</span>(<span class="built_in">tab</span>, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// fh &gt;= 0 说明这个节点是一个链表的节点 不是树的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 在这里遍历链表所有的结点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果 hash 值和 key 值相同  则修改对应结点的 value 值[put 操作和 putIfAbsent 操作业务实现]</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == <span class="built_in">key</span> ||</span><br><span class="line">                                            (ek != <span class="built_in">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 如果遍历到了最后一个结点，那么就证明新的节点需要插入，使用尾插法把它插入在链表尾部</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="built_in">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, <span class="built_in">key</span>,</span><br><span class="line">                                        value, <span class="built_in">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果这个节点是树节点，就按照树的方式插入值</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f instanceof TreeBin) &#123;</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).<span class="built_in">putTreeVal</span>(hash, <span class="built_in">key</span>,</span><br><span class="line">                                value)) != <span class="built_in">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表长度已经达到临界值 8 就需要把链表转换为树结构</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                <span class="comment">// 转化为红黑树</span></span><br><span class="line">                    <span class="built_in">treeifyBin</span>(<span class="built_in">tab</span>, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="built_in">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前 ConcurrentHashMap 的元素数量 + 1，CAS 式更新 baseCount，并判断是否需要扩容</span></span><br><span class="line">    <span class="built_in">addCount</span>(<span class="number">1</span>L, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 的 put 操作的流程就是对当前的 table 进行无条件自循环直到 put 成功，可以分成以下七步流程来概述：</p><ul><li>如果为 null 直接抛空指针异常</li><li>如果没有初始化就先调用 initTable() 方法来进行初始化过程</li><li>如果没有 hash 冲突就直接 casTabAt() 无锁插入</li><li>如果还在进行扩容操作就 helpTransfer() 帮助其扩容</li><li>如果存在 hash 冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，</li><li>如果该链表的数量大于阈值 8，就要先treeifyBin()转换成黑红树的结构[若table length &lt; 64，直接 tryPresize，两倍table.length，不转树]，break 跳出循环</li><li>如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ConcurrentHashMap-与-HashMap-的区别"><a href="#ConcurrentHashMap-与-HashMap-的区别" class="headerlink" title="ConcurrentHashMap 与 HashMap 的区别"></a>ConcurrentHashMap 与 HashMap 的区别</h3><ul><li><strong>线程安全性不同</strong>：ConcurrentHashMap 线程安全，而 HashMap 非线程安全</li><li><strong>key 和 value 是否允许 null 值</strong>：HashMap 允许 Key 和 Value 为 null，而 ConcurrentHashMap 不允许 Key 和 Value 为 null</li><li><strong>是否允许遍历时修改集合</strong>：HashMap 不允许通过 Iterator 遍历的同时通过 HashMap 修改，而 ConcurrentHashMap 允许该行为，并且该更新对后续的遍历可见。</li></ul><h3 id="JDK-1-7-中-ConcurrentHashMap-和-JDK-1-8-中-ConcurrentHashMap-的实现区別？"><a href="#JDK-1-7-中-ConcurrentHashMap-和-JDK-1-8-中-ConcurrentHashMap-的实现区別？" class="headerlink" title="JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別？"></a>JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別？</h3><p>其实可以看出 JDK 1.8 版本的 ConcurrentHashMap 的数据结构已经接近 HashMap，相对而言，ConcurrentHashMap 只是增加了同步的操作来控制并发，从 JDK 1.7 版本的 ReentrantLock + Segment + HashEntry，到 JDK 1.8 版本中 synchronized + CAS + HashEntry + 红黑树，相对而言，JDK 1.7 中 ConcurrentHashMap 和 JDK 1.8 中 ConcurrentHashMap 的实现区別总结如下：</p><ul><li><strong>底层数据结构不同</strong>：JDK 1.7 中 ConcurrentHashMap 采用 Segment 分段锁的数据结构，JDK 1.8 中 ConcurrentHashMap 采用数组 + 链表 + 红黑树的数据结构。</li><li><strong>保证线程安全机制不同</strong>：JDK 1.7 中 ConcurrentHashMap 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK 1.8 中 ConcurrentHashMap 采用 CAS+Synchronized 机制实现线程安全。</li><li><strong>锁的粒度不同</strong>：JDK 1.7 中 ConcurrentHashMap 是对需要进行数据操作的 Segment 加锁，JDK 1.8 中 ConcurrentHashMap 是对每个数组元素加锁（Node）。</li><li><strong>查询的时间复杂度不同</strong>：定位结点的 hash 算法简化会带来弊端，Hash 冲突加剧，因此在链表节点数量大于 8 时，会将链表转化为红黑树进行存储。查询元素的时间复杂度从原来的遍历链表 O(n)，变成遍历红黑树 O(logN)。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://www.jasongj.com/java/concurrenthashmap/" target="_blank" rel="noopener">Java 进阶（六）从 ConcurrentHashMap 的演进看 Java 多线程核心技术</a><br>[2]. <a href="https://www.cnblogs.com/study-everyday/p/6430462.html" target="_blank" rel="noopener">ConcurrentHashMap 原理分析（1.7 与 1.8）</a><br>[3]. <a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a>    </p><hr><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p><small>[1]. 分离锁（lock striping）：分拆锁 (lock spliting) 就是若原先的程序中多处逻辑都采用同一个锁，但各个逻辑之间又相互独立，就可以拆 (Spliting) 为使用多个锁，每个锁守护不同的逻辑。分拆锁有时候可以被扩展，分成可大可小加锁块的集合，并且它们归属于相互独立的对象，这样的情况就是分离锁(lock striping)。（摘自《Java 并发编程实践》）</small></p><p><small>[2]. CAS：CAS 是 compare and swap 的缩写，即我们所说的比较并替换，是用于实现多线程同步的原子指令。CAS 是一种基于锁的操作，是乐观锁。<br>在 Java 中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，线程一旦得到锁，会导致其它所有需要锁的线程挂起，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据，性能较悲观锁有很大的提高。CAS 操作包含三个基本操作数 —— 内存位置（V）、预期原值（A）和新值 (B)。更新一个变量的时候，只有当变量的预期原值（A）和内存位置（V）当中的实际值相同时，才会将内存位置（V）对应的值修改为新值 (B)。CAS 是通过无限循环来获取数据的，若果在第一轮循环中，a 线程获取地址里面的值被 b 线程修改了，那么 a 线程需要自旋，到下次循环才有可能机会执行。CAS 可以有效的提升并发的效率，但同时也会引入 ABA 问题。如线程 1 从内存位置（V）中取出预期原值（A），这时候另一个线程 2 也从内存位置（V）中取出预期原值（A），并且线程 2 进行了一些操作将内存位置（V）中的值变成了新值 (B)，然后线程 2 又将内存位置（V）中的数据变成预期原值（A），这时候线程 1 进行 CAS 操作发现内存位置（V）中仍然是预期原值（A），然后线程 1 操作成功。虽然线程 1 的 CAS 操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。解决方式，在对象中额外再增加一个标记来标识对象是否有过变更【AtomicMarkableReference(通过引入一个 boolean 来反映中间有没有变过)、AtomicStampedReference（通过引入一个 int 来累加来反映中间有没有变过）】。</small></p><p><small>[3]. Unsafe：Unsafe 是 Java 留给开发者的后门，用于直接操作系统内存且不受 Jvm 管辖，实现类似 C++ 风格的操作。Java 不能直接访问操作系统底层，而是通过本地方法来访问，Unsafe 类提供了硬件级别的原子操作。Oracle 官方一般不建议开发者使用 Unsafe 类，因为正如这个类的类名一样，它并不安全，使用不当会造成内存泄露。Unsafe 类在 sun.misc 包下，不属于 Java 标准。很多 Java 的基础类库，包括一些被广泛使用的高性能开发库都是基于 Unsafe 类开发，比如 Netty、Hadoop、Kafka 等。</small></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ConcurrentHashMap 从 JDK 1.5 开始随 java.util.concurrent 包一起引入 JDK 中，主要为了解决 HashMap 线程不安全和 Hashtable 效率不高的问题。&lt;/p&gt;
&lt;p&gt;HashMap 是我们日常开发中最常见的一种容器，根据键值对键的哈希值来确定值对键在集合中的存储位置，因此具有良好的存取和查找功能。但众所周知，它在高并发的情境下是线程不安全的。尤其是在 JDK 1.8 之前，rehash 的过程中采用头插法转移结点，高并发下，多个线程同时操作一条链表将直接导致闭链，易出现逆序且环形链表死循环问题，导致死循环并占满 CPU。JDK 1.8 以来，对 HashMap 的内部进行了很大的改进，采用数组 + 链表 + 红黑树的形式来进行数据的存储。rehash 的过程也进行了改动，基于复制的算法思想，不直接操作原链，而是定义了两条链表分别完成对原链的结点分离操作，在多线程的环境下，采用了尾插法，扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致，所有即使是多线程的情况下也是安全的。JDK 1.8 中的 HashMap 虽然不会导致死循环，但是因为 HashMap 多线程下内存不共享的问题，两个线程同时指向一个 hash 桶数组时，会导致数据覆盖的问题，所以 HashMap 是依旧是线程不安全的。&lt;/p&gt;
&lt;p&gt;HashTable 是线程安全的容器，它在所有涉及到多线程的操作都加上了 synchronized 关键字来锁住整个 table，这就意味着所有的线程都在竞争一把锁，在多线程的环境下，它是安全的，但是无疑是效率低下的，因此 Hashtable 已经是 Java 中的遗留容器，已经不推荐使用。&lt;/p&gt;
&lt;p&gt;因此在多线程条件下，需要满足线程安全，我们可使用 Collections.synchronizedMap 方法构造出一个同步的 Map，使 HashMap 具有线程安全的能力；或者直接使用线程安全的 ConcurrentHashMap。本篇文章将要介绍的 ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 HashMap 很多。&lt;/p&gt;
    
    </summary>
    
      <category term="集合" scheme="https://blog.maoning.vip/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java8" scheme="https://blog.maoning.vip/tags/Java8/"/>
    
      <category term="集合" scheme="https://blog.maoning.vip/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="Java7" scheme="https://blog.maoning.vip/tags/Java7/"/>
    
      <category term="ConcurrentHashMap" scheme="https://blog.maoning.vip/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java8 那些事儿（五）：函数式接口</title>
    <link href="https://blog.maoning.vip/archives/43810ae.html"/>
    <id>https://blog.maoning.vip/archives/43810ae.html</id>
    <published>2019-09-10T10:50:05.000Z</published>
    <updated>2020-08-03T09:25:10.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式接口 (Functional Interface) 就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Java 允许利用 Lambda 表达式创建这些接口的实例。java.util.function 包是 Java 8 增加的一个新技术点 “函数式接口”，此包共有 43 个接口。别指望能够全部记住他们，但是如果能记住其中 6 个基础接口，必要时就可以推断出其余接口了。这些接口是为了使 Lamdba 函数表达式使用的更加简便，当然你也可以自己自定义接口来应用于 Lambda 函数表达式。</p><p>JDK 1.8 API 包含了很多内建的函数式接口，比如 Comparator 或者 Runnable 接口，这些接口都增加了 @FunctionalInterface 注解以便能用在 Lamdba 上。现如今，我们则从 Function 常用函数入口，真正了解一下函数式接口。</p><a id="more"></a><h2 id="Java-8-中函数式接口"><a href="#Java-8-中函数式接口" class="headerlink" title="Java 8 中函数式接口"></a>Java 8 中函数式接口</h2><table><thead><tr><th>接口</th><th>描述</th><th>函数签名</th><th>范例</th></tr></thead><tbody><tr><td>UnaryOperator&lt;T></td><td>接收 T 对象，返回 T 对象</td><td>T apply(T t)</td><td>String::toLowerCase</td></tr><tr><td>BinaryOprator&lt;T></td><td>接收两个 T 对象，返回 T 对象</td><td>T apply(T t1, T t2)</td><td>BigInteger::add</td></tr><tr><td>Predicate&lt;T></td><td>接收 T 对象，返回 boolean</td><td>boolean test(T t)</td><td>Collection::isEmpty</td></tr><tr><td>Function&lt;T, R&gt;</td><td>接收 T 对象，返回 R 对象</td><td>R apply(T t)</td><td>Arrays::asList</td></tr><tr><td>Supplier&lt;T></td><td>提供 T 对象（例如工厂），不接收值</td><td>T get()</td><td>Instant::new</td></tr><tr><td>Consumer&lt;T></td><td>接收 T 对象，不返回值</td><td>void accept(T t)</td><td>System.out::println</td></tr></tbody></table><p>标注为 @FunctionalInterface 的接口被称为函数式接口，该接口有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。是否是一个函数式接口，需要注意的有以下几点：</p><ul><li>该注解只能标记在“有且仅有一个抽象方法”的接口上。</li><li>Java 8 接口中的静态方法和默认方法，都不算是抽象方法。</li><li>接口默认继承 java.lang.Object，所以如果接口显示声明覆盖了 Object 中方法，那么也不算抽象方法。</li><li>该注解不是必须的，如果一个接口符合 “函数式接口” 定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错。</li><li>在一个接口中定义两个自定义的方法，就会产生 Invalid ‘@FunctionalInterface’ annotation; FunctionalInterfaceTest is not a functional interface 错误。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Consumer：消费型接口（void-accept-T-t-）"><a href="#Consumer：消费型接口（void-accept-T-t-）" class="headerlink" title="Consumer：消费型接口（void accept(T t)）"></a>Consumer：消费型接口（void accept(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Consumer&lt;T></td><td>提供一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>BiConsumer&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，不返回执行结果</td></tr><tr><td>DoubleConsumer</td><td>提供一个 double 类型的输入参数，不返回执行结果</td></tr><tr><td>IntConsumer</td><td>提供一个 int 类型的输入参数，不返回执行结果</td></tr><tr><td>LongConsumer</td><td>提供一个 long 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjDoubleConsumer&lt;T></td><td>提供一个 double 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjIntConsumer&lt;T></td><td>提供一个 int 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr><tr><td>ObjLongConsumer&lt;T></td><td>提供一个 long 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</td></tr></tbody></table><p>（1）作用：消费某个对象</p><p>（2）使用场景：Iterable 接口的 forEach 方法需要传入 Consumer，大部分集合类都实现了该接口，用于返回 Iterator 对象进行迭代。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void  accept(T t)</td><td>对给定的参数执行操作</td></tr><tr><td>default  Consumer&lt;T>  andThen(Consumer&lt; ? super T&gt; after)</td><td>返回一个组合函数，after 将会在该函数执行之后应用</td></tr></tbody></table><p>（4）代码示例</p><p>Consumer&lt;T>：提供一个 T 类型的输入参数，不返回执行结果</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testConsumer() &#123;</span><br><span class="line">    <span class="comment">// Consumer&lt;T&gt;:accept(T t)</span></span><br><span class="line">    Consumer&lt;<span class="keyword">String</span>&gt; consumer = System.out::<span class="built_in">println</span>;</span><br><span class="line">    consumer.accept(<span class="string">"hello world!"</span>);    <span class="comment">// hello world!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consumer&lt;T&gt;:andThen(Consumer&lt;? super T&gt; after) -&gt; 返回一个组合函数，after将会在该函数执行之后应用</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"Hello "</span>);</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer_accept = (<span class="built_in">str</span>) -&gt; <span class="built_in">str</span>.<span class="built_in">append</span>(<span class="string">"Jack! "</span>);</span><br><span class="line">    Consumer&lt;StringBuilder&gt; consumer_andThen = (<span class="built_in">str</span>) -&gt; <span class="built_in">str</span>.<span class="built_in">append</span>(<span class="string">"Bob!"</span>);</span><br><span class="line">    consumer_accept.andThen(consumer_andThen).accept(sb);</span><br><span class="line">    System.out.<span class="built_in">println</span>(sb.toString());  <span class="comment">// Hello Jack! Bob!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BiConsumer&lt;T, U&gt; ：提供两个自定义类型的输入参数，不返回执行结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> testBiConsumer() &#123;</span><br><span class="line">    <span class="comment">// BiConsumer&lt;T, U&gt;:accept(T t, U u)</span></span><br><span class="line">    BiConsumer&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; biConsumer = (a, b) -&gt; System.out.printf(<span class="string">"%s %s!"</span>, a, b);</span><br><span class="line">    biConsumer.accept(<span class="string">"hello"</span>, <span class="string">"world"</span>);    <span class="comment">// hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DoubleConsumer ：提供一个 double 类型的输入参数，不返回执行结果</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">testDoubleConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DoubleConsumer:accept(double value)</span></span><br><span class="line">    DoubleConsumer doubleConsumer = System.out::println;</span><br><span class="line">    doubleConsumer.accept(<span class="number">9.12</span>D);   <span class="comment">// 9.12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjDoubleConsumer&lt;T> ： 提供一个 double 类型的输入参数和一个 T 类型的输入参数，不返回执行结果</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjDoubleConsumer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ObjDoubleConsumer&lt;T&gt;:accept(T t, double value)</span></span><br><span class="line">    ObjDoubleConsumer&lt;String&gt; stringObjDoubleConsumer = (s, <span class="keyword">value</span>) -&gt; System.<span class="keyword">out</span>.println(s + <span class="keyword">value</span>);</span><br><span class="line">    stringObjDoubleConsumer.accept(<span class="string">"金额："</span>, <span class="number">9.12</span>D);   <span class="comment">// 金额：9.12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Predicate：断言型接口（boolean-test-T-t-）"><a href="#Predicate：断言型接口（boolean-test-T-t-）" class="headerlink" title="Predicate：断言型接口（boolean test(T t)）"></a>Predicate：断言型接口（boolean test(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Predicate&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>DoublePredicate</td><td>提供一个 double 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>IntPredicate</td><td>提供一个 int 类型的输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>LongPredicate</td><td>提供一个 long 类型的输入参数，返回一个 boolean 类型的结果</td></tr></tbody></table><p>（1）作用：判断对象是否符合某个条件</p><p>（2）使用场景：ArrayList 的 removeIf(Predicate)：删除符合条件的元素。如果条件硬编码在 ArrayList 中，它将提供无数的实现，但是如果让调用者传入条件，这样 ArrayList 就可以从复杂和无法猜测的业务中解放出来。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean  test(T t)</td><td>根据给定的参数进行判断</td></tr><tr><td>Predicate&lt;T>  and(Predicate&lt; ? super T&gt; other)</td><td>返回一个组合判断，将 other 以短路并且的方式加入到函数的判断中</td></tr><tr><td>Predicate&lt;T>  or(Predicate&lt; ? super T&gt; other)</td><td>返回一个组合判断，将 other 以短路或的方式加入到函数的判断中</td></tr><tr><td>Predicate&lt;T>  negate()</td><td>将函数的判断取反</td></tr></tbody></table><p>（4）代码示例</p><p>Predicate&lt;T> ： 提供一个 T 类型的输入参数，返回一个 boolean 类型的结果</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testPredicate() &#123;</span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:boolean test(T t)</span></span><br><span class="line">    Predicate&lt;List&lt;String&gt;&gt; listPredicate = Collection::isEmpty;</span><br><span class="line">    <span class="keyword">System</span>.out.println(listPredicate.test(Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"World"</span>))); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:boolean test(T t)</span></span><br><span class="line">    Predicate&lt;<span class="keyword">Integer</span>&gt; predicate = <span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other)</span></span><br><span class="line">    predicate = predicate.<span class="keyword">and</span>(<span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> &gt;= <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)</span></span><br><span class="line">    predicate = predicate.<span class="keyword">or</span>(<span class="keyword">integer</span> -&gt; <span class="keyword">integer</span> != <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Predicate&lt;T&gt;:Predicate&lt;T&gt; negate()</span></span><br><span class="line">    predicate = predicate.negate();</span><br><span class="line">    <span class="keyword">System</span>.out.println(predicate.test(<span class="number">10</span>)); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function：函数型接口（R-apply-T-t-）"><a href="#Function：函数型接口（R-apply-T-t-）" class="headerlink" title="Function：函数型接口（R apply(T t)）"></a>Function：函数型接口（R apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Function&lt;T, R&gt;</td><td>提供一个 T 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>提供两个自定义类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>DoubleFunction&lt;R></td><td>提供一个 double 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>DoubleToIntFunction</td><td>提供一个 double 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>DoubleToLongFunction</td><td>提供一个 double 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>IntFunction&lt;R></td><td>提供一个 int 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>IntToDoubleFunction</td><td>提供一个 int 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntToLongFunction</td><td>提供一个 int 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>LongFunction&lt;R></td><td>提供一个 long 类型的输入参数，返回一个 R 类型的结果</td></tr><tr><td>LongToDoubleFunction</td><td>提供一个 long 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>LongToIntFunction</td><td>提供一个 long 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToDoubleBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>ToDoubleFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>ToIntBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToIntFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>ToLongBiFunction&lt;T, U&gt;</td><td>提供两个自定义类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>ToLongFunction&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：实现一个”一元函数“，即传入一个值经过函数的计算返回另一个值。</p><p>（2）使用场景：V HashMap.computeIfAbsent(K , Function&lt;K, V&gt;)：如果指定的 key 不存在或相关的 value 为 null 时，设置 key 与关联一个计算出的非 null 值，计算出的值为 null 的话什么也不做(不会去删除相应的 key)。如果 key 存在并且对应 value 不为 null 的话什么也不做。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>R  apply(T t)</td><td>将此参数应用到函数中</td></tr><tr><td>Function&lt;T, V&gt; andThen(Function&lt; ? super R, ? extends V&gt; after)</td><td>返回一个组合函数，该函数结果应用到 after 函数中</td></tr><tr><td>Function&lt;V, R&gt; compose(Function&lt; ? super V, ? extends T&gt; before)</td><td>返回一个组合函数，首先将入参应用到 before 函数，再将 before 函数结果应用到该函数中</td></tr></tbody></table><p>（4）代码示例</p><p>Function&lt;T, R&gt; ： 提供一个 T 类型的输入参数，返回一个 R 类型的结果</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> testFunction() &#123;</span><br><span class="line">    <span class="comment">// Function&lt;T, R&gt;:R apply(T t)</span></span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>[], List&lt;<span class="built_in">String</span>&gt;&gt; asList = Arrays::asList;</span><br><span class="line">    System.out.println(asList.apply(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"Hello"</span>, <span class="string">"World"</span>&#125;));   <span class="comment">// [Hello, World]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; <span class="function"><span class="keyword">function</span> = <span class="title">s</span> -&gt; <span class="title">String</span>.<span class="title">format</span>(<span class="params">"%s, Jack!", s</span>)</span>;</span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; compose = s -&gt; StringUtils.isEmpty(s) ? <span class="string">"Hello"</span> : s;</span><br><span class="line">    <span class="built_in">Function</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; andThen = <span class="built_in">String</span>::toUpperCase;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> s = <span class="function"><span class="keyword">function</span>.<span class="title">compose</span>(<span class="params">compose</span>).<span class="title">andThen</span>(<span class="params">andThen</span>).<span class="title">apply</span>(<span class="params">""</span>)</span>;</span><br><span class="line">    System.out.println(s);  <span class="comment">// HELLO, JACK!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Supplier：供给型接口（R-apply-T-t-）"><a href="#Supplier：供给型接口（R-apply-T-t-）" class="headerlink" title="Supplier：供给型接口（R apply(T t)）"></a>Supplier：供给型接口（R apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>Supplier&lt;T></td><td>不提供输入参数，返回一个 T 类型的结果</td></tr><tr><td>BooleanSupplier</td><td>不提供输入参数，返回一个 boolean 类型的结果</td></tr><tr><td>DoubleSupplier</td><td>不提供输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntSupplier</td><td>不提供输入参数，返回一个 int 类型的结果</td></tr><tr><td>LongSupplier</td><td>不提供输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：创建一个对象（工厂类）</p><p>（2）使用场景：Optional.orElseGet(Supplier&lt; ? extends T&gt;)：当 this 对象为 null，就通过传入 supplier 创建一个 T 返回。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>T  get()</td><td>获取结果值</td></tr></tbody></table><p>（4）代码示例</p><p>Supplier&lt;T> ： 不提供输入参数，返回一个 T 类型的结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testSupplier() &#123;</span><br><span class="line">    <span class="comment">// Supplier&lt;T&gt;:T get();</span></span><br><span class="line">    Supplier&lt;<span class="keyword">String</span>&gt; supplier = () -&gt; <span class="string">"Hello Jack!"</span>;</span><br><span class="line">    System.out.<span class="built_in">println</span>(supplier.<span class="built_in">get</span>()); <span class="comment">// Hello Jack!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Operator：操作型接口（T-apply-T-t-）"><a href="#Operator：操作型接口（T-apply-T-t-）" class="headerlink" title="Operator：操作型接口（T apply(T t)）"></a>Operator：操作型接口（T apply(T t)）</h2><table><thead><tr><th>函数式接口</th><th>描述</th></tr></thead><tbody><tr><td>UnaryOperator&lt;T></td><td>提供一个 T 类型的输入参数，返回一个 T 类型的结果</td></tr><tr><td>BinaryOperator&lt;T></td><td>提供两个 T 类型的输入参数，返回一个 T 类型的结果</td></tr><tr><td>DoubleBinaryOperator</td><td>提供两个 double 类型的输入参数，返回两个 double 类型的结果</td></tr><tr><td>DoubleUnaryOperator</td><td>提供一个 double 类型的输入参数，返回一个 double 类型的结果</td></tr><tr><td>IntBinaryOperator</td><td>提供两个 int 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>IntUnaryOperator</td><td>提供一个 int 类型的输入参数，返回一个 int 类型的结果</td></tr><tr><td>LongBinaryOperator</td><td>提供两个 long 类型的输入参数，返回一个 long 类型的结果</td></tr><tr><td>LongUnaryOperator</td><td>提供一个 long 类型的输入参数，返回一个 long 类型的结果</td></tr></tbody></table><p>（1）作用：实现一个”一元函数“，即传入一个值经过函数的计算返回另一个同类型的值。</p><p>（2）使用场景：UnaryOperator 继承了 Function，与 Function 作用相同，不过 UnaryOperator，限定了传入类型和返回类型必需相同。</p><p>（3）主要方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>T apply(T t)</td><td>将给定参数应用到函数中</td></tr><tr><td>Function&lt;T, V&gt; andThen(Function&lt; ? super T, ? extends V&gt; after)</td><td>返回一个组合函数，该函数结果应用到 after 函数中</td></tr><tr><td>Function&lt;V, T&gt; compose(Function&lt; ? super V, ? extends T&gt; before)</td><td>返回一个组合函数，首先将入参应用到 before 函数，再将 before 函数结果应用到该函数中</td></tr></tbody></table><p>（4）代码示例</p><p>UnaryOperator&lt;T> ： 提供一个 T 类型的输入参数，返回一个 T 类型的结果</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testOperator() &#123;</span><br><span class="line">    <span class="comment">// UnaryOperator&lt;T&gt;:T apply(T t)</span></span><br><span class="line">    UnaryOperator&lt;<span class="keyword">String</span>&gt; unaryOperator = <span class="keyword">String</span>::toUpperCase;</span><br><span class="line">    System.out.<span class="built_in">println</span>(unaryOperator.apply(<span class="string">"Hello World!"</span>));    <span class="comment">// HELLO WORLD!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BinaryOperator&lt;T> ：提供两个 T 类型的输入参数，返回一个 T 类型的结果</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@Test</span></span><br><span class="line"><span class="symbol">public</span> void testBinaryOperator() &#123;</span><br><span class="line">    // <span class="keyword">BinaryOperator&lt;T&gt;:T </span>apply(T t1, T T2)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">BinaryOperator&lt;BigInteger&gt; </span><span class="keyword">binaryOperator </span>= <span class="keyword">BigInteger::add;</span></span><br><span class="line"><span class="keyword"> </span>   System.out.println(<span class="keyword">binaryOperator.apply(BigInteger.ONE, </span><span class="keyword">BigInteger.TEN));</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java.util.function 包已经为大家提供了大量标注的函数接口。只要标准的函数接口能够满足需求，通常应该优先考虑，而不是专门再构建一个新的函数接口。这样会使 API 更加容易学习，通过减少它的概念内容，显著提升互操作性优势，因为许多标准的函数接口都提供了有用的默认方法。</p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.cnblogs.com/huohuoL/p/10545437.html" target="_blank" rel="noopener">JDK8 新特性 - java.util.function-Function 接口</a><br>[2]. <a href="https://www.cnblogs.com/linzhanfly/p/9686941.html" target="_blank" rel="noopener">JAVA8 的 java.util.function 包</a></p><hr><h2 id="Java8-那些事儿系列"><a href="#Java8-那些事儿系列" class="headerlink" title="Java8 那些事儿系列"></a>Java8 那些事儿系列</h2><ul><li><a href="8cef11db.html">Java8 那些事儿（一）：Stream 函数式编程</a></li><li><a href="8eb6feba.html">Java8 那些事儿（二）：Optional 类解决空指针异常</a></li><li><a href="d66032e3.html">Java8 那些事儿（三）：Date/Time API(JSR 310)</a></li><li><a href="139a123e.html">Java8 那些事儿（四）：增强的 Map 集合</a></li><li><a href="43810ae.html">Java8 那些事儿（五）：函数式接口</a></li><li><a href="a3263046.html">Java8 那些事儿（六）：从 CompletableFuture 到异步编程</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;函数式接口 (Functional Interface) 就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Java 允许利用 Lambda 表达式创建这些接口的实例。java.util.function 包是 Java 8 增加的一个新技术点 “函数式接口”，此包共有 43 个接口。别指望能够全部记住他们，但是如果能记住其中 6 个基础接口，必要时就可以推断出其余接口了。这些接口是为了使 Lamdba 函数表达式使用的更加简便，当然你也可以自己自定义接口来应用于 Lambda 函数表达式。&lt;/p&gt;
&lt;p&gt;JDK 1.8 API 包含了很多内建的函数式接口，比如 Comparator 或者 Runnable 接口，这些接口都增加了 @FunctionalInterface 注解以便能用在 Lamdba 上。现如今，我们则从 Function 常用函数入口，真正了解一下函数式接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.maoning.vip/categories/Java/"/>
    
    
      <category term="Function" scheme="https://blog.maoning.vip/tags/Function/"/>
    
      <category term="Lambda" scheme="https://blog.maoning.vip/tags/Lambda/"/>
    
      <category term="函数式接口" scheme="https://blog.maoning.vip/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>了不起的消息队列（一）：浅谈消息队列及常见的分布式消息队列中间件</title>
    <link href="https://blog.maoning.vip/archives/1c55560e.html"/>
    <id>https://blog.maoning.vip/archives/1c55560e.html</id>
    <published>2019-08-30T06:33:22.000Z</published>
    <updated>2020-07-03T08:56:51.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>分布式消息队列中间件是是大型分布式系统不可缺少的中间件，通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。所以消息队列主要解决应用耦合、异步消息、流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性架构。消息队列已经逐渐成为企业应用系统内部通信的核心手段，当前使用较多的消息队列有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分数据库如 Redis、MySQL 以及 PhxSQL 也可实现消息队列的功能。</p><p>在日常学习与开发过程中，消息队列作为系统不可缺少的中间件，显得十分的重要。在现代云架构中，应用程序被分解为多个规模较小且更易于开发、部署和维护的独立构建块。消息队列可为这些分布式应用程序提供通信和协调。而本人也在工作的过程中，前前后后后接触到了 Kafka、RabbitMQ 两款消息队列。所以，本系列文章也主要以 RabbitMQ 和 Kafka 两款典型的消息中间件来做分析。本文是该系列的开篇，主要讲解消息队列的概述、特点等，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。</p><a id="more"></a><h2 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h2><p>消息队列（Message Queue，简称 MQ）是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等等功能，其作为分布式系统架构中的一个重要组件，有着举足轻重的地位。消息队列是构建分布式互联网应用的基础设施，通过 MQ 实现的松耦合架构设计可以提高系统可用性以及可扩展性，是适用于现代应用的最佳设计方案。</p><p><img src="/media/15662836853167/16479c8e7c77109d.jpg" alt="16479c8e7c77109d"></p><h2 id="消息队列特点"><a href="#消息队列特点" class="headerlink" title="消息队列特点"></a>消息队列特点</h2><h3 id="为什么要用消息队列？"><a href="#为什么要用消息队列？" class="headerlink" title="为什么要用消息队列？"></a>为什么要用消息队列？</h3><h4 id="通过异步处理提高系统性能"><a href="#通过异步处理提高系统性能" class="headerlink" title="通过异步处理提高系统性能"></a>通过异步处理提高系统性能</h4><p>讲解该特点之前，我们先了解一下同步架构和异步架构的区别：</p><ul><li>同步调用：是指从请求的发起一直到最终的处理完成期间，请求的调用方一直在同步阻塞等待调用的处理完成。</li><li>异步调用：是指在请求发起的处理过程中，客户端的代码已经返回了，它可以继续进行自己的后续操作，而不需要等待调用处理完成，这就叫做异步调用。</li></ul><p><img src="/media/15662836853167/656726733d3239313233.jpg" alt="656726733d3239313233"></p><p>如上图，在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</p><p>通过以上分析我们可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示： </p><p><img src="/media/15662836853167/6726733d3133353530.jpg" alt="6726733d3133353530"></p><p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><h4 id="降低系统耦合性"><a href="#降低系统耦合性" class="headerlink" title="降低系统耦合性"></a>降低系统耦合性</h4><p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p><p>我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p><p><img src="/media/15662836853167/56726733d3134393436.jpg" alt="56726733d3134393436"></p><p>消息队列使利用发布 - 订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。</p><p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</p><h3 id="使用消息队列带来的一些问题？"><a href="#使用消息队列带来的一些问题？" class="headerlink" title="使用消息队列带来的一些问题？"></a>使用消息队列带来的一些问题？</h3><ul><li>系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等情况，但是，引入 MQ 之后你就需要如何保证消息队列的高可用。</li><li>系统复杂性提高： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题，系统复发性提高。</li><li>一致性问题： 消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况。</li></ul><h2 id="JMS-VS-AMQP"><a href="#JMS-VS-AMQP" class="headerlink" title="JMS VS AMQP"></a>JMS VS AMQP</h2><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java 消息服务（Java Message Service，JMS）应用程序接口是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。JMS PI 是一个消息服务的标准或者说是规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。点对点与发布订阅最初是由 JMS 定义的。这两种模式主要区别或解决的问题就是发送到队列的消息能否重复消费。</p><p>JMS 规范目前支持两种消息模型：点对点（point to point，queue）和发布 / 订阅（publish/subscribe，topic）。</p><p><img src="/media/15662836853167/20140410230348859.png" alt="20140410230348859"></p><h4 id="点对点（P2P）模型"><a href="#点对点（P2P）模型" class="headerlink" title="点对点（P2P）模型"></a>点对点（P2P）模型</h4><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。点对点（P2P）使用队列（Queue）作为消息通信载体；满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</p><p>Queue 实现了负载均衡，一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，一个 queue 可以有很多消费者，他们之间实现了负载均衡， 所以 Queue 实现了一个可靠的负载均衡。</p><p><img src="/media/15662836853167/20150817113531436.jpg" alt="20150817113531436"></p><p>特点：</p><ul><li>每个消息只用一个消费者；</li><li>发送者和接受者没有时间依赖；</li><li>接受者确认消息接受和处理成功。</li></ul><h4 id="发布-订阅（Pub-Sub）模型"><a href="#发布-订阅（Pub-Sub）模型" class="headerlink" title="发布 / 订阅（Pub/Sub）模型"></a>发布 / 订阅（Pub/Sub）模型</h4><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。发布订阅模型（Pub/Sub） 使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。</p><p>Topic 实现了发布和订阅，当你发布一个消息，所有订阅这个 Topic 的服务都能得到这个消息，所以从 1 到 N 个订阅者都能得到一个消息的拷贝， 只有在消息代理收到消息时有一个有效订阅时的订阅者才能得到这个消息的拷贝。</p><p><img src="/media/15662836853167/20150817113626248.jpg" alt="20150817113626248"></p><p>特点：</p><ul><li>每个消息可以有多个订阅者；</li><li>客户端只有订阅后才能接收到消息；</li><li>持久订阅和非持久订阅。</li></ul><blockquote><p>注意：</p><ol><li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li><li>非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时约等于点对点模。</li></ol></blockquote><h4 id="点对点（P2P）模型与发布-订阅（Pub-Sub）模型应用"><a href="#点对点（P2P）模型与发布-订阅（Pub-Sub）模型应用" class="headerlink" title="点对点（P2P）模型与发布 / 订阅（Pub/Sub）模型应用"></a>点对点（P2P）模型与发布 / 订阅（Pub/Sub）模型应用</h4><ul><li>点对点模型：主要用于一些耗时较长的、逻辑相对独立的业务。</li></ul><p>比如说发送邮件这样一个操作。因为发送邮件比较耗时，而且应用程序其实也并不太关心邮件发送是否成功，发送邮件的逻辑也相对比较独立，所以它只需要把邮件消息丢到消息队列中就可以返回了，而消费者也不需要关心是哪个生产者去发送的邮件，它只需要把邮件消息内容取出来以后进行消费，通过远程服务器将邮件发送出去就可以了。而且每个邮件只需要被发送一次。所以消息只被一个消费者消费就可以了。</p><ul><li>发布订阅模型：如新用户注册这样一个消息，需要使用按主题发布的方式。</li></ul><p>比如新用户注册，一个新用户注册成功以后，需要给用户发送一封激活邮件，发送一条欢迎短信，还需要将用户注册数据写入数据库，甚至需要将新用户信息发送给关联企业的系统，比如淘宝新用户信息发送给支付宝，这样允许用户可以一次注册就能登录使用多个关联产品。一个新用户注册，会把注册消息发送给一个主题，多种消费者可以订阅这个主题。比如发送邮件的消费者、发送短信的消费者、将注册信息写入数据库的消费者，跨系统同步消息的消费者等。</p><h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP（advanced message queuing protocol）在 2003 年时被提出，最早用于解决金融领不同平台之间的消息传递交互问题。顾名思义，AMQP 是一种协议，更准确的说是一种 binary wire-level protocol（链接协议）。这是其和 JMS 的本质差别，AMQP 不从 API 层进行限定，而是直接定义网络交换的数据格式。这使得实现了 AMQP 的 provider 天然性就是跨平台的。意味着我们可以使用 Java 的 AMQP provider，同时使用一个 python 的 producer 加一个 rubby 的 consumer。</p><p>在 AMQP 中，消息路由（message routing）和 JMS 存在一些差别，在 AMQP 中增加了 Exchange 和 binding 的角色。producer 将消息发送给 Exchange，binding 决定 Exchange 的消息应该发送到那个 queue，而 consumer 直接从 queue 中消费消息。</p><p><img src="/media/15662836853167/20140410230404281.png" alt="20140410230404281"></p><p>AMQP 提供五种消息模型：①Direct Exchange；②Fanout Exchange；③Topic Exchange；④Headers Exchange；⑤System Exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分。</p><h3 id="JMS-与-AMQP-对比"><a href="#JMS-与-AMQP-对比" class="headerlink" title="JMS 与 AMQP 对比"></a>JMS 与 AMQP 对比</h3><p><img src="/media/15662836853167/20190823155319.png" alt="20190823155319"></p><p>总结：</p><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题 / 订阅 方式两种。</li></ul><h2 id="消息队列推拉模型"><a href="#消息队列推拉模型" class="headerlink" title="消息队列推拉模型"></a>消息队列推拉模型</h2><p>Push 推消息模型：消息生产者将消息发送给消息队列，消息队列又将消息推给消息消费者。</p><p>Pull 拉消息模型：消费者请求消息队列接受消息，消息生产者从消息队列中拉该消息。</p><p><img src="/media/15662836853167/16479c8ea4b19ea9.jpg" alt="16479c8ea4b19ea9"></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ 实现了 AQMP 协议，AQMP 协议定义了消息路由规则和方式。生产端通过路由规则发送消息到不同 queue，消费端根据 queue 名称消费消息。此外 RabbitMQ 是向消费端推送消息，订阅关系和消费状态保存在服务端。</p><p><img src="/media/15662836853167/20150817114804971.jpg" alt="20150817114804971"></p><p><img src="/media/15662836853167/20150817114828518.jpg" alt="20150817114828518"></p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>Kafka 只支持消息持久化，消费端为拉模型，消费状态和订阅关系由客户端端负责维护，消息消费完后不会立即删除，会保留历史消息。因此支持多订阅时，消息只会存储一份就可以了。同一个订阅组会消费 topic 所有消息，每条消息只会被同一个订阅组的一个消费节点消费，同一个订阅组内不同消费节点会消费不同消息。</p><p><img src="/media/15662836853167/20150817114859626.jpg" alt="20150817114859626"></p><h2 id="消息队列使用场景"><a href="#消息队列使用场景" class="headerlink" title="消息队列使用场景"></a>消息队列使用场景</h2><h3 id="异步处理：实现异步处理，提升处理性能"><a href="#异步处理：实现异步处理，提升处理性能" class="headerlink" title="异步处理：实现异步处理，提升处理性能"></a>异步处理：实现异步处理，提升处理性能</h3><p>对一些比较耗时的操作，可以把处理过程通过消息队列进行异步处理。这样做可以推迟耗时操作的处理，使耗时操作异步化，而不必阻塞客户端的程序，客户端的程序在得到处理结果之前就可以继续执行，从而提高客户端程序的处理性能。非核心流程异步化，减少系统响应时间，提高吞吐量。</p><p>例如：短信通知、终端状态推送、App 推送、用户注册等。</p><h3 id="解耦：可以使生产者和消费者的代码实现解耦合"><a href="#解耦：可以使生产者和消费者的代码实现解耦合" class="headerlink" title="解耦：可以使生产者和消费者的代码实现解耦合"></a>解耦：可以使生产者和消费者的代码实现解耦合</h3><p>可以多个生产者发布消息，多个消费者处理消息，共同完成完整的业务处理逻辑，但是它们的不需要直接的交互调用，没有代码的依赖耦合。在传统的同步调用中，调用者代码必须要依赖被调用者的代码，也就是生产者代码必须要依赖消费者的处理逻辑代码，代码需要直接的耦合，而使用消息队列，这两部分的代码不需要进行任何的耦合。因为耦合程度越低的代码越容易维护，也越容易进行扩展。</p><p>比如新用户注册，如果用传统同步调用的方式，那么发邮件、发短信、写数据库、通知关联系统这些代码会和用户注册代码直接耦合起来，整个代码看起来就是完成用户注册逻辑后，后面必然跟着发邮件、发短信这些代码。如果要新增一个功能，比如将监控用户注册情况，将注册信息发送到业务监控系统，就必须要修改前面的代码，至少增加一行代码，发送注册信息到监控系统，我们知道，任何代码的修改都可能会引起 bug。</p><p>而使用分布式消息队列实现生产者和消费者解耦合以后，用户注册以后，不需要调用任何后续处理代码，只需要将注册消息发送到分布式消息队列就可以了。如果要增加新功能，只需要写个新功能的消费者程序，在分布式消息队列中，订阅用户注册主题就可以了，不需要修改原来任何一行代码。</p><h3 id="流量削峰和流控：可以平衡流量峰值，削峰填谷"><a href="#流量削峰和流控：可以平衡流量峰值，削峰填谷" class="headerlink" title="流量削峰和流控：可以平衡流量峰值，削峰填谷"></a>流量削峰和流控：可以平衡流量峰值，削峰填谷</h3><p>当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的 “漏斗”，进行限流控制。在下游有能力处理的时候，再进行分发。</p><p>使用消息队列，即便是访问流量持续的增长，系统依然可以持续地接收请求。这种情况下，虽然生产者发布消息的速度比消费者消费消息的速度快，但是可以持续的将消息纳入到消息队列中，用消息队列作为消息的缓冲，因此短时间内，发布者不会受到消费处理能力的影响。</p><p>在访问高峰，用户的并发访问数可能超过了系统的处理能力，所以在高峰期就可能会导致系统负载过大，响应速度变慢，更严重的可能会导致系统崩溃。这种情况下，通过消息队列将用户请求的消息纳入到消息队列中，通过消息队列缓冲消费者处理消息的速度。</p><p>消息的生产者它有高峰有低谷，但是到了消费者这里，只会按照自己的最佳处理能力去消费消息。高峰期它会把消息缓冲在消息队列中，而在低谷期它也还是使用自己最大的处理能力去获取消息，将前面缓冲起来、来不及及时处理的消息处理掉。那么，通过这种手段可以实现系统负载消峰填谷，也就是说将访问的高峰消掉，而将访问的低谷填平，使系统处在一个最佳的处理状态之下，不会对系统的负载产生太大的冲击。</p><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。短信系统可能由于短板效应，速度卡在网关上（每秒几百次请求），跟前端的并发量不是一个数量级。于是，就造成支付系统和短信系统的处理能力出现差异化。</p><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过协商、滑动窗口等复杂的方案也不是说不能实现。但系统复杂性指数级增长，势必在上游或者下游做存储，并且要处理定时、拥塞等一系列问题。而且每当有处理能力有差距的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><h3 id="易伸缩：可以让系统获得更好的伸缩性"><a href="#易伸缩：可以让系统获得更好的伸缩性" class="headerlink" title="易伸缩：可以让系统获得更好的伸缩性"></a>易伸缩：可以让系统获得更好的伸缩性</h3><p>耗时的任务可以通过分布式消息队列，向多台消费者服务器并行发送消息，然后在很多台消费者服务器上并行处理消息，也就是说可以在多台物理服务器上运行消费者。那么当负载上升的时候，可以很容易地添加更多的机器成为消费者。</p><p>例如：用户上传文件后，通过发布消息的方式，通知后端的消费者获取数据、读取文件，进行异步的文件处理操作。那么当前端发布更多文件的时候，或者处理逻辑比较复杂的时候，就可以通过添加后端的消费者服务器，提供更强大的处理能力。</p><h3 id="隔离失效机器以及自我修复：失败隔离和自我修复"><a href="#隔离失效机器以及自我修复：失败隔离和自我修复" class="headerlink" title="隔离失效机器以及自我修复：失败隔离和自我修复"></a>隔离失效机器以及自我修复：失败隔离和自我修复</h3><p>因为发布者不直接依赖消费者，所以分布式消息队列可以将消费者系统产生的错误异常与生产者系统隔离开来，生产者不受消费者失败的影响。当在消息消费过程中出现处理逻辑失败的时候，这个错误只会影响到消费者自身，而不会传递给消息的生产者，也就是应用程序可以按照原来的处理逻辑继续执行。</p><p>所以，这也就意味着在任何时候都可以对后端的服务器执行维护和发布操作。可以重启、添加或删除服务器，而不影响生产者的可用性，这样简化了部署和服务器管理的难度。</p><h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输和缓冲的问题。日志采集客户端，负责日志数据采集，定时写受写入 Kafka 队列；Kafka 消息队列，负责日志数据的接收，存储和转发；日志处理应用，订阅并消费 kafka 队列中的日志数据。</p><h2 id="消息队列技术对比"><a href="#消息队列技术对比" class="headerlink" title="消息队列技术对比"></a>消息队列技术对比</h2><ul><li><p><strong>ActiveMQ</strong> 是 Apache 出品的、采用 Java 语言编写的完全基于 JMS1.1 规范的面向消息的中间件，为应用程序提供高效的、可扩展的、稳定的和安全的企业级消息通信。不过由于历史原因包袱太重，目前市场份额没有后面三种消息中间件多，其最新架构被命名为 Apollo，号称下一代 ActiveMQ，有兴趣的同学可行了解。</p></li><li><p><strong>RabbitMQ</strong> 是采用 Erlang 语言实现的 AMQP 协议的消息中间件，最初起源于金融系统，用于在分布式系统中存储转发消息。RabbitMQ 发展到今天，被越来越多的人认可，这和它在可靠性、可用性、扩展性、功能丰富等方面的卓越表现是分不开的。主要特点是性能好，社区活跃，但是 RabbitMQ 用 Erlang 开发，我们的应用很少用 Erlang，所以不便于二次开发和维护。</p></li><li><p><strong>Kafka</strong> 是由 LinkedIn 公司采用 Scala 语言开发的一个分布式、多分区、多副本且基于 zookeeper 协调的分布式消息系统，现已捐献给 Apache 基金会。它是一种高吞吐量的分布式发布订阅消息系统，以可水平扩展和高吞吐率而被广泛使用。目前越来越多的开源分布式处理系统如 Cloudera、Apache Storm、Spark、Flink 等都支持与 Kafka 集成。</p></li><li><p><strong>RocketMQ</strong> 是阿里开源的消息中间件，目前在 Apache 孵化，使用纯 Java 开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ 思路起源于 Kafka，但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog 分发等场景，支撑了阿里多次双十一活动。</p></li><li><p><strong>ZeroMQ</strong> 是基于 C 语言开发，号称史上最快的消息队列。ZeroMQ 是一个消息处理队列库，可在多线程、多内核和主机之间弹性伸缩，虽然大多数时候我们习惯将其归入消息队列家族之中，但是其和前面的几款有着本质的区别，ZeroMQ 本身就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的 Socket API 上加上一层封装而已。</p></li></ul><p>总结：</p><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用 RocketMQ 挺好的</li><li>kafka 最初设计时就是针对互联网的分布式、高可用应用场景而设计，所以其特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul><p><img src="/media/15662836853167/20190826102530.png" alt="20190826102530"></p><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://juejin.im/post/5b41fe36e51d45191252e79e#heading-21" target="_blank" rel="noopener">浅谈消息队列及常见的消息中间件</a><br>[2]. <a href="https://mp.weixin.qq.com/s/ad7jibTb5nTzh3nDQYKFeg" target="_blank" rel="noopener">消息中间件选型分析</a><br>[3]. <a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">新手也能看懂，消息队列其实很简单</a><br>[4]. <a href="https://mp.weixin.qq.com/s/MbM3xc5egIEaklRKfr7nzg" target="_blank" rel="noopener">10 分钟搞懂：95% 的程序员都拎不清的分布式消息队列中间件</a></p><hr><h2 id="了不起的消息队列系列"><a href="#了不起的消息队列系列" class="headerlink" title="了不起的消息队列系列"></a>了不起的消息队列系列</h2><ul><li><a href="1c55560e.html">了不起的消息队列（一）：浅谈消息队列及常见的分布式消息队列中间件</a></li><li><a href="f99da47b.html">了不起的消息队列（二）：啊哈！RabbitMQ</a></li><li><a href="5d3d79c7.html">了不起的消息队列（三）：致敬匠心，Kafka</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;分布式消息队列中间件是是大型分布式系统不可缺少的中间件，通过消息队列，应用程序可以在不知道彼此位置的情况下独立处理消息，或者在处理消息前不需要等待接收此消息。所以消息队列主要解决应用耦合、异步消息、流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性架构。消息队列已经逐渐成为企业应用系统内部通信的核心手段，当前使用较多的消息队列有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分数据库如 Redis、MySQL 以及 PhxSQL 也可实现消息队列的功能。&lt;/p&gt;
&lt;p&gt;在日常学习与开发过程中，消息队列作为系统不可缺少的中间件，显得十分的重要。在现代云架构中，应用程序被分解为多个规模较小且更易于开发、部署和维护的独立构建块。消息队列可为这些分布式应用程序提供通信和协调。而本人也在工作的过程中，前前后后后接触到了 Kafka、RabbitMQ 两款消息队列。所以，本系列文章也主要以 RabbitMQ 和 Kafka 两款典型的消息中间件来做分析。本文是该系列的开篇，主要讲解消息队列的概述、特点等，然后对消息队列使用场景进行分析，最后对市面上比较常见的消息队列产品进行技术对比。&lt;/p&gt;
    
    </summary>
    
      <category term="消息队列" scheme="https://blog.maoning.vip/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="RabbitMQ" scheme="https://blog.maoning.vip/tags/RabbitMQ/"/>
    
      <category term="Kafka" scheme="https://blog.maoning.vip/tags/Kafka/"/>
    
      <category term="JMS" scheme="https://blog.maoning.vip/tags/JMS/"/>
    
      <category term="AMQP" scheme="https://blog.maoning.vip/tags/AMQP/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</title>
    <link href="https://blog.maoning.vip/archives/f4f43ede.html"/>
    <id>https://blog.maoning.vip/archives/f4f43ede.html</id>
    <published>2019-08-07T09:14:45.000Z</published>
    <updated>2020-10-12T07:46:22.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 并发编程是整个 Java 开发体系中最难以理解但也是最重要的知识点，也是各类开源分布式框架（如 ZooKeeper、Kafka、Spring Cloud、Netty 等）中各个并发组件实现的基础。J.U.C 并发包，即 java.util.concurrent 包，大大提高了并发性能，是 JDK 的核心工具包，是 JDK 1.5 之后，由 Doug Lea 实现并引入。而 AQS 被认为是 J.U.C 的核心。</p><p>AQS 是一个抽象类，并没有对并发类提供了一个统一的接口定义，而是由子类根据自身的情况实现相应的方法，AQS 中一般包含两个方法 acquire(int)、release(int)，获取同步状态和释放同步状态，AQS 根据其状态是否独占分为独占模式和共享模式。</p><ul><li>独占模式：同一时刻最多只有一个线程获取同步状态，处于该模式下，其他线程试图获取该锁将无法获取成功。</li><li>共享模式：同一时刻会有多个线程获取共享同步状态，处于该模式下，其他线程试图获取该锁可能会获取成功。</li></ul><p>同步器根据同步状态分为独占模式和共享模式，独占模式包括类：ReentrantLock、ReentrantReadWriteLock.WriteLock，共享模式包括：Semaphore、CountDownLatch、ReentrantReadWriteLock.ReadLock，本文将着重介绍一下 java.util.concurrent 包下一些辅助同步器类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、Phaser。</p><a id="more"></a><h2 id="CountDownLatch-闭锁"><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch - 闭锁"></a>CountDownLatch - 闭锁</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 是一个同步辅助工具类，通过它可以完成类似于阻塞当前线程的功能，也就是一个或多个线程一直等待直到其他线程执行完成。即允许一个或多个线程一直等待，直到其他线程执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有框架服务之后执行。</p><p>CountDownLatch 用了一个给定的计数器 cnt 来进行初始化，该计数器的操作是原子操作，即同时只能有一个线程操作该计数器，调用该类 await 方法的线程会一直处于阻塞状态，直到其他线程调用 countDown 方法时计数器的值变成 0，每次调用 countDown 时计数器的值会减 1，当计数器的值为 0 时所有因 await 方法而处于等待状态的线程就会继续执行。计数器 cnt 是闭锁需要等待的线程数量，只能被设置一次，且 CountDownLatch 没有提供任何机制去重新设置计数器 count，如果需要重置，可以考虑使用 CyclicBarrier。</p><p><img src="/media/15651639608949/CountdownLatch_example.png" alt="CountdownLatch_example"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>（1）开启多个线程分块下载一个大文件，每个线程只下载固定的一截，最后由另外一个线程来拼接所有的分段。</p><p>（2）应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><p>（3）确保一个计算不会执行，直到所需要的资源被初始化。</p><p>（4）并行计算，处理量很大时可以将运算任务拆分成多个子任务，当所有子任务都完成之后，父任务再将所有子任务都结果进行汇总。</p><h3 id="主要接口分析"><a href="#主要接口分析" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>CountDownLatch 内部依赖 Sync 实现，而 Sync 继承 AQS。CountDownLatch 关键接口如下：</p><ul><li>countDown() 如果当前计数器的值大于 1，则将其减 1；若当前值为 1，则将其置为 0 并唤醒所有通过 await 等待的线程；若当前值为 0，则什么也不做直接返回。</li><li>await() 等待计数器的值为 0，若计数器的值为 0 则该方法返回；若等待期间该线程被中断，则抛出 InterruptedException 并清除该线程的中断状态。</li><li>await(long timeout, TimeUnit unit) 在指定的时间内等待计数器的值为 0，若在指定时间内计数器的值变为 0，则该方法返回 true；若指定时间内计数器的值仍未变为 0，则返回 false；若指定时间内计数器的值变为 0 之前当前线程被中断，则抛出 InterruptedException 并清除该线程的中断状态。</li><li>getCount() 读取当前计数器的值，一般用于调试或者测试。</li></ul><h3 id="Coding-演示"><a href="#Coding-演示" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）作为一个开关 / 入口</p><p>将初始计数值为 1 的 CountDownLatch 作为一个的开关或入口，在调用 countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(countDownLatch));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        doSomething();</span><br><span class="line">        <span class="comment">// 主线程开启开关</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"start.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch countDownLatch) &#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 所有执行线程在此处等待开关开启 [多个子线程同时执行]</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            <span class="comment">// 子线程执行</span></span><br><span class="line">            doWork();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// start..run..run..run..run..run..run..run..run..run..run..</span></span><br></pre></td></tr></table></figure><p>（2）作为一个完成信号</p><p>将初始计数值为 N 的 CountDownLatch 作为一个完成信号点，使某个线程在其它 N 个线程完成某项操作之前一直等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CountDownLatch</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(WORK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(countDownLatch));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待其它 N 个线程完成</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        <span class="comment">// 主线程执行</span></span><br><span class="line">        doSomething();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    Worker(CountDownLatch countDownLatch) &#123;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 子线程执行</span></span><br><span class="line">        doWork();</span><br><span class="line">        <span class="comment">// 每个线程做完自己的事情后, 就将计数器减去 1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// run..run..run..run..run..run..run..run..run..run..end</span></span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier - 循环栅栏"></a>CyclicBarrier - 循环栅栏</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CyclicBarrier 和 CountDownLatch 是非常类似的，CyclicBarrier 核心的概念是在于设置一个等待线程的数量边界，到达了此边界之后进行执行。CyclicBarrier 也是一个同步辅助工具类，它允许一组线程相互等待直到到达某个公共的屏障点（Common Barrier Point），通过它可以完成多个线程之间相互等待时，只有当每个线程都准备就绪后才能各自继续执行后面的操作。</p><p>CyclicBarrier 也是通过计数器来实现，当某个线程调用 await 方法后就进入等待状态，计数器执行加一操作。当计数器的值达到了设置的初始值时等待状态的线程会被唤醒继续执行。通过调用 CyclicBarrier 对象的 await() 方法，两个线程可以实现互相等待。一旦 N 个线程在等待 CyclicBarrier 达成，所有线程将被释放掉去继续执行。由于 CyclicBarrier 在释放等待线程后可以重用，所以可以称之为循环栅栏。</p><p><img src="/media/15651639608949/759814-20181031152238027-1792385756.png" alt="759814-20181031152238027-1792385756"></p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>CyclicBarrier 特别适用于并行迭代计算，每个线程负责一部分计算，然后在栅栏处等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。</p><h3 id="主要接口分析-1"><a href="#主要接口分析-1" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>CyclicBarrier 并没有自己去实现 AQS 框架的 API，而是利用了 ReentrantLock 和 Condition。</p><p>CyclicBarrier 提供的关键方法如下：</p><ul><li>await() 等待其它参与方的到来（调用 await()）。如果当前调用是最后一个调用，则唤醒所有其它的线程的等待并且如果在构造 CyclicBarrier 时指定了 action，当前线程会去执行该 action，然后该方法返回该线程调用 await 的次序（getParties()-1 说明该线程是第一个调用 await 的，0 说明该线程是最后一个执行 await 的），接着该线程继续执行 await 后的代码；如果该调用不是最后一个调用，则阻塞等待；如果等待过程中，当前线程被中断，则抛出 InterruptedException；如果等待过程中，其它等待的线程被中断，或者其它线程等待超时，或者该 barrier 被 reset，或者当前线程在执行 barrier 构造时注册的 action 时因为抛出异常而失败，则抛出 BrokenBarrierException。</li><li>await(long timeout, TimeUnit unit) 与 await() 唯一的不同点在于设置了等待超时时间，等待超时时会抛出 TimeoutException。</li><li>reset() 该方法会将该 barrier 重置为它的初始状态，并使得所有对该 barrier 的 await 调用抛出 BrokenBarrierException。</li></ul><p>CyclicBarrier 提供的两个构造函数：</p><ul><li>CyclicBarrier(int parties)：parties 表示拦截线程的数量。创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，但它不会在启动 barrier 时执行预定义的操作。</li><li>CyclicBarrier(int parties, Runnable barrierAction) ：barrierAction 为 CyclicBarrier 接收的 Runnable 命令，用于在线程到达屏障时，优先执行 barrierAction ，用于处理更加复杂的业务场景。创建一个新的 CyclicBarrier，它将在给定数量的参与者（线程）处于等待状态时启动，并在启动 barrier 时执行给定的屏障操作，该操作由最后一个进入 barrier 的线程执行。</li></ul><h3 id="Coding-演示-1"><a href="#Coding-演示-1" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）简单例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 10 的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(WORK_COUNT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    Worker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 多个线程之间相互等待时，只有当每个线程都准备就绪后才能各自继续执行后面的操作</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子线程执行</span></span><br><span class="line">        doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span></span><br></pre></td></tr></table></figure><p>（2）执行 barrierAction</p><p>在 ready 状态时日志是每秒输出一条，当有 5 条 ready 时会一次性输出 5 条 continue。这就是前面讲的全部线程准备就绪后同时开始执行。在初始化 CyclicBarrier 时还可以在等待线程数后指定一个 runnable，含义是当线程到达这个屏障时优先执行这里的 runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer WORK_COUNT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化计数器为 5 的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; System.out.println(String.format(<span class="string">"%s call back is ready."</span>, Thread.currentThread().getName())));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Worker(cyclicBarrier));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 平滑地关闭 ExecutorService</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    Worker(CyclicBarrier cyclicBarrier) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s is ready"</span>, Thread.currentThread().getName()));</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s continue"</span>, Thread.currentThread().getName()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 call back is ready.</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 is ready</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 call back is ready.</span></span><br><span class="line"><span class="comment">// pool-1-thread-3 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-5 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-4 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-2 continue</span></span><br><span class="line"><span class="comment">// pool-1-thread-1 continue</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h3><p>CyclicBarrier 与 CountDownLatch 可能容易混淆，我们强调下其区别：</p><ul><li><p>CountDownLatch 的参与线程是有不同角色的，有的负责倒计时，有的在等待倒计时变为 0，负责倒计时和等待倒计时的线程都可以有多个，它用于不同角色线程间的同步。</p></li><li><p>CyclicBarrier 的参与线程角色是一样的，用于同一角色线程间的协调一致。</p></li><li><p>CountDownLatch 是一次性的，而 CyclicBarrier 是可以重复利用的。</p></li></ul><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore - 信号量"></a>Semaphore - 信号量</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Semaphore，又名信号量，这个类的作用有点类似于 “许可证”。信号量 Semaphore 是一个控制访问多个共享资源的计数器，和 CountDownLatch 一样，其本质上是一个 “共享锁”。从源码角度来看，Semaphore 的实现方式和 CountDownLatch 非常相似，基于 AQS 做了一些定制。通过维持 AQS 的锁全局计数 state 字段来实现定量锁的加锁和解锁操作。Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目。</p><p>有时，我们因为一些原因需要控制同时访问共享资源的最大线程数量，比如出于系统性能的考虑需要限流，或者共享资源是稀缺资源，我们需要有一种办法能够协调各个线程，以保证合理的使用公共资源。当有线程想要访问共享资源时，需要先获取 (acquire) 的许可；如果许可不够了，线程需要一直等待，直到许可可用。当线程使用完共享资源后，可以归还 (release) 许可，以供其它需要的线程使用；然而，实际上并没有真实的许可证对象供线程使用，Semaphore 只是对可用的数量进行管理维护。</p><p><img src="/media/15651639608949/759814-20181031152255999-607973962.png" alt="759814-20181031152255999-607973962"></p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>Semaphore 可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p><h3 id="主要接口分析-2"><a href="#主要接口分析-2" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Semaphore 内部包含公平锁（FairSync）和非公平锁（NonfairSync），继承内部类 Sync，其中 Sync 继承 AQS，作为 Semaphore 的公平锁和非公平锁的基类。</p><p>CyclicBarrier 提供的关键方法如下：</p><ul><li>isFair()：是否公平模式 FIFO</li><li>availablePermits()：获取当前可用的许可证数量</li><li>acquire()：当前线程尝试去阻塞的获取 1 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 1 个可用的许可证，则会停止等待，继续执行；当前线程被中断，则会抛出 InterruptedException 异常，并停止等待，继续执行。</li><li>acquire(permits)：当前线程尝试去阻塞的获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 n 个可用的许可证，则会停止等待，继续执行；当前线程被中断，则会抛出 InterruptedException 异常，并停止等待，继续执行。</li><li>acquierUninterruptibly()：当前线程尝试去阻塞的获取 1 个许可证 (不可中断的)。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 1 个可用的许可证，则会停止等待，继续执行。</li><li>acquireUninterruptibly(permits)：当前线程尝试去阻塞的获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了 n 个可用的许可证，则会停止等待，继续执行。</li><li>tryAcquire()：当前线程尝试去获取 1 个许可证。此过程是非阻塞的，它只是在方法调用时进行一次尝试。如果当前线程获取了 1 个可用的许可证，则会停止等待，继续执行，并返回 true。如果当前线程没有获得这个许可证，也会停止等待，继续执行，并返回 false。</li><li>tryAcquire(permits)：当前线程尝试去获取 permits 个许可证。此过程是非阻塞的，它只是在方法调用时进行一次尝试。如果当前线程获取了 permits 个可用的许可证，则会停止等待，继续执行，并返回 true。如果当前线程没有获得 permits 个许可证，也会停止等待，继续执行，并返回 false。</li><li>tryAcquire(timeout, TimeUnit)：当前线程在限定时间内，阻塞的尝试去获取 1 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了可用的许可证，则会停止等待，继续执行，并返回 true；当前线程等待时间 timeout 超时，则会停止等待，继续执行，并返回 false；当前线程在 timeout 时间内被中断，则会抛出 InterruptedException 一次，并停止等待，继续执行。</li><li>tryAcquire(permits, timeout, TimeUnit)：当前线程在限定时间内，阻塞的尝试去获取 permits 个许可证。此过程是阻塞的，它会一直等待许可证，直到发生以下任意一件事：当前线程获取了可用的 permits 个许可证，则会停止等待，继续执行，并返回 true；当前线程等待时间 timeout 超时，则会停止等待，继续执行，并返回 false；当前线程在 timeout 时间内被中断，则会抛出 InterruptedException 一次，并停止等待，继续执行。</li><li>release()：当前线程释放 1 个可用的许可证。</li><li>release(permits)：当前线程释放 permits 个可用的许可证。</li><li>drainPermits()：当前线程获得剩余的所有可用许可证。</li><li>hasQueuedThreads()：判断当前 Semaphore 对象上是否存在正在等待许可证的线程。</li><li>getQueueLength()：获取当前 Semaphore 对象上是正在等待许可证的线程数量。</li></ul><p>Semaphore 提供了两个构造函数：</p><ul><li>Semaphore(int permits)：创建具有给定的许可数和非公平的公平设置的 Semaphore，Semaphore 默认选择非公平锁。</li><li>Semaphore(int permits, boolean fair)：创建具有给定的许可数和给定的公平设置的 Semaphore。Semaphore 有两种模式，公平模式和非公平模式。公平模式就是调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程，简单的说就是随机选取新线程来运行。</li></ul><h3 id="Coding-演示-2"><a href="#Coding-演示-2" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        final int clientCount = <span class="number">3</span>;</span><br><span class="line">        final int totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(()-&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.<span class="built_in">print</span>(semaphore.availablePermits() + <span class="string">" "</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">finally</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    semaphore.release();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Output</span></span></span><br><span class="line"><span class="function">// 2 1 2 2 2 2 2 1 2 2</span></span><br></pre></td></tr></table></figure><h2 id="Exchanger-交换器"><a href="#Exchanger-交换器" class="headerlink" title="Exchanger - 交换器"></a>Exchanger - 交换器</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Exchanger（交换器）是一个用于线程间协作的工具类，是 JDK 1.5 开始提供的一个用于两个工作线程之间交换数据的封装工具类。Exchanger 有点类似于 CyclicBarrier，我们知道 CyclicBarrier 是一个栅栏，到达栅栏的线程需要等待其它一定数量的线程到达后，才能通过栅栏，Exchanger 可以看成是一个双向栅栏。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p><p>可简单地将 Exchanger 对象理解为一个包含两个格子的容器，通过 exchanger 方法可以向两个格子中填充信息。当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。这两个线程通过 exchange 方法交换数据，如果第一个线程先执行 exchange 方法，它会一直等待第二个线程也执行 exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><p><img src="/media/15651639608949/3655810457-5b7034f01b70a_articlex.png" alt="3655810457-5b7034f01b70a_articlex"></p><h3 id="主要接口分析-3"><a href="#主要接口分析-3" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Exchanger 是最简单的也是最复杂的，简单在于 API 非常简单，就一个构造方法和两个 exchange() 方法，最复杂在于它的实现是最复杂的。</p><p>Exchanger 提供的关键方法如下：</p><ul><li>exchange(V x) ：当前线程跟另外一个线程交换数据 x，如果另外一个线程的数据准备好，那么当前线程会立刻返回，并获得另外一个线程的数据；否则当前线程会进入等待状态。</li><li>V exchange(V x, long timeout, TimeUnit unit)：当前线程跟另外一个线程交换数据 x，有一个指定的超时时间，如果在等待时间超时了，而且还没有收到对方的数据的话，则会抛出 TimeoutException 异常。</li></ul><p>可以看出，当一个线程到达 exchange 调用点时，如果其他线程此前已经调用了此方法，则其他线程会被调度唤醒并与之进行对象交换，然后各自返回；如果其他线程还没到达交换点，则当前线程会被挂起，直至其他线程到达才会完成交换并正常返回，或者当前线程被中断或超时返回。</p><h3 id="Coding-演示-3"><a href="#Coding-演示-3" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExchangerExample</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    private static final Integer WORK_COUNT = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    public static <span class="literal">void</span> main(String[] args) &#123;</span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; WORK_COUNT; i++) &#123;</span><br><span class="line">            executorService.execute<span class="function"><span class="params">(() -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                String beforeObj = Thread.currentThread().getName();</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    String afterObj = exchanger.exchange(Thread.currentThread().getName());</span></span></span><br><span class="line"><span class="function"><span class="params">                    System.out.println(String.format(<span class="string">"currentThread %s , before exchange %s , after exchange %s"</span>, Thread.currentThread().getName(), beforeObj, afterObj));</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">                    e.printStackTrace();</span></span></span><br><span class="line"><span class="function"><span class="params">                &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">            &#125;)</span>;</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">        <span class="title">executorService</span>.<span class="title">shutdown</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Output</span></span></span><br><span class="line"><span class="function">// <span class="title">currentThread</span> <span class="title">pool-1-thread-1</span> , <span class="title">before</span> <span class="title">exchange</span> <span class="title">pool-1-thread-1</span> , <span class="title">after</span> <span class="title">exchange</span> <span class="title">pool-1-thread-2</span> </span></span><br><span class="line"><span class="function">// <span class="title">currentThread</span> <span class="title">pool-1-thread-2</span> , <span class="title">before</span> <span class="title">exchange</span> <span class="title">pool-1-thread-2</span> , <span class="title">after</span> <span class="title">exchange</span> <span class="title">pool-1-thread-1</span></span></span><br></pre></td></tr></table></figure><h2 id="Phaser-多阶段栅栏"><a href="#Phaser-多阶段栅栏" class="headerlink" title="Phaser - 多阶段栅栏"></a>Phaser - 多阶段栅栏</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 和 CyclicBarrier 都是 JDK 1.5 引入的，而 Phaser 是 JDK 1.7 引入的。Phaser 的功能与 CountDownLatch 和 CyclicBarrier 有部分重叠，它几乎可以取代 CountDownLatch 和 CyclicBarrier， 其功能更灵活，更强大，支持动态调整需要控制的线程数。</p><p>CountDownLatch，闭锁，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待，它提供了 await()、countDown() 两个方法来进行操作；CyclicBarrier，循环栅栏，允许一组线程互相等待，直到到达某个公共屏障点，它提供的 await() 可以实现让所有参与者在临界点到来之前一直处于等待状态；Phaser，多阶段栅栏，它把多个线程协作执行的任务划分为多个阶段，编程时需要明确各个阶段的任务，每个阶段都可以有任意个参与者，线程都可以随时注册并参与到某个阶段，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）。</p><p>Phaser 顾名思义，与阶段相关。Phaser 比较适合这样一种场景，一种任务可以分为多个阶段，现希望多个线程去处理该批任务，对于每个阶段，多个线程可以并发进行，但是希望保证只有前面一个阶段的任务完成之后才能开始后面的任务。这种场景可以使用多个 CyclicBarrier 来实现，每个 CyclicBarrier 负责等待一个阶段的任务全部完成。但是使用 CyclicBarrier 的缺点在于，需要明确知道总共有多少个阶段，同时并行的任务数需要提前预定义好，且无法动态修改。而 Phaser 可同时解决这两个问题。</p><p><img src="/media/15651639608949/878416911-5b72af098eb7b.png" alt="878416911-5b72af098eb7b"></p><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><p>Phaser 主要接口如下：</p><h3 id="主要接口分析-4"><a href="#主要接口分析-4" class="headerlink" title="主要接口分析"></a>主要接口分析</h3><p>Phaser 提供的关键方法如下：</p><ul><li>arriveAndAwaitAdvance()：当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从 0 开始），同时其它线程的该方法也返回下一个阶段的序号。arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法。</li><li>arriveAndDeregister()：该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该 Phaser 是另外一个 Phaser 的子 Phaser，并且该操作导致当前 Phaser 的成员数为 0，则该操作也会将当前 Phaser 从其父 Phaser 中移除。</li><li>arrive()：该方法不作任何等待，直接返回下一阶段的序号。</li><li>awaitAdvance(int phase)：该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该 Phaser 已经被终止，则立即返回。该阶段数一般由 arrive() 方法或者 arriveAndDeregister() 方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前 Phaser 已经被终止）。</li><li>awaitAdvanceInterruptibly(int phase)：效果与 awaitAdvance(int phase) 相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出 InterruptedException。</li><li>awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)：效果与 awaitAdvanceInterruptibly(int phase) 相当，区别在于如果超时则抛出 TimeoutException。</li><li>bulkRegister(int parties)：注册多个 party。如果当前 phaser 已经被终止，则该方法无效，并返回负数。如果调用该方法时，onAdvance 方法正在执行，则该方法等待其执行完毕。如果该 Phaser 有父 Phaser 则指定的 party 数大于 0，且之前该 Phaser 的 party 数为 0，那么该 Phaser 会被注册到其父 Phaser 中。</li><li>forceTermination()：强制让该 Phaser 进入终止状态。已经注册的 party 数不受影响。如果该 Phaser 有子 Phaser，则其所有的子 Phaser 均进入终止状态。如果该 Phaser 已经处于终止状态，该方法调用不造成任何影响。</li></ul><h3 id="Coding-演示-4"><a href="#Coding-演示-4" class="headerlink" title="Coding 演示"></a>Coding 演示</h3><p>（1）通过 Phaser 实现 CyclicBarrier 控制多个线程的执行时机的功能</p><p>通过 Phaser 控制多个线程的执行时机：有时候我们希望所有线程到达指定点后再同时开始执行，我们可以利用 CyclicBarrier 来实现，这里给出使用 Phaser 的版本。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-10, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（2）通过 Phaser 实现 CyclicBarrier 执行 barrierAction</p><p>CyclicBarrier 支持 barrier action, Phaser 同样也支持。不同之处是 Phaser 的 barrier action 需要改写 onAdvance 方法来进行定制。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">boolean</span> onAdvance(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"%s call back is ready."</span>, Thread.currentThread().getName()));</span><br><span class="line">                <span class="built_in">return</span> super.onAdvance(phase, registeredParties);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// pool-1-thread-10 call back is ready.</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-10, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（3）通过 Phaser 实现 CountDownLatch 作为一个开关 / 入口功能</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class PhaserExample &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws IOException &#123;</span><br><span class="line">        final <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 注册主线程, 当外部条件满足时, 由主线程打开开关</span></span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.<span class="keyword">register</span>();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打开开关 [parties 共 11 个, 主线程从之后需要等待的成员中移除, 即 parties 还剩 10]</span></span><br><span class="line">        phaser.arriveAndDeregister();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"主线程打开了开关"</span>);</span><br><span class="line"></span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// 主线程打开了开关</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-6, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-7, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-8, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-9, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-4, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-5, Executing the task, currentPhase:1</span></span><br></pre></td></tr></table></figure><p>（4）通过 Phaser 实现分层</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> parties = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> phases = <span class="number">4</span>;</span><br><span class="line">        Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"====== Phase :"</span> + phase + <span class="string">"======"</span>);</span><br><span class="line">                <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onAdvance</span><span class="params">(phase, registeredParties)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parties; i++) &#123;</span><br><span class="line">            <span class="comment">// 注册各个参与者线程</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> phase = <span class="number">0</span>; phase &lt; phases; phase++) &#123;</span><br><span class="line">                    <span class="comment">// 等待其它参与者线程到达 [arriveAndAwaitAdvance 方法是不响应中断的，也就是说即使当前线程被中断，arriveAndAwaitAdvance 方法也不会返回或抛出异常，而是继续等待。如果希望能够响应中断，可以参考 awaitAdvanceInterruptibly 方法]</span></span><br><span class="line">                    <span class="keyword">int</span> j = phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    <span class="comment">// do something</span></span><br><span class="line">                    System.out.println(String.format(<span class="string">"currentThread:%s, Executing the task, currentPhase:%s"</span>, Thread.currentThread().getName(), j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// ====== Phase : 0 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:1</span></span><br><span class="line"><span class="comment">// ====== Phase : 1 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:2</span></span><br><span class="line"><span class="comment">// ====== Phase : 2 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:3</span></span><br><span class="line"><span class="comment">// ====== Phase : 3 ======</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-3, Executing the task, currentPhase:4</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-1, Executing the task, currentPhase:4</span></span><br><span class="line"><span class="comment">// currentThread:pool-1-thread-2, Executing the task, currentPhase:4</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://juejin.im/post/5d32f2c6f265da1b897b0b68#heading-3" target="_blank" rel="noopener">【并发编程】J.U.C 之 AQS 介绍、实现及其子类使用演示</a><br>[2]. <a href="http://www.jasongj.com/java/thread_communication/" target="_blank" rel="noopener">Java 进阶（四）线程间通信剖析</a><br>[3]. <a href="https://segmentfault.com/blog/ressmix_multithread" target="_blank" rel="noopener">透彻理解 Java 并发编程</a><br>[4]. <a href="http://cmsblogs.com/?cat=151" target="_blank" rel="noopener">死磕 Java 并发</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li><li><a href="bdbfedfb.html">Java 并发编程之美（七）：透彻理解 Java 并发编程</a></li><li><a href="c0108a7c.html">Java 并发编程之美（八）：循序渐进学习 Java 锁机制</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 并发编程是整个 Java 开发体系中最难以理解但也是最重要的知识点，也是各类开源分布式框架（如 ZooKeeper、Kafka、Spring Cloud、Netty 等）中各个并发组件实现的基础。J.U.C 并发包，即 java.util.concurrent 包，大大提高了并发性能，是 JDK 的核心工具包，是 JDK 1.5 之后，由 Doug Lea 实现并引入。而 AQS 被认为是 J.U.C 的核心。&lt;/p&gt;
&lt;p&gt;AQS 是一个抽象类，并没有对并发类提供了一个统一的接口定义，而是由子类根据自身的情况实现相应的方法，AQS 中一般包含两个方法 acquire(int)、release(int)，获取同步状态和释放同步状态，AQS 根据其状态是否独占分为独占模式和共享模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占模式：同一时刻最多只有一个线程获取同步状态，处于该模式下，其他线程试图获取该锁将无法获取成功。&lt;/li&gt;
&lt;li&gt;共享模式：同一时刻会有多个线程获取共享同步状态，处于该模式下，其他线程试图获取该锁可能会获取成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步器根据同步状态分为独占模式和共享模式，独占模式包括类：ReentrantLock、ReentrantReadWriteLock.WriteLock，共享模式包括：Semaphore、CountDownLatch、ReentrantReadWriteLock.ReadLock，本文将着重介绍一下 java.util.concurrent 包下一些辅助同步器类：CountDownLatch、CyclicBarrier、Semaphore、Exchanger、Phaser。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.maoning.vip/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Semaphore" scheme="https://blog.maoning.vip/tags/Semaphore/"/>
    
      <category term="CountDownLatch" scheme="https://blog.maoning.vip/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="https://blog.maoning.vip/tags/CyclicBarrier/"/>
    
      <category term="Phaser" scheme="https://blog.maoning.vip/tags/Phaser/"/>
    
      <category term="Exchanger" scheme="https://blog.maoning.vip/tags/Exchanger/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 进阶讲解（二）：快速生成测试数据以及 EXPLAIN 详解</title>
    <link href="https://blog.maoning.vip/archives/46faebc7.html"/>
    <id>https://blog.maoning.vip/archives/46faebc7.html</id>
    <published>2019-07-28T01:57:54.000Z</published>
    <updated>2019-08-30T06:54:44.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的 IO 成本。MySQL 在 300w 条记录左右性能开始逐渐下降，虽然官方文档说 500~800w 记录，所以大数据量建立索引是非常有必要的。MySQL 提供了 EXPLAIN，用于显示 SQL 执行的详细信息，可以进行索引的优化。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的查询语句或是表结构的性能瓶颈。 可以帮助选择更好的索引和写出更优化的查询语句。</p><p>本章首先介绍如何通过存储过程随机生成大量随机数据作为 EXPLIAN 的测试数据，然后通过例子详解 EXPLIAN 用法以及各字段含义，最后对 EXPLIAN 用途进行总结。</p><a id="more"></a><h2 id="EXPLAIN-概述"><a href="#EXPLAIN-概述" class="headerlink" title="EXPLAIN 概述"></a>EXPLAIN 概述</h2><p>EXPLAIN 命令是查看查询优化器如何决定执行查询的主要方法，使用 EXPLAIN，只需要在查询中的 SELECT 关键字之前增加 EXPLAIN 这个词即可，MYSQL 会在查询上设置一个标记，当执行查询时，这个标记会使其返回关于在执行计划中每一步的信息，而不是执行它，它会返回一行或多行信息，显示出执行计划中的每一部分和执行的次序，从而可以从分析结果中找到查询语句或是表结构的性能瓶颈。</p><p>通过 EXPLAIN，我们可以分析出以下结果：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h2 id="随机生成大量测试数据"><a href="#随机生成大量测试数据" class="headerlink" title="随机生成大量测试数据"></a>随机生成大量测试数据</h2><p>利用 MySQL 内存表插入速度快的特点，先利用函数和存储过程在内存表中生成数据，然后再从内存表插入普通表中。</p><p>（1）登录 MySQL</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 连接到远程主机上的 MySQL</span></span><br><span class="line">$ mysql -h [host] -u [username] -p [password]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看所有的数据库</span></span><br><span class="line">mysql&gt; <span class="keyword">show </span>databases<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 选择数据库</span></span><br><span class="line">mysql&gt; use [table_name]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看数据库中的表 </span></span><br><span class="line">mysql&gt; <span class="keyword">show </span>tables<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>（2）创建内存表</p><p>如果一条一条插入普通表的话，效率太低下，但内存表插入速度是很快的，可以先建立一张内存表，插入数据后，在导入到普通表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`big_data_user_memory`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_user_memory`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别 [0: 男性; 1: 女性]'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组ID'</span>,</span><br><span class="line">  <span class="string">`join_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'加入时间'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> <span class="keyword">HASH</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">MEMORY</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>（3）创建普通表</p><p>创建普通表，参数设置和内存表相同，否则从内存表往普通标导入数据会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`big_data_user`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户ID'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">tinyint</span>(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'年龄'</span>,</span><br><span class="line">  <span class="string">`gender`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'性别 [0: 男性; 1: 女性]'</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'手机'</span>,</span><br><span class="line">  <span class="string">`group_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组ID'</span>,</span><br><span class="line">  <span class="string">`join_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'加入时间'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`index_user_id`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>（4）创建存储函数</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 生成随机 UserId</span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=`root`@`localhost` <span class="function"><span class="keyword">FUNCTION</span> `<span class="title">generateCode</span>`<span class="params">( n int )</span> <span class="title">RETURNS</span> <span class="title">varchar</span><span class="params">(20)</span> <span class="title">CHARSET</span> <span class="title">utf8</span></span></span><br><span class="line"><span class="function">    <span class="title">DETERMINISTIC</span></span></span><br><span class="line"><span class="function"><span class="title">BEGIN</span></span></span><br><span class="line"><span class="function"><span class="title">DECLARE</span> <span class="title">chars_str</span> <span class="title">VARCHAR</span> <span class="params">( 100 )</span> <span class="title">DEFAULT</span> '<span class="title">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</span>';</span></span><br><span class="line">DECLARE return_str VARCHAR ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line">DECLARE i INT <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">WHILE</span></span><br><span class="line">i &lt; n <span class="keyword">DO</span></span><br><span class="line"><span class="keyword">SET</span> return_str = <span class="keyword">concat</span>(return_str, SUBSTRING(chars_str, FLOOR( <span class="number">1</span> + RAND() * <span class="number">62</span> ), <span class="number">1</span> ));</span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">RETURN return_str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 生成随机中文名</span></span><br><span class="line">CREATE DEFINER=`root`@`localhost` <span class="keyword">FUNCTION</span> `generateUserName`() RETURNS varchar(<span class="number">255</span>) CHARSET utf8</span><br><span class="line">    DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line"><span class="meta">#Routine body goes here...</span></span><br><span class="line"><span class="keyword">DECLARE</span> last_name varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'赵钱孙李周郑王冯陈楮卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闽席季麻强贾路娄危江童颜郭梅盛林刁锺徐丘骆高夏蔡田樊胡凌霍虞万支柯昝管卢莫经裘缪干解应宗丁宣贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁';</span></span><br><span class="line"><span class="keyword">DECLARE</span> first_name varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'嘉懿煜城懿轩烨伟苑博伟泽熠彤鸿煊博涛烨霖烨华煜祺智宸正豪昊然明杰诚立轩立辉峻熙弘文熠彤鸿煊烨霖哲瀚鑫鹏致远俊驰雨泽烨磊晟睿天佑文昊修洁黎昕远航旭尧鸿涛伟祺轩越泽浩宇瑾瑜皓轩擎苍擎宇志泽睿渊楷瑞轩弘文哲瀚雨泽鑫磊梦琪忆之桃慕青问兰尔岚元香初夏沛菡傲珊曼文乐菱痴珊恨玉惜文香寒新柔语蓉海安夜蓉涵柏水桃醉蓝春儿语琴从彤傲晴语兰又菱碧彤元霜怜梦紫寒妙彤曼易南莲紫翠雨寒易烟如萱若南寻真晓亦向珊慕灵以蕊寻雁映易雪柳孤岚笑霜海云凝天沛珊寒云冰旋宛儿绿真盼儿晓霜碧凡夏菡曼香若烟半梦雅绿冰蓝灵槐平安书翠翠风香巧代云梦曼幼翠友巧听寒梦柏醉易访旋亦玉凌萱访卉怀亦笑蓝春翠靖柏夜蕾冰夏梦松书雪乐枫念薇靖雁寻春恨山从寒忆香觅波静曼凡旋以亦念露芷蕾千兰新波代真新蕾雁玉冷卉紫山千琴恨天傲芙盼山怀蝶冰兰山柏翠萱乐丹翠柔谷山之瑶冰露尔珍谷雪乐萱涵菡海莲傲蕾青槐冬儿易梦惜雪宛海之柔夏青亦瑶妙菡春竹修杰伟诚建辉晋鹏天磊绍辉泽洋明轩健柏煊昊强伟宸博超君浩子骞明辉鹏涛炎彬鹤轩越彬风华靖琪明诚高格光华国源宇晗昱涵润翰飞翰海昊乾浩博和安弘博鸿朗华奥华灿嘉慕坚秉建明金鑫锦程瑾瑜鹏经赋景同靖琪君昊俊明季同开济凯安康成乐语力勤良哲理群茂彦敏博明达朋义彭泽鹏举濮存溥心璞瑜浦泽奇邃祥荣轩';</span></span><br><span class="line"><span class="keyword">DECLARE</span> return_str varchar(<span class="number">2056</span>) <span class="keyword">DEFAULT</span> <span class="comment">'';</span></span><br><span class="line"><span class="meta"># 一个中文的长度是 3 位</span></span><br><span class="line"><span class="keyword">DECLARE</span> first_name_length int <span class="keyword">DEFAULT</span> LENGTH(first_name) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> last_name_length int <span class="keyword">DEFAULT</span> LENGTH(last_name) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(last_name, FLOOR(<span class="number">1</span> + RAND() * last_name_length), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(first_name, FLOOR(<span class="number">1</span> + RAND() * first_name_length), <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">IF</span> RAND() &gt; <span class="number">0.400</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">SET</span> return_str = CONCAT(return_str, SUBSTRING(first_name, FLOOR(<span class="number">1</span> + RAND() * first_name_length), <span class="number">1</span>));</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> return_str;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 生成随机手机号</span><br><span class="line">CREATE DEFINER=`root`@`localhost` FUNCTION `generatePhone`() RETURNS char(<span class="number">11</span>) CHARSET utf8</span><br><span class="line">    DETERMINISTIC</span><br><span class="line">BEGIN</span><br><span class="line">#Routine body goes here...</span><br><span class="line">DECLARE head VARCHAR(<span class="number">256</span>) DEFAULT '<span class="number">133</span>、<span class="number">153</span>、<span class="number">180</span>、<span class="number">181</span>、<span class="number">189</span>、<span class="number">177</span>、<span class="number">173</span>、<span class="number">149</span>、<span class="number">130</span>、<span class="number">131</span>、<span class="number">132</span>、<span class="number">155</span>、<span class="number">156</span>、<span class="number">145</span>、<span class="number">185</span>、<span class="number">186</span>、<span class="number">176</span>、<span class="number">175</span>、<span class="number">134</span>、<span class="number">135</span>、<span class="number">136</span>、<span class="number">137</span>、<span class="number">138</span>、<span class="number">139</span>、<span class="number">150</span>、<span class="number">151</span>、<span class="number">152</span>、<span class="number">157</span>、<span class="number">158</span>、<span class="number">159</span>、<span class="number">182</span>、<span class="number">183</span>、<span class="number">184</span>、<span class="number">187</span>、<span class="number">188</span>、<span class="number">147</span>、<span class="number">178</span>';</span><br><span class="line">DECLARE content CHAR(<span class="number">10</span>) DEFAULT '<span class="number">0123456789</span>';</span><br><span class="line">DECLARE phone CHAR(<span class="number">11</span>) DEFAULT substring( head, <span class="number">1</span> + ( FLOOR(( RAND() * <span class="number">37</span> ))* <span class="number">4</span> ), <span class="number">3</span> );</span><br><span class="line">DECLARE i int DEFAULT <span class="number">1</span>;</span><br><span class="line">  DECLARE len int DEFAULT LENGTH(content);</span><br><span class="line"></span><br><span class="line">WHILE i &lt;= <span class="number">8</span> DO</span><br><span class="line">SET i = i + <span class="number">1</span>;</span><br><span class="line">SET phone = CONCAT(phone, substring( content, floor( <span class="number">1</span> + RAND() * len ), <span class="number">1</span> ));</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">RETURN phone;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成随机'yyyy-MM-dd'至'yyyy-MM-dd'时间</span></span><br><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`root`</span>@<span class="string">`localhost`</span> <span class="keyword">FUNCTION</span> <span class="string">`generateDateTime`</span>(begin_time <span class="built_in">char</span>(<span class="number">10</span>), end_time <span class="built_in">char</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> datetime</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">#Routine body goes here...</span></span><br><span class="line"><span class="keyword">DECLARE</span> date_time <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> local_date <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> local_time <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> local_date = <span class="built_in">DATE</span>(FROM_UNIXTIME( <span class="keyword">UNIX_TIMESTAMP</span>( begin_time ) + <span class="keyword">FLOOR</span>( <span class="keyword">RAND</span>() * ( <span class="keyword">UNIX_TIMESTAMP</span>( end_time ) - <span class="keyword">UNIX_TIMESTAMP</span>( begin_time ) + <span class="number">1</span> ) )));</span><br><span class="line"><span class="keyword">SET</span> local_time = <span class="keyword">CONCAT</span>(local_time, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">24</span>), <span class="string">':'</span>, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">60</span>), <span class="string">':'</span>, <span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>() * <span class="number">60</span>));</span><br><span class="line"><span class="keyword">SET</span> date_time = <span class="keyword">CONCAT</span>(local_date, <span class="string">' '</span>, local_time);</span><br><span class="line"></span><br><span class="line">RETURN date_time;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>（5）创建存储过程</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="symbol">`root`</span>@<span class="symbol">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="symbol">`generateBigDataUser`</span>(<span class="keyword">IN</span> num INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">#Routine body goes here...</span><br><span class="line"></span><br><span class="line">#申明变量i,默认为<span class="number">1</span></span><br><span class="line"><span class="keyword">DECLARE</span> i INT DEFAULT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#当i小于传入的参数时执行循环插入</span><br><span class="line">WHILE  i &lt;= num  DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`big_data_user_memory`</span>(<span class="symbol">`user_id`</span>, <span class="symbol">`user_name`</span>, <span class="symbol">`age`</span>, <span class="symbol">`gender`</span>, <span class="symbol">`phone`</span>, <span class="symbol">`group_id`</span>, <span class="symbol">`join_time`</span>, <span class="symbol">`gmt_create`</span>, <span class="symbol">`gmt_modified`</span>) <span class="keyword">VALUES</span> (generateCode(<span class="number">20</span>), generateUserName(), <span class="number">18</span> + <span class="built_in">FLOOR</span>(RAND() * <span class="number">50</span>), <span class="built_in">FLOOR</span>(RAND() * <span class="number">2</span>), generatePhone(), <span class="built_in">FLOOR</span>(RAND() * <span class="number">100</span>), generateDateTime(<span class="string">'1990-01-01'</span>, <span class="string">'2019-08-15'</span>), DATE(NOW() - INTERVAL (<span class="built_in">FLOOR</span>(rand() * <span class="number">1000</span> )) DAY), NOW());</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>（6）调用存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> generateBigDataUser(<span class="number">1000000</span>);</span><br></pre></td></tr></table></figure><p>在调用存储过程的过程中内存表大小的问题抛出 “The table ‘big_data_memory’ is full”，这是就需要我们修改一下 MySQL 的配置信息。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 查看 tmp_table_size 大小, tmp_table_size: 控制内存临时表的最大值, 超过限值后就往硬盘写, 写的位置由变量 tmpdir 决定 </span><br><span class="line">mysql&gt; SHOW <span class="keyword">variables</span> like <span class="comment">'%tmp_table_size%'</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 查看 max_heap_table_size 大小, max_heap_table_size: 用户可以创建的内存表 (memory <span class="keyword">table</span>) 的大小. 这个值用来计算内存表的最大行数值</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">'%max_heap_table_size%'</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 修改 tmp_table_size 大小</span><br><span class="line">mysql&gt; <span class="keyword">SET</span> SESSION <span class="comment">tmp_table_size = 1024 * 1024 * 1024</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 修改 max_heap_table_size 大小</span><br><span class="line">mysql&gt; <span class="keyword">SET</span> SESSION <span class="comment">max_heap_table_size = 1024 * 1024 * 1024</span>;</span><br></pre></td></tr></table></figure><p>（7）将内存表中的数据导入普通表</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> big_data_user <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user_memory;</span><br></pre></td></tr></table></figure><p>以上，我们通过存储过程快速产生百万条随机测试数据的工作就大功告成了。接下来，我们将用我们产生的数据为基础详解 EXPLIAN 用法以及各字段含义。</p><p>（8）准备关联查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`big_data_group`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`group_code`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分组编码'</span>,</span><br><span class="line">  <span class="string">`number_of_people`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'人数'</span>,</span><br><span class="line">  <span class="string">`gmt_create`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`gmt_modified`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="symbol">`root`</span>@<span class="symbol">`localhost`</span> <span class="keyword">PROCEDURE</span> <span class="symbol">`generateBigDataGroup`</span>(<span class="keyword">IN</span> num INT)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">#Routine body goes here...</span><br><span class="line"><span class="keyword">DECLARE</span> i INT DEFAULT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#当i小于传入的参数时执行循环插入</span><br><span class="line">WHILE  i &lt;= num  DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="symbol">`big_data_group`</span>(<span class="symbol">`group_code`</span>, <span class="symbol">`number_of_people`</span>, <span class="symbol">`gmt_create`</span>, <span class="symbol">`gmt_modified`</span>) <span class="keyword">VALUES</span> (generateCode(<span class="number">15</span>), <span class="built_in">FLOOR</span>(RAND() * <span class="number">10000</span>), DATE(NOW() - INTERVAL (<span class="built_in">FLOOR</span>(rand() * <span class="number">1000</span> )) DAY), NOW());</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">CALL</span> generateBigDataGroup(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="EXPLIAN-用法以及各字段含义"><a href="#EXPLIAN-用法以及各字段含义" class="headerlink" title="EXPLIAN 用法以及各字段含义"></a>EXPLIAN 用法以及各字段含义</h2><p>EXPLIAN 模拟优化器执行 SQL 语句，在 5.6 以及以后的版本中，除过 SELECT，其他比如 INSERT，UPDATE 和 DELETE 均可以使用 EXPLIAN 查看执行计划，从而知道 MySQL 是如何处理 SQL 语句，分析查询语句或者表结构的性能瓶颈。 </p><p>本次 EXPLIAN 以根据手机号码过滤测试数据中手机号码重复的、保留 ID 最小数据的滤重 SQL 语句为例子。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">DELETE <span class="keyword">FROM</span> big_data_user WHERE phone <span class="keyword">IN</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> big_data_user bdu1<span class="built_in"> GROUP </span>BY bdu1.phone HAVING count(*)&gt; 1) p) <span class="keyword">AND</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">SELECT id <span class="keyword">FROM</span> (</span><br><span class="line">SELECT min(bdu2.id) <span class="keyword">FROM</span> big_data_user bdu2<span class="built_in"> GROUP </span>BY bdu2.phone HAVING count(*)&gt; 1) b);</span><br></pre></td></tr></table></figure><p><img src="/media/15657628227946/20190815153622.png" alt="20190815153622"></p><p>EXPLIAN 出来的信息有 12 列，分别是 id、select_type、table、partitions、type、possible_keys、key、key_len、ref、rows、filtered、Extra</p><h3 id="id-查询标识"><a href="#id-查询标识" class="headerlink" title="id - 查询标识"></a>id - 查询标识</h3><p>查询标识，表示 SQL 语句中执行 SELECT 子句或者是操作的顺序。</p><ol><li>id 相同时执行顺序从上至下。</li><li>id 不同时，如果是子查询，id 的序号会递增，序号越大的越先执行。</li><li>id 相同，不同都存在时，id 相同的可以认为是一组查询按从上至下的顺序执行，id 值越大越优先执行。</li><li>id 为 NULL，如果行引用其他行的联合结果，则值可以为 NULL。在这种情况下，表列显示像 &lt;unionM,N&gt; 这样的值，以指示该行引用 id 值为 M 和 N 的行的并。</li></ol><h3 id="select-type-查询类型"><a href="#select-type-查询类型" class="headerlink" title="select_type - 查询类型"></a>select_type - 查询类型</h3><p>查询类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询。</p><ul><li>SIMPLE：简单的 select 查询，查询中不包含子查询或者 UNION</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为 PRIMARY</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> *, (<span class="keyword">SELECT</span> group_code <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">group_id</span>) <span class="keyword">AS</span> group_code <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>SUBQUERY：在 SELECT 或 WHERE 列表中包含了子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">group_id</span> = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> group_code=<span class="string">'cqlhc1nBKNAlOTQ'</span>);</span><br></pre></td></tr></table></figure><ul><li>DEPENDENT SUBQUERY：在 SELECT 或 WHERE 列表中包含了子查询，该子查询依赖外层查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> *, (<span class="keyword">SELECT</span> group_code <span class="keyword">FROM</span> big_data_group <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="keyword">group_id</span>) <span class="keyword">AS</span> group_code <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>DERIVED：在 FROM 列表中包含的子查询被标记为 DERIVED（衍生），MySQL 会递归执行这些子查询，把结果放在临时表中</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">LIMIT</span> <span class="number">5</span>) <span class="keyword">AS</span> bdu</span><br></pre></td></tr></table></figure><ul><li>UNION：若第二个 SELECT 出现在 UNION 之后，则被标记为 UNION；若 UNION 包含在 FROM 子句的子查询中，外层 SELECT 将被标记为DERIVED</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id = <span class="string">'Jt2BHyxQqsPBoZAO9adp'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> phone = <span class="string">'13982711661'</span>;</span><br></pre></td></tr></table></figure><ul><li>UNION RESULT：从 UNION 表获取结果的 SELECT</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id = <span class="string">'Jt2BHyxQqsPBoZAO9adp'</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> phone = <span class="string">'13982711661'</span>;</span><br></pre></td></tr></table></figure><h3 id="table-查询涉及表"><a href="#table-查询涉及表" class="headerlink" title="table - 查询涉及表"></a>table - 查询涉及表</h3><p>查询涉及表，显示这一行的数据是关于哪张表的。这也可以是下列值之一：</p><ul><li>&lt;unionM,N&gt;：输出行引用了 id 值为 M 和 N 的行的 UNION 结果。 </li><li>&lt; derivedN &gt;：该行引用了一个 id 值为 n 的行的派生表结果。 </li><li>&lt; subqueryN &gt;：输出行引用了 id 值为 N 的行的物化子查询的结果。</li></ul><h3 id="partitions-匹配到的分区信息"><a href="#partitions-匹配到的分区信息" class="headerlink" title="partitions - 匹配到的分区信息"></a>partitions - 匹配到的分区信息</h3><p>匹配到的分区信息，由查询匹配记录的分区。对于非分区表，值为 NULL。</p><h3 id="type-连接类型"><a href="#type-连接类型" class="headerlink" title="type - 连接类型"></a>type - 连接类型</h3><p>连接类型，对表访问方式，表示 MySQL 在表中找到所需行的方式，又称 “访问类型”。常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好）。SQL 性能优化的目标：至少要达到  range 级别，要求是 ref 级别，如果可以是 consts<br>最好。</p><ul><li>system: 表中只有一条数据， 这个类型是特殊的 const 类型。</li><li>const: 针对主键或唯一索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>eq_ref: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，查询效率较高。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user bdu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> big_data_group bdg <span class="keyword">ON</span> bdu.group_id = bdg.id;</span><br></pre></td></tr></table></figure><ul><li>ref: 此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了最左前缀规则索引的查询。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> user_id=<span class="string">'Jt2BHyxQqsPBoZAO9adp'</span>;</span><br></pre></td></tr></table></figure><ul><li>range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ul><li>index: 表示全索引扫描 (full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引，而不扫描数据。index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。例如下面这个例子：EXPLAIN SELECT id FROM big_data_user;</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> big_data_user;</span><br></pre></td></tr></table></figure><ul><li>ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。 如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。</li></ul><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user;</span><br></pre></td></tr></table></figure><h3 id="possible-keys-可能选择的索引"><a href="#possible-keys-可能选择的索引" class="headerlink" title="possible_keys - 可能选择的索引"></a>possible_keys - 可能选择的索引</h3><p>可能选择的索引，它表示 MySQL 在查询时，可能使用到的索引。 注意，即使有些索引在 possible_keys 中出现，但是并不表示此索引会真正地被 MySQL 使用到。 MySQL 在查询时具体使用了哪些索引，由 key 字段决定。</p><h3 id="key-实际使用的索引"><a href="#key-实际使用的索引" class="headerlink" title="key - 实际使用的索引"></a>key - 实际使用的索引</h3><p>实际使用的索引，实际使用的索引，如果为null，则没有使用索引，因此会出现possible_keys列有可能被用到的索引，但是key列为null，表示实际没用索引。</p><h3 id="key-len-实际使用的索引的长度"><a href="#key-len-实际使用的索引的长度" class="headerlink" title="key_len - 实际使用的索引的长度"></a>key_len - 实际使用的索引的长度</h3><p>实际使用的索引的长度，表示索引中使用的字节数，而通过该列计算查询中使用的索引长度，在不损失精确性的情况下，长度越短越好，key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得而不是通过表内检索出的。</p><h3 id="ref-和索引进行比较的列"><a href="#ref-和索引进行比较的列" class="headerlink" title="ref - 和索引进行比较的列"></a>ref - 和索引进行比较的列</h3><p>和索引进行比较的列，表示哪些列或常量与键列中命名的索引相比较，以从表中选择行。 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> big_data_user bdu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> big_data_group bdg <span class="keyword">ON</span> bdu.group_id = bdg.id;</span><br></pre></td></tr></table></figure><h3 id="rows-需要被检索的大致行数"><a href="#rows-需要被检索的大致行数" class="headerlink" title="rows - 需要被检索的大致行数"></a>rows - 需要被检索的大致行数</h3><p>需要被检索的大致行数，根据表统计信息及索引选用情况，大只估算出找到所需的记录所需要读取的行数。</p><h3 id="filtered-按表条件过滤的行百分比"><a href="#filtered-按表条件过滤的行百分比" class="headerlink" title="filtered - 按表条件过滤的行百分比"></a>filtered - 按表条件过滤的行百分比</h3><p>按表条件过滤的行百分比，该列表示将被表条件过滤的表行的估计百分比。 最大值为100，这意味着没有发生行过滤。值从100下降表明过滤量增加。</p><h3 id="Extra-额外信息"><a href="#Extra-额外信息" class="headerlink" title="Extra - 额外信息"></a>Extra - 额外信息</h3><p>额外信息，不适合在其他字段中显示，但是十分重要的额外信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN</span><br><span class="line">DELETE <span class="keyword">FROM</span> big_data_user WHERE phone <span class="keyword">IN</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> (</span><br><span class="line">SELECT phone <span class="keyword">FROM</span> big_data_user bdu1<span class="built_in"> GROUP </span>BY bdu1.phone HAVING count(*)&gt; 1) p) <span class="keyword">AND</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">SELECT id <span class="keyword">FROM</span> (</span><br><span class="line">SELECT min(bdu2.id) <span class="keyword">FROM</span> big_data_user bdu2<span class="built_in"> GROUP </span>BY bdu2.phone HAVING count(*)&gt; 1) b);</span><br></pre></td></tr></table></figure><ul><li>Using filesort : 表示 MySQL 需额外的排序操作，不能通过索引顺序达到排序效果，MySQL Query Optimizer 不得不选择相应的排序算法来实现。一般有 using filesort 都建议优化去掉，因为这样的查询 cpu 资源消耗大。</li><li>Using temporary :  使用了临时表保存中间结果，MySQL 在对查询结果排序时使用了临时表。常见于 order by， group by， join 操作，查询效率不高，建议优化。</li><li>Using index : 发生了索引覆盖 ， 查询时在索引树上取到了需要查询的数据，不需要再进行回行操作。</li><li>Using join buffer : 使用了连接缓存，Block Nested Loop，连接算法是块嵌套循环连接；Batched Key Access，连接算法是批量索引连接。</li><li>Using where : 表示 MySQL 服务器从存储引擎收到查询数据，再进行 “后过滤”（Post-filter）。所谓 “后过滤”，就是先读取整行数据，再检查此行是否符合 where 句的条件，符合就留下，不符合便丢弃。因为检查是在读取行后才进行的，所以称为 “后过滤”。注意：Extra 列出现 Using where 表示 MySQL 服务器将存储引擎返回服务层以后再应用 WHERE 条件过滤。</li><li>Impossible WHERE : where 子句的值总是 false，不能用来获取任何数据。</li><li>distinct : 查找 distinct 值，当 MySQL 找到了第一条匹配的结果时，将停止该值的查询，转为后面其他值查询。</li></ul><h2 id="SQL-执行顺序"><a href="#SQL-执行顺序" class="headerlink" title="SQL 执行顺序"></a>SQL 执行顺序</h2><p>想要优化 SQL，必须清楚知道 SQL 的执行顺序，这样再配合 explain 才能事半功倍！</p><p>完整 SQL 语句：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> </span><br><span class="line">    &lt;select_list&gt;</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">join</span> &lt;right_table&gt; <span class="keyword">on</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">    &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">limit</span> &lt;<span class="keyword">limit</span> <span class="keyword">number</span>&gt;</span><br></pre></td></tr></table></figure><p>SQL 执行顺序：</p><p>1、from &lt;left_table&gt;&lt;join_type&gt;<br>2、on &lt;join_condition&gt;<br>3、&lt;join_type&gt; join &lt;right_table&gt;<br>4、where &lt;where_condition&gt;<br>5、group by &lt;group_by_list&gt;<br>6、having &lt;having_condition&gt;<br>7、select<br>8、distinct &lt;select_list&gt;<br>9、order by &lt;order_by_condition&gt;<br>10、limit &lt;limit_number&gt;</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用 EXPLAIN 解析 SQL 执行计划时，如果有下面几种情况，就需要特别关注下了：</p><ul><li>首先看下 type 这列的结果，如果有类型是 ALL 时，表示预计会进行全表扫描（full table scan）。通常全表扫描的代价是比较大的，建议创建适当的索引，通过索引检索避免全表扫描。</li><li>再来看下 Extra 列的结果，如果有出现 Using temporary 或者 Using filesort 则要多加关注：Using temporary，表示需要创建临时表以满足需求，通常是因为 GROUP BY 的列没有索引，或者 GROUP BY 和 ORDER BY 的列不一样，也需要创建临时表，建议添加适当的索引；Using filesort，表示无法利用索引完成排序，也有可能是因为多表连接时，排序字段不是驱动表中的字段，因此也没办法利用索引完成排序，建议添加适当的索引；Using where，通常是因为全表扫描或全索引扫描时（type 列显示为 ALL 或 index），又加上了 WHERE 条件，建议添加适当的索引；其他状态例如：Using index、Using index condition、Using index for group-by 则都还好，不用紧张。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://cmsblogs.com/?p=2818" target="_blank" rel="noopener">MySQL 的索引是什么？怎么优化？</a><br>[2]. <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">EXPLAIN Output Format</a><br>[3]. <a href="https://blog.csdn.net/qq_16946803/article/details/81870174" target="_blank" rel="noopener">MySQL 快速生成 100W 条测试数据</a><br>[4]. <a href="https://www.cnblogs.com/wangfengming/articles/8275448.html" target="_blank" rel="noopener">MySQL EXPLAIN 详解</a><br>[5]. <a href="https://blog.csdn.net/wuseyukui/article/details/71512793" target="_blank" rel="noopener">MySQL 高级 之 explain 执行计划详解</a></p><hr><h2 id="MySQL-进阶讲解系列"><a href="#MySQL-进阶讲解系列" class="headerlink" title="MySQL 进阶讲解系列"></a>MySQL 进阶讲解系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="46faebc7.html">MySQL 进阶讲解（二）：快速生成测试数据以及 EXPLAIN 详解</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;索引类似大学图书馆建书目索引，可以提高数据检索的效率，降低数据库的 IO 成本。MySQL 在 300w 条记录左右性能开始逐渐下降，虽然官方文档说 500~800w 记录，所以大数据量建立索引是非常有必要的。MySQL 提供了 EXPLAIN，用于显示 SQL 执行的详细信息，可以进行索引的优化。使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的，分析你的查询语句或是表结构的性能瓶颈。 可以帮助选择更好的索引和写出更优化的查询语句。&lt;/p&gt;
&lt;p&gt;本章首先介绍如何通过存储过程随机生成大量随机数据作为 EXPLIAN 的测试数据，然后通过例子详解 EXPLIAN 用法以及各字段含义，最后对 EXPLIAN 用途进行总结。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.maoning.vip/categories/MySQL/"/>
    
    
      <category term="EXPLAIN" scheme="https://blog.maoning.vip/tags/EXPLAIN/"/>
    
      <category term="索引" scheme="https://blog.maoning.vip/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</title>
    <link href="https://blog.maoning.vip/archives/14348371.html"/>
    <id>https://blog.maoning.vip/archives/14348371.html</id>
    <published>2019-07-13T06:39:44.000Z</published>
    <updated>2019-11-20T11:09:41.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过 Redis 深度探险系列的学习相信大家对 Redis 的数据结构、对象、持久化机制、过期键删除策略等知识有了大致的了解，本篇博文主要讲述 Redis 的安装步骤，然后介绍一下 Redis 配置说明，最后对 Redis 集群搭建进行详细的讲解。</p><a id="more"></a><h2 id="单机环境搭建"><a href="#单机环境搭建" class="headerlink" title="单机环境搭建"></a>单机环境搭建</h2><h3 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h3><p>Mac 中使用 brew 安装 Redis 的方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>redis</span><br></pre></td></tr></table></figure><h3 id="Linux-安装-Redis"><a href="#Linux-安装-Redis" class="headerlink" title="Linux 安装 Redis"></a>Linux 安装 Redis</h3><p><strong>Ubuntu 中使用 apt-get 安装 Redis 的方法</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install redis-server</span><br></pre></td></tr></table></figure><p><strong>CentOS7 中使用 yum 安装 Redis 的方法</strong></p><ol><li>检查 Redis 版本</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过 yum <span class="meta">info</span> redis 可知 Centos7 中 Redis 源的版本为<span class="number">3</span>.<span class="number">2</span>.<span class="number">12</span></span><br><span class="line">$ yum <span class="meta">info</span> redis</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 Redis 数据库</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum <span class="keyword">install</span> -y redis</span><br></pre></td></tr></table></figure><ol start="3"><li>启动 Redis 数据库</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="literal">start</span> redis</span><br></pre></td></tr></table></figure><ol start="4"><li>查看 Redis 运行状况</li></ol><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>systemctl status redis</span><br></pre></td></tr></table></figure><ol start="5"><li>检测 Redis 服务器是否开启</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> -ef | <span class="keyword">grep</span> redis</span><br></pre></td></tr></table></figure><ol start="6"><li>通过上述方法安装的 Redis 版本较低，如果想安装最新的 Redis 请执行如下命令</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装 Remi 的软件源</span></span><br><span class="line"><span class="symbol">$</span> yum install -y http:<span class="comment">//rpms.famillecollet.com/enterprise/remi-release-7.rpm</span></span><br><span class="line"><span class="comment">// 更换 yum 源，通过 remi 源安装 Redis</span></span><br><span class="line"><span class="symbol">$</span> yum --enablerepo=remi install -y redis</span><br></pre></td></tr></table></figure><h2 id="Redis-简单配置以及配置说明"><a href="#Redis-简单配置以及配置说明" class="headerlink" title="Redis 简单配置以及配置说明"></a>Redis 简单配置以及配置说明</h2><h3 id="Rdis设置为开启启动"><a href="#Rdis设置为开启启动" class="headerlink" title="Rdis设置为开启启动"></a>Rdis设置为开启启动</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="builtin-name">enable</span> redis.service</span><br></pre></td></tr></table></figure><h3 id="开启远程连接，Redis-默认只能-localhost-访问"><a href="#开启远程连接，Redis-默认只能-localhost-访问" class="headerlink" title="开启远程连接，Redis 默认只能 localhost 访问"></a>开启远程连接，Redis 默认只能 localhost 访问</h3><p>修改 /etc/redis.conf 配置文件，执行 systemctl restart redis 重启 Redis 即生效。</p><ol><li>输入命令 vim /etc/redis.conf 进入编辑模式</li><li>bind 127.0.0.1 修改为 bind 0.0.0.0</li><li>protected-mode yes 修改为 protected-mode no（保护模式，是否只允许本地访问）</li></ol><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>修改 /etc/redis.conf 配置文件，在 requirepass foobared 前面去掉注释，将 foobared 改为自己的密码，我在这里改为 requirepass foobared，执行 systemctl restart redis 重启 Redis 即生效。</p><h3 id="在线变更配置"><a href="#在线变更配置" class="headerlink" title="在线变更配置"></a>在线变更配置</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 通过 redis-<span class="keyword">cli</span> 连接 redis 客户端，使用 AUTH 进行认证</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; auth foobared</span><br><span class="line">// 获取当前配置</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG GET *</span><br><span class="line">// 修改密码为 root</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG SET requirepass root</span><br><span class="line">// 将修改后的配置写入配置文件</span><br><span class="line"><span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">6379</span>&gt; CONFIG REWRITE</span><br></pre></td></tr></table></figure><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><p> <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf </a> 以及Redis 配置文件 redis.conf 中文详解：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Redis 配置文件例子.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 注意: 为了能读取到配置文件, Redis 服务必须以配置文件的路径作为第一个参数启动:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># ./redis-server /path/to/redis.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 单位说明: 当需要指定内存大小时, 可能会使用到不同的单位, 如 1k、5GB、4M 等, 这里给出其单位含义:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1k =&gt; 1000 bytes</span></span><br><span class="line"><span class="meta"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="meta"># 1m =&gt; 1000000 bytes</span></span><br><span class="line"><span class="meta"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="meta"># 1g =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="meta"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 单位是大小写不敏感的 所以 1GB 1Gb 1gB 是一样的.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果你拥有一个标准的配置模板, 并且希望在该模板之上做一些个性化的修改, 你可以使用 include 指令来引入其他的配置文件.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 注意:"include" 不会被 admin 或者 Redis Sentinel "CONFIG REWRITE" 命令覆盖.</span></span><br><span class="line"><span class="meta"># 由于 redis 以最终的配置作为实际配置, 因此我们希望你将 include 命令放置在配置文件的最前面以防配置被覆盖.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果你打算使用另外的 conf 文件来覆盖当前文件的配置, 那么最好将 include 指令放置到该文件的末尾. </span></span><br><span class="line"><span class="meta"># 即最后生效原则, 最后被解析的配置将作为最后的配置.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># include /path/to/local.conf</span></span><br><span class="line"><span class="meta"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## MODULES #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动时加载模块. 如果服务器无法加载模块, 它将中止. 可以使用多个 loadmodule 指令.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># loadmodule /path/to/my_module.so</span></span><br><span class="line"><span class="meta"># loadmodule /path/to/other_module.so</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## NETWORK #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下 redis 会在所有的可用网络接口中进行监听, 如果你想让 redis 在指定的网络接口中</span></span><br><span class="line"><span class="meta"># 监听, 那么可以使用 bind 命令来指定 redis 的监听接口.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 例如:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="meta"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># ~~~ 警告 ~~~ 如果允许所有的网络接口访问 Redis, 这样做是很危险的, 如果你只是需要本机访问 </span></span><br><span class="line"><span class="meta"># 可以指定特定的 127.0.0.1, 如果需要外网访问, 请配置防火墙策略.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="meta"># JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="meta"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否开启保护模式, 默认开启. 要是配置里没有指定 bind 和密码.</span></span><br><span class="line"><span class="meta"># 开启该参数后, redis 只会本地进行访问, 拒绝外部访问.</span></span><br><span class="line"><span class="meta"># 要是开启了密码和 bind, 可以开启. 否则最好关闭, 设置为 no.</span></span><br><span class="line"><span class="keyword">protected</span>-mode yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在指定的端口上进行监听, 默认是 6379.</span></span><br><span class="line"><span class="meta"># 如果端口设置为 0, 那么 redis 就不会在 TCP socket 上进行监听.</span></span><br><span class="line">port <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># TCP listen() backlog.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在一个并发量高的环境中, 你需要指定一个比较大的 backlog 值来避免慢连接的情况.</span></span><br><span class="line"><span class="meta"># 注意, linux 内核会默认 使用 / proc/sys/net/core/somaxconn 的值来削减 backlog 的实际值,</span></span><br><span class="line"><span class="meta"># 因此你需要确保提升 somaxconn 和 tcp_max_syn_backlog 这两个值来确保此处的 backlog 生效.</span></span><br><span class="line">tcp-backlog <span class="number">511</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Unix socket.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 指定 unix sock 的路径来进行连接监听, 默认是不指定, 因此 redis 不会在 unix socket 上进行监听.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># unixsocket /tmp/redis.sock</span></span><br><span class="line"><span class="meta"># unixsocketperm 700</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭掉空闲 N 秒的连接 (0 则是不处理空闲连接)</span></span><br><span class="line">timeout <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># TCP keepalive.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 如果该值不为 0, 将使用 SO_KEEPALIVE 这一默认的做法来向客户端连接发送 TCP ACKs </span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 这样的好处有以下两个原因:</span></span><br><span class="line"><span class="meta"># 1) 检测已经死亡的对端 (译者注: TCP 的关闭会存在无法完成 4 次握手的情况, 如断电, 断网, 数据丢失等等)</span></span><br><span class="line"><span class="meta"># 2) 保持连接在网络环境中的存活</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在 Linux 中, 该指定时间是一次发送 ACKs 的时间片.</span></span><br><span class="line"><span class="meta"># 对于其他内核系统, 其时间片大小与内核配置有关.</span></span><br><span class="line"><span class="meta"># 一个比较合理的值是 300 seconds.Redis 3.2.1 版本之后默认指定该值为 300 seconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">tcp-keepalive <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################# GENERAL #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># redis 默认不是以一个守护进程来运行的, 使用 yes, 可以让 redis 作为守护进程来运行.</span></span><br><span class="line"><span class="meta"># 注意: 当 redis 作为守护进程的时候 /var/run/redis.pid 作为 pid 文件.</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果需要在机器启动 (upstart 模式 或 systemd 模式) 时就启动 Redis 服务器, 可以通过该选项来配置 Redis.</span></span><br><span class="line"><span class="meta"># 支持的模式:</span></span><br><span class="line"><span class="meta">#supervised no      – 无, 不会与 supervised tree 进行交互</span></span><br><span class="line"><span class="meta"># supervised upstart – 将 Redis 服务器添加到 SIGSTOP 模式中</span></span><br><span class="line"><span class="meta"># supervised systemd – 将 READY=1 写入 $NOTIFY_SOCKET</span></span><br><span class="line"><span class="meta"># supervised auto    - 根据环境变量 UPSTART_JOB 或 NOTIFY_SOCKET 检测 upstart 还是 systemd</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 上述 supervision 方法 (upstart 或 systemd) 仅发出 “程序已就绪” 信号, 不会继续给 supervisor 返回 ping 回复.</span></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果指定了 pid 文件, Redis 会在启动时写该 pid 文件, 在退出时删除该文件.</span></span><br><span class="line"><span class="meta"># 当 Redis 服务器已守护进程启动时, 如果指定了配置文件, 则直接使用, 如果没有指定, 则创建 / var/run/redis.pid 作为配置文件.</span></span><br><span class="line">pidfile /<span class="keyword">var</span>/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定日志的记录级别的.</span></span><br><span class="line"><span class="meta"># 可以是如下的几个值之一:</span></span><br><span class="line"><span class="meta"># debug (尽可能多的日志信息, 用于开发和测试之中)</span></span><br><span class="line"><span class="meta"># verbose (少但是有用的信息, 没有 debug 级别那么混乱)</span></span><br><span class="line"><span class="meta"># notice (适量的信息, 用于生产环境)</span></span><br><span class="line"><span class="meta"># warning (只有非常重要和关键的信息会被记录)</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定日志文件的位置. 为空时将输出到标准输出设备.</span></span><br><span class="line"><span class="meta"># 如果你在 demo 模式下使用标准输出的日志, 日志将会输出到 /dev/null .</span></span><br><span class="line">logfile /<span class="keyword">var</span>/log/redis/redis.log</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当设置'syslog-enabled'为 yes 时, 允许记录日志到系统日志中.</span></span><br><span class="line"><span class="meta"># 以及你可以使用更多的日志参数来满足你的要求.</span></span><br><span class="line"><span class="meta"># syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定在系统日志中的身份.</span></span><br><span class="line"><span class="meta"># syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定系统日志的能力. 必须是 LOCAL0 到 LOCAL7 之间 (闭区间).</span></span><br><span class="line"><span class="meta"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置数据库的数量. 默认的数据库是 DB 0 使得你可以在每一个连接的基础之上使用 </span></span><br><span class="line"><span class="meta"># SELECT &lt;dbid&gt; 来指定另外的数据库, 但是这个值必须在 0 到'database'-1 之间.</span></span><br><span class="line">databases <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, Redis 只会在交互模式才显示 ASCII 版本的 logo, 可以通过设置此选项为 yes,</span></span><br><span class="line"><span class="meta"># 来使 Redis 在任何情况下都显示 logo, 使得 Redis 的此行为和 4.0 之前的版本行为保持一致.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">always-show-logo yes</span><br><span class="line"></span><br><span class="line"><span class="meta">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 将 DB 数据保存到磁盘:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># save &lt;seconds&gt; &lt;changes&gt;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 将会在 &lt; seconds&gt; 和 &lt;changes &gt; 两个值同时满足时, 将 DB 数据保存到硬盘中</span></span><br><span class="line"><span class="meta"># 其中 &lt; seconds&gt; 每多少秒,&lt;changes &gt; 是改变的 key 的数量</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在以下的例子中, 将会存在如下的行为:</span></span><br><span class="line"><span class="meta"># 当存在最少一个 key 变更时, 900 秒 (15 分钟) 后保存到硬盘</span></span><br><span class="line"><span class="meta"># 当存在最少 10 个 key 变更时, 300 秒后保存到硬盘</span></span><br><span class="line"><span class="meta"># 当存在最少 1000 个 key 变更时, 60 秒后保存到硬盘</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 提示: 你可以禁用如下的所有 save 行.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 你可以删除所有的 save 然后设置成如下这样的情况.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># save ""</span></span><br><span class="line"></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, 在发生 RDB 快照或 BGSAVE 执行失败的那一刻, Redis 执行接收写请求.</span></span><br><span class="line"><span class="meta"># 这会使用户察觉 (通常比较困难) 到数据没有正确的持久化到磁盘. 否则有可能出现不被察觉的灾难性后果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当后台 BGSAVE 程序可以再次开始工作时, Reidis 会再次自动允许写入.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果已经对 Server 和服务器持久化建立了正确的监控, 那么当你禁用该功能后, 即使磁盘、持久化等出现问题, Redis 也能继续提供服务.</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否在 dump 到 rdb 数据库的时候使用 LZF(一种高效的压缩算法) 来压缩字符串.</span></span><br><span class="line"><span class="meta"># 默认是 yes, 因为这是一个优良的做法.</span></span><br><span class="line"><span class="meta"># 如果你不想耗费你的 CPU 处理能力, 你可以设置为 no, 但是这会导致你的数据会很大.</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 从 RDB 的版本 5 开始, CRC64 校验值会写入到文件的末尾.</span></span><br><span class="line"><span class="meta"># 这会使得格式化过程中, 使得文件的完整性更有保障,</span></span><br><span class="line"><span class="meta"># 但是这会在保存和加载的时候损失不少的性能 (大概在 10%).</span></span><br><span class="line"><span class="meta"># 你可以关闭这个功能来获得最高的性能.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># RDB 文件会在校验功能关闭的时候, 使用 0 来作为校验值, 这将告诉加载代码来跳过校验步骤.</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># DB 的文件名称.</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 工作目录.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DB 将会使用上述'dbfilename'指定的文件名写入到该目录中.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 追加的文件也会在该目录中创建.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 你应该在这里输入的是一个目录而不是一个文件名.</span></span><br><span class="line">dir /<span class="keyword">var</span>/lib/redis</span><br><span class="line"></span><br><span class="line"><span class="meta">################################# REPLICATION #################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 主从复制. 单机模式下, Redis 支持使用 slaveof 命令从另一个 Redis 服务器的拷贝中来创建一个实例.</span></span><br><span class="line"><span class="meta"># 集群模式下则使用 cluster replicate &lt;master-id &gt; 命令. Redis 复制使用前须知:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="meta">#   |      Master      | ---&gt; |    Replica    |</span></span><br><span class="line"><span class="meta">#   | (receive writes) |      |  (exact copy) |</span></span><br><span class="line"><span class="meta">#   +------------------+      +---------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1)Redis 复制是异步复制, 但是可以配置连接的从节点数量.</span></span><br><span class="line"><span class="meta"># 2)当连接断开, Redis 从节点支持部分重同步 (psync) 功能来保证主从节点数据同步.</span></span><br><span class="line"><span class="meta"># 3)复制过程是一个自动化过程, 无需人工干预. 当出现网络分区后, 从节点会自动尝试建立与主节点的连接, 并尝试同步.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果主服务器开启了密码保护 (使用下面的 "requirepass" 配置).</span></span><br><span class="line"><span class="meta"># 这个配置就是告诉从服务在发起向主服务器的异步复制的请求之前使用如下的密码进行认证,</span></span><br><span class="line"><span class="meta"># 否则主服务器会拒绝这个请求.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果从服务器失去了和主服务器之间的连接, 或者当复制仍然处于处理状态的时候</span></span><br><span class="line"><span class="meta"># 从服务器做出如下的两个行为:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1) 如果 slave-serve-stale-data 被设置为 yes(默认值), 从服务器将会持续</span></span><br><span class="line"><span class="meta"># 回复来自客户端的请求, 可能会回复已经过期的数据,</span></span><br><span class="line"><span class="meta"># 或者返回空的数据, 当从服务器第一次异步请求数据时.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 2) 如果 slave-serve-stale-data 被设置为 no ,</span></span><br><span class="line"><span class="meta"># 从服务器就会返回 "SYNC with master in progress"</span></span><br><span class="line"><span class="meta"># 这个错误, 来应答所有命令除了 INFO 和 SLAVEOF.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 你可以配置一个从服务器的实例是否接受写请求,</span></span><br><span class="line"><span class="meta"># 从服务器在存储一些短暂的数据的的时候, 接收写请求是一件非常正确的事情</span></span><br><span class="line"><span class="meta"># (因为数据在向主服务器同步之后非常容易擦除) 但是会因为配置不正确而导致一些问题.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 从 redis 2.6 开始默认从服务器是只读的服务器.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 提示: 只读的从服务器并不是设计用来公开给不受信任的互联网客户端的, 它</span></span><br><span class="line"><span class="meta"># 仅仅是一个用来防止对实例进行误操作的保护层. 只读从服务器默认用来输出管理命令</span></span><br><span class="line"><span class="meta"># 例如 CONFIG, DEBUG 和其他. 如果你想限制它的规模, 你可以使用'rename-command'来</span></span><br><span class="line"><span class="meta"># 提高它的安全性, 使得她作为一个影子来执行管理或者危险的命令.</span></span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 是否使用 socket 方式复制数据. 目前 redis 复制提供两种方式, disk 和 socket.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 对于新连接的 slaves 或断开重连的 slaves 将无法执行 “部分同步”, 需要进行一次完全同步. 当进行完全同步时, 主节点将传播一个 RDB 文件给从节点. 该 RDB 文件的传播方式有两种:</span></span><br><span class="line"><span class="meta"># 1)基于磁盘: Redis 主节点创建一个新进程将 RDB 文件写到磁盘, 然后将生成的 RDB 文件传播给从节点.</span></span><br><span class="line"><span class="meta"># 2)无磁盘: Redis 主节点创建一个新进程直接将 RDB 文件写到 slaves 的套接字中, RDB 文件无需落盘.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 基于磁盘的复制, 一旦 RDB 文件生成, 多个 slaves 将排队等待并可以共享该文件. 而无磁盘复制一旦开始传输数据, 新 slaves 到来后将会排队等待.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在使用无磁盘复制时, 主节点在开始传输同步数据前将根据配置的时间进行等待, 从而实现多个从节点的并发传输.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在磁盘速度缓慢且网络速度很快 (高带宽) 时, 无磁盘复制效率更高. 默认情况下, 无磁盘复制同步关闭.</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 无磁盘复制前, 主节点需要等待的时间. 该配置在启用无磁盘复制时将生效.</span></span><br><span class="line"><span class="meta"># 由于一旦开启一次数据传输, 其余 slaves 将排队等待, 所以最好让主节点等待一段时间, 这样主节点就可对多个 slaves 并发传播数据.</span></span><br><span class="line"><span class="meta"># 等待的单位是秒(second), 默认是 5 秒. 一旦将其设置为 0, 主节点将会马上开始数据传输.</span></span><br><span class="line">repl-diskless-sync-delay <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># slave 根据指定的时间间隔向服务器发送 ping 请求.</span></span><br><span class="line"><span class="meta"># 时间间隔可以通过 repl_ping_slave_period 来设置, 默认 10 秒.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># repl-ping-replica-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 复制连接超时时间. master 和 slave 都有超时时间的设置.</span></span><br><span class="line"><span class="meta"># master 检测到 slave 上次发送的时间超过 repl-timeout, 即认为 slave 离线, 清除该 slave 信息.</span></span><br><span class="line"><span class="meta"># slave 检测到上次和 master 交互的时间超过 repl-timeout, 则认为 master 离线.</span></span><br><span class="line"><span class="meta"># 需要注意的是 repl-timeout 需要设置一个比 repl-ping-slave-period 更大的值,</span></span><br><span class="line"><span class="meta"># 不然会经常检测到超时.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 以下情境将使用到复制超时阈值:</span></span><br><span class="line"><span class="meta"># 1) 从节点在执行 SYNC 期间, 检测块文件传输超时.</span></span><br><span class="line"><span class="meta"># 2) 从节点检测主节点离线(data、pings).</span></span><br><span class="line"><span class="meta"># 3) 主节点检测从节点离线(REPLCONF ACK).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 必须要确保复制超时阈值 (repl-timeout) 大于 slaves 定时向 master 发送 PING 的时间片(repl-ping-slave-period),</span></span><br><span class="line"><span class="meta"># 否则将总会检测到复制超时(当 slave 发送 PING 的时间片大于复制超时阈值时, slave 还未发送 ping 就会被定性为复制超时).</span></span><br><span class="line"><span class="meta"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 执行完 SYNC 后, 是否要禁用 TCP_NODELAY.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当禁用该功能后, Redis 会使用占用更少带宽的小 TCP 包向从节点发送数据.</span></span><br><span class="line"><span class="meta"># 但是这样做将会增大从节点端数据传输延时. 在 Linux 下禁用 TCP_NODELAY 功能将导致 40 微秒的延迟.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当启动该功能后, 在进行复制时将会减少数据传输延迟, 但是会占用更大的带宽.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 我们优先选择低延迟, 但是在高速网络或主从节点存在多 hops 路径时, 建议禁用 TCP_NODELAY 功能.</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置复制积压缓冲区 (replication backlog) 大小. 当 slaves 断开与节点连接后, Redis 使用复制积压缓冲区记录需要未发送给 slave 的数据.</span></span><br><span class="line"><span class="meta"># 当从节点重连后, 仅需执行一次部分同步, 将从节点缺失数据补全.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 复制积压缓冲区 (replication backlog) 越大, Redis 可以支持的 slave 离线时间就越长. 复制积压缓冲区用于部分重同步.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 复制缓冲区只有在有 slave 连接时才分配内存. 没有 slave 时, 该内存会被释放出来, 默认大小为 1m.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># repl-backlog-size 1mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当主节点不再有新连接的从节点后, 复制积压缓冲区将会被释放.</span></span><br><span class="line"><span class="meta"># 为避免因从节点频繁掉线后上线而频繁的进行复制积压缓冲区的释放与申请, Redis 提供复制积压缓冲区释放时间片 (repl-backlog-ttl) 参数, 保证主节点在检测到从节点掉线后的规定时间内不会释放该缓冲区.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 值为零时表示不会释放该复制积压缓冲区, 单位为秒.</span></span><br><span class="line"><span class="meta"># 单位为秒, 配置如下:</span></span><br><span class="line"><span class="meta"># repl-backlog-ttl 3600</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 使用整数表示从节点优先级.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当主节点无法正常工作后, Sentinel 将使用该优先级在从节点中推选出新的主节点.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 优先级对应的整数值越小, 被推选成主节点的可能性更大. 但是当优先级的值为零时表示该从节点不具备成为主节点的身份.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认优先级为 100.</span></span><br><span class="line">slave-priority <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当主节点的已连接从节点数小于 N 且这些从节点延迟均大于 M 秒, 该主节点将停止接收写请求.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点处于 “online” 状态, 当且仅当延迟 (通过计算距离上一次接收从节点的 ping 消息的时间间隔获得) 小于指定的阈值.</span></span><br><span class="line"><span class="meta"># 这个选项配置不是用来保证 N 个部分接收写信息, 而是为了在没有足够的从节点可用时, 限制写丢失.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如需要至少需要 3 个从节点并在 10s 内可用, 则设置:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 延迟小于 min-slaves-max-lag 秒的 slave 才认为是健康的 slave.</span></span><br><span class="line"><span class="meta"># min-slaves-to-write 3</span></span><br><span class="line"><span class="meta"># 设置 1 或另一个设置为 0 禁用这个特性.</span></span><br><span class="line"><span class="meta"># min-slaves-max-lag 10</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一旦对这两个中的一个赋值为零, 则该功能失效.</span></span><br><span class="line"><span class="meta"># 默认 min-slaves-to-write 参数设置为 0, 即该功能默认不启用.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 主节点可以通过多种途径显示已连接从节点的 IP 和 port. 如 Sentinel 可以使用 “INFO replication” 命令来发现从节点实例；</span></span><br><span class="line"><span class="meta"># Master 可以使用 “ROLE” 命令显示从节点 IP 和 port 信息等.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># slave 获取 IP 和 port 的方式是:</span></span><br><span class="line"><span class="meta"># IP: 自动检测获取. 当从节点连接主节点时, 通过检查对应套接字地址获取.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#Port: 从节点在复制中和主节点握手时需要使用到 port. 通常情况下, port 即为连接时的 port.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 但是, 当发生端口转发(port forwarding, 转发一个网络端口从一个网络节点到另一个网络节点的行为)</span></span><br><span class="line"><span class="meta"># 或使用 NAT(Network Address Translation, 网络地址转换)技术是, 从节点需要被分配不同 IP 和 port 后才能被访问.</span></span><br><span class="line"><span class="meta"># 接下来的两个配置用来设置从节点的 IP 和 port, 用来告知主节点所指定的 IP 和 port, 这样 INFO 和 ROLE 才能继续返回结果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 当需要重写 IP 和 port 时, 则无需配置该选项.</span></span><br><span class="line"><span class="meta"># slave-announce-ip 5.5.5.5</span></span><br><span class="line"><span class="meta"># slave-announce-port 1234</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## SECURITY ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Server 在处理客户端命令前, 该客户端需要提供提供认证密码. 这在非可信网络环境中很有用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为减少后台执行复杂度, 这个选项一般都会被注释掉. 因为大多数用户不需要授权.(如用户使用自己的服务器)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Warning: 由于 Redis 执行高效, 所以外部用户每秒可以尝试认证 15w 次.</span></span><br><span class="line"><span class="meta"># 也就是说, 为避免密码被快送攻破, 用户需要使用一个极其复杂的密码.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># requirepass foobared</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 重命名命令.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在一个共享环境中有必要对危险命令进行重命令, 从而避免危险命令的滥用、无用.</span></span><br><span class="line"><span class="meta"># 如给 CONFIG 命令重新设置一个难以猜测的命令, 这样这个命令就很难被普通用户使用的, 但仍能被内部工具使用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 设置成一个空的值, 可以禁止一个命令.</span></span><br><span class="line"><span class="meta"># rename-command CONFIG ""</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 一定要避免重命名那些写 AOF 文件或传输数据给 slaves 的命令, 否则将会导致各种难以预料的错误.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################### CLIENTS ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置能连上 redis 的最大客户端连接数量. 默认是 10000 个客户端连接.</span></span><br><span class="line"><span class="meta"># 由于 redis 不区分连接是客户端连接还是内部打开文件或者和 slave 连接等,</span></span><br><span class="line"><span class="meta"># 所以 maxclients 最小建议设置到 32. 如果超过了 maxclients,</span></span><br><span class="line"><span class="meta"># redis 会给新的连接发送’max number of clients reached’, 并关闭连接.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################## MEMORY MANAGEMENT ################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># redis 配置的最大内存容量. 不要再内存超过指定限制时仍然使用内存.</span></span><br><span class="line"><span class="meta"># 当达到内存上限时, Redis 会根据选定的过期键策略移除一些 key.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果根据过期键策略仍不能移除一些键或者过期键策略设置成 “noeviction”(不启用过期键策略),</span></span><br><span class="line"><span class="meta"># 那么 Redis 会向如 SET、LPUSH 等使用内存的命令返回错误, 向诸如 GET 等读命令正常返回结果.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 这个配置通常在将 Redis 当过 LRU 缓存或对以设置硬性的内存上限的 Redis 很适用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># WARNING: slaves 的输出缓冲区不在主节点的 maxmemory 计算中, 所以设置的 maxmemory 不宜过大.</span></span><br><span class="line"><span class="meta"># 如果过大, 可能导致主机的剩余内存过小, 从而不能预留足够的内存用于创建 slaves 的输出缓冲区.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 简言之, 如果当前节点存在已连接的从节点, 建立设置一个较小的 maxmemory 上限, 这样系统就可以有多余的 RAM 用与创建从节点输出缓存.(当过期键策略设置成'noeviction'时, 则没有必要这么做)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 内存容量超过 maxmemory 后的处理策略. Redis 提供五种内存淘汰策略:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># volatile-lru -&gt; 利用 LRU 算法移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-lru -&gt; 利用 LRU 算法移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-lfu -&gt; 利用 LFU 算法移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-lfu -&gt; 利用 LFU 算法移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-random -&gt; 随机移除设置过过期时间的 key.</span></span><br><span class="line"><span class="meta"># allkeys-random -&gt; 随机移除任何 key.</span></span><br><span class="line"><span class="meta"># volatile-ttl -&gt; 移除即将过期的 key, 根据最近过期时间来删除 (辅以 TTL)</span></span><br><span class="line"><span class="meta"># noeviction -&gt; 不移除任何 key, 只是返回一个写错误.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 上面的这些驱逐策略, 如果 redis 没有合适的 key 驱逐, 对于写命令, 还是会返回错误.</span></span><br><span class="line"><span class="meta"># redis 将不再接收写请求, 只接收 get 请求. 写命令包括: set setnx</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory-policy noeviction</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># lru 检测的样本数. 使用 lru 或者 ttl 淘汰算法, 从需要淘汰的列表中随机选择 sample 个 key,</span></span><br><span class="line"><span class="meta"># 选出闲置时间最长的 key 移除.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, Redis 会从五个键中选择一个最近最久未使用的键进行淘汰. 可以通过配置该选择设置检测基数.</span></span><br><span class="line"><span class="meta"># 一般情况下, 五个检测样本可以获得足够好的结果. 10 个样本的结果更接近 LRU 算法, 但是会消耗更多的 CPU.</span></span><br><span class="line"><span class="meta"># 3 个样本可以获得较高的执行速度但是不够精确.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># maxmemory-samples 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 从 Redis 5 开始, 默认情况下, replica 节点会忽略 maxmemory 设置(除非在发生 failover 后, 此节点被提升为 master 节点).</span></span><br><span class="line"><span class="meta"># 这意味着只有 master 才会执行过期删除策略, 并且 master 在删除键之后会对 replica 发送 DEL 命令.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 这个行为保证了 master 和 replicas 的一致性, 并且这通常也是你需要的, 但是若你的 replica 节点是可写的,</span></span><br><span class="line"><span class="meta"># 或者你希望 replica 节点有不同的内存配置, 并且你确保所有到 replica 写操作都幂等的, 那么你可以修改这个默认的行为(请确保你明白你在做什么).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 需要注意的是默认情况喜爱 replica 节点不会执行过期策略, 它有可能使用了超过 maxmemory 设定的值的内存.</span></span><br><span class="line"><span class="meta"># 因此你需要监控 replicas 节点所在的机器并且确保在 master 节点到达配置的 maxmemory 大小时, replicas 节点不会超过物理内存的大小.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># replica-ignore-maxmemory yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################# LAZY FREEING ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 有两种方式删除键. 一种是使用如 DEL 这样的命令进行的同步删除. </span></span><br><span class="line"><span class="meta"># 同步删除意味着删除过程中服务端会停止处理新进来的命令. 若要删除的 key 关联了一个小的 object 删除耗时会很短.</span></span><br><span class="line"><span class="meta"># 若要删除的 key 管理了一个很大的 object, 比如此对象有上百万个元素, 服务端会阻塞相同长一段时间(甚至超过一秒).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 由于以上原因, Redis 同时提供了一种非阻塞的方式用于删除,</span></span><br><span class="line"><span class="meta"># 比如 UNLINK(非阻塞的 DEL)以及用于 FLUSHALL 和 FLUSHDB 的 ASYNC 选项, 这些命令能在后台回收内存.</span></span><br><span class="line"><span class="meta"># 这些命令能在常数时间内执行完毕. 其他线程会在后台尽快回收内存.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># DEL,UNLINK 以及用于 FLUSHALL 和 FLUSHDB 的 ASYNC 选项是用户可以控制的. </span></span><br><span class="line"><span class="meta"># 根据应用的设计, 用户可以选择使用阻塞或者非阻塞的方式. </span></span><br><span class="line"><span class="meta"># 但是作为某些命令的副作用 Redis 服务端有时会删除某些 object 或者 flush 整个数据库. </span></span><br><span class="line"><span class="meta"># 特别是以下独立于用户操作的情形: </span></span><br><span class="line"><span class="meta"># 1. 由于 maxmemory 和 maxmemory policy 配置导致的内存回收动作 </span></span><br><span class="line"><span class="meta"># 2. 由于过期, 当一个 key 过期后(可以查看 EXPIRE 命令获取相关信息), 必须回收其内存 </span></span><br><span class="line"><span class="meta"># 3. 由于某些命令的副作用, 比如 STORE 命令, 执行 STORE 命令可能需要删除已有的键. SET 命令需要删除已有的旧内容.</span></span><br><span class="line"><span class="meta"># 4. 在复制过程中, 当一个 replica 节点执行一个全量同步时, replica 需要删除整个数据库的内容以加载传输过来的 RDB 文件.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 在上述所有情形中, 删除 object 的默认行为都是以阻塞方式删除. 当然你可以配置上述四个选项来改变这种默认行为:</span></span><br><span class="line"></span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line"></span><br><span class="line"><span class="meta">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认 redis 使用的是 rdb 方式持久化, 这种方式在许多应用中已经足够用了.</span></span><br><span class="line"><span class="meta"># 但是 redis 如果中途宕机, 会导致可能有几分钟的数据丢失, 根据 save 来策略进行持久化,</span></span><br><span class="line"><span class="meta"># Append Only File 是另一种持久化方式, 可以提供更好的持久化特性.</span></span><br><span class="line"><span class="meta"># Redis 会把每次写入的数据在接收后都写入 appendonly.aof 文件,</span></span><br><span class="line"><span class="meta"># 每次启动时 Redis 都会先把这个文件的数据读入内存里, 先忽略 RDB 文件.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, Redis 会异步将数据集快照到磁盘上. 尽管这种模式对许多应用友好, 但是当 Redis 进程崩溃或发生掉电时,</span></span><br><span class="line"><span class="meta"># 几分钟内的写信息将丢失(根据快照执行的粒度).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># AOF 作为一种可替换的持久化策略, 能够提供更好的耐久性.</span></span><br><span class="line"><span class="meta"># 如使用默认的 fsync 策略, Redis 仅会丢失 1s 的写信息, 当发生突发事件(服务器掉电、服务器进程崩溃但 OS 运行正常).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># AOF 持久化和 RDB 持久化可以同时开启. 如果在启动 Redis 时已经存在 AOF 文件, 则会直接加载 AOF 文件(考虑到 AOF 文件相比 RDB 文件有更好的耐久性).</span></span><br><span class="line"><span class="meta"># 关于 AOF 的更多讯息见: http://redis.io/topics/persistence </span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定 AOF 文件名称, 默认是 appendonly.aof.</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 调用 fsync() 系统函数用来告知 OS 将数据写入磁盘, 而不是在输出缓冲区等待数据. 有些 OS 将直接 flush 数据到磁盘, 有些其他的 OS 仅会尝试去 flush.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Redis 支持三种 fsync() 调用模式:</span></span><br><span class="line"><span class="meta"># no: 不执行 fsync, 由 OS 决定 flush 数据的频率. 高效. Linux 下默认是每 30s 执行一次 flush.</span></span><br><span class="line"><span class="meta"># always: 每写入一次 AOF 就调用一次 fsync. 慢, 最安全.</span></span><br><span class="line"><span class="meta"># everysec: 每秒调用一次 fsync, 可能会导致丢失这 1s 数据.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认 fsync 的调用频率是 “everysec”, 这种策略在执行速度和数据安全进行折中.</span></span><br><span class="line"><span class="meta"># 当可以容忍一定程度数据丢失并期望更高的性能时, 可以使用 “no” 策略(由操作系统决定 flush 的频率).</span></span><br><span class="line"><span class="meta"># 相反的, 如果不能容忍数据丢失, 可以使用 “always” 获得更好的安全性, 尽管执行更慢.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在无法确定 fsync 调用频率时, 推荐使用 “everysec” 策略.</span></span><br><span class="line"><span class="meta"># 在开启 AOF 持久化功能后, 该配置才会生效.</span></span><br><span class="line"><span class="meta"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在 aof 重写或者写入 rdb 文件的时候, 会执行大量 IO, 此时对于 everysec 和 always 的 aof 模式来说,</span></span><br><span class="line"><span class="meta"># 执行 fsync 会造成阻塞过长时间, no-appendfsync-on-rewrite 字段设置为默认设置为 no.</span></span><br><span class="line"><span class="meta"># 如果对延迟要求很高的应用, 这个字段可以设置为 yes, 否则还是设置为 no,</span></span><br><span class="line"><span class="meta"># 这样对持久化特性来说这是更安全的选择. 设置为 yes 表示 rewrite 期间对新写操作不 fsync,</span></span><br><span class="line"><span class="meta"># 暂时存在内存中, 等 rewrite 完成后再写入, 默认为 no, 建议 yes.</span></span><br><span class="line"><span class="meta"># Linux 的默认 fsync 策略是 30 秒. 可能丢失 30 秒数据.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 当 AOF 执行 fsync 的策略是 always 和 everysec 时, 如果此时有一个后台进程 (BGSAVE 进程或 AOF rewrite 进程) 正在执行大量的 I/O 操作到磁盘,</span></span><br><span class="line"><span class="meta"># 在一些 Linux 系统中, 执行 fsync 会造成较长的阻塞. 当前对这种情况还没有很好的解决策略, 即使在不同的线程中执行 fsync 也会导致调用同步 write(2) 阻塞.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了缓解上述问题, 可以通过配置下述选项来避免在主线程调用 fsync() 时执行 BGSAVE 或 BGREWRITEAOF 带来的阻塞.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 也就是说, 默认情况下, 当子进程执行 BGSAVE 或 BGREWRITEAOF 时, Redis 的耐久性将默认转变成 "appendfsync none".</span></span><br><span class="line"><span class="meta"># 在实际的应用中就意味着在最坏的场景下将丢失 30s 的数据, 即使配置了 fsync 调用频率为 always 或 everysec.(默认情况下, Linux 每 30s 自动调用一次 fsync 将缓存数据 flush 到磁盘)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果当前应用已考虑延迟问题, 则将该配置设置成 “yes”. 否则使用默认配置(“no”), 这是从耐久性角度考虑的最安全的选择.</span></span><br><span class="line">no-appendfsync-on-rewrite no </span><br><span class="line"></span><br><span class="line"><span class="meta"># aof 自动重写配置. 当目前 aof 文件大小超过上一次重写的 aof 文件大小的百分之多少进行重写,</span></span><br><span class="line"><span class="meta"># 即当 aof 文件增长到一定大小的时候 Redis 能够调用 bgrewriteaof 对日志文件进行重写.</span></span><br><span class="line"><span class="meta"># 当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍 (设置为 100) 时,</span></span><br><span class="line"><span class="meta"># 自动启动新的日志重写过程.</span></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="meta"># 设置允许重写的最小 aof 文件大小, 避免了达到约定百分比但尺寸仍然很小的情况还要重写</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置 AOF 重写的触发条件.</span></span><br><span class="line"><span class="meta"># 当 AOF 日志按照指定的比例增长时, 可以通过调用 BGREWRITEAOF 执行自动的 AOF rewrite.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 工作原理: Redis 通过对比上一次执行 rewrite 时 AOF 文件的大小与当前 AOF 文件大小(在重启时将没有上一次执行 rewrite 的记录, 这时将使用 startup 时的 AOF 文件大小), 决定是否进行 rewrite.</span></span><br><span class="line"><span class="meta"># 如果当前 AOF 对于上一次执行 rewrite 的 AOF 文件的增长比率大于指定的比率, 将会触发一次 rewrite.</span></span><br><span class="line"><span class="meta"># 当然, 还需指定一个 AOF 进行重写的最小单位. 这样做可以避免增长比率已经达到要求, 但对应的 AOF 仍很小的情况 (这种情况下没有必要进行 rewrite) 的发生.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果想要关闭自动 AOF rewrite 功能, 可将进行 rewrite 要求的增长比率设置 0.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认当 AOF 大于 64MB 且相比于上一次 rewrite,AOF 以扩充了两倍时会触发一次 rewrite 执行. 默认配置如下:</span></span><br><span class="line">auto-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</span><br><span class="line"></span><br><span class="line"><span class="meta"># aof 文件可能在尾部是不完整的, 当 redis 启动的时候, aof 文件的数据被载入内存.</span></span><br><span class="line"><span class="meta"># 重启可能发生在 redis 所在的主机操作系统宕机后,</span></span><br><span class="line"><span class="meta"># 尤其在 ext4 文件系统没有加上 data=ordered 选项 (redis 宕机或者异常终止不会造成尾部不完整现象.)</span></span><br><span class="line"><span class="meta"># 出现这种现象, 可以选择让 redis 退出, 或者导入尽可能多的数据. 如果选择的是 yes,</span></span><br><span class="line"><span class="meta"># 当截断的 aof 文件被导入的时候, 会自动发布一个 log 给客户端然后 load.</span></span><br><span class="line"><span class="meta"># 如果是 no, 用户必须手动 redis-check-aof 修复 AOF 文件才可以.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 在将 AOF 文件加载到内存时(重启 Redis), 可能会出现 AOF 被截断的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如当 Redis 运行所在系统突然崩溃(当 ext4 文件系统在安装时没有配置成数据按序存储), 会出现 AOF 被截断情况.</span></span><br><span class="line"><span class="meta"># 如果 Redis 程序发生崩溃或异常, 但操作系统仍能正常工作, 则不会出现 AOF 被截断的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 出现 AOF 被截断后, Redis 要么直接退出并返回错误, 要么加载被截断 AOF 中尽可能多的数据(当前默认方式).</span></span><br><span class="line"><span class="meta"># 可以通过 aof-load-truncated 选项进行配置:</span></span><br><span class="line"><span class="meta"># 当 aof-load-truncated 设置成 “yes”,Redis 仍会加载一个被截断的 AOF 文件, 同时向用户报告 AOF 文件被截断.</span></span><br><span class="line"><span class="meta"># 如果设置成 “no”,Redis 会直接返回错误并拒绝启动, 这时用户需要使用 "redis-check-aof" 程序修复 AOF, 只有这样才能重启 Server.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 注意, 如果 AOF 文件在执行一半时就出现问题, 即使设置 aof-load-truncated 为 “yes”,Redis 也会直接退出并返回错误.</span></span><br><span class="line"><span class="meta"># 这个配置仅在 Redis 尝试从 AOF 文件读更多数据但发现没有足够字计数存在时有意义.</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当重写 AOF 文件时, Redis 可以使用 RDB 文件作为 AOF 文件的前导, 这样可以更快地进行重写和恢复. </span></span><br><span class="line"><span class="meta"># 当启用这个功能时 AOF 文件由两部分组成:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   [RDB file][AOF tail]</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当加载 AOF 文件时, Redis 通过以 “REDIS” 字符串开头的 AOF 文件识别出此文件是由 RDB 和 AOF 组合而成的,</span></span><br><span class="line"><span class="meta"># Redis 会先加载 RDB 部分, 然后再加载 AOF 部分.</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line"></span><br><span class="line"><span class="meta">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 设置 Lua 脚本执超时的时间上限, 单位是毫秒, milliseconds.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当 Lua 脚本执行超时, Redis 会记录脚本执行之后的结果 (超时后) 并向查询返回错误.</span></span><br><span class="line"><span class="meta"># 当一个长时脚本执行时间超过最大执行时间时, 只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 命令可用.</span></span><br><span class="line"><span class="meta"># 停止这类脚本运行的第一个方法是调用一个非写命令. 第二种方法是 shut down 这个 server, 如果已经发送了一个写命令但用户并不想等待脚本自然终止.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果想不限制脚本的执行时间并且不需要返回 warning, 可以将该参数设置成 0 或负数.</span></span><br><span class="line">lua-time-limit <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 正常情况下, 启动的 Redis 实例为非集群模式. 只有当节点配置成集群模式时才能成为集群节点.</span></span><br><span class="line"><span class="meta"># 如需以集群模式启动, 取消下述配置的注释即可:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-enabled yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 集群配置文件的名称, 每个节点都有一个集群相关的配置文件, 持久化保存集群的信息.</span></span><br><span class="line"><span class="meta"># 这个文件并不需要手动配置, 这个配置文件有 Redis 生成并更新,</span></span><br><span class="line"><span class="meta"># 每个 Redis 集群节点需要一个单独的配置文件, 请确保与实例运行的系统中配置文件名称不冲突.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 集群节点超时阈值用来作为节点不可达并被标记为失效状态的超时上限, 单位是毫秒(millisecond)</span></span><br><span class="line"><span class="meta"># 大部分其他内部时间将其基本参考数.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-node-timeout 15000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在进行故障转移的时候, 全部 slave 都会请求申请为 master,</span></span><br><span class="line"><span class="meta"># 但是有些 slave 可能与 master 断开连接一段时间了, 导致数据过于陈旧,</span></span><br><span class="line"><span class="meta"># 这样的 slave 不应该被提升为 master. 该参数就是用来判断 slave 节点与 master 断线的时间是否过长.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 没有简单的方式可以直接准确判定从节点的”data age”, 可以通过下面两个方面的检测实现:</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 1) 如果有多个从节点可以发起故障转移, 可以让他们交换信息以选出数据状态最节点主节点的从节点.</span></span><br><span class="line"><span class="meta"># 从节点可以通过 offset 进行排名并通过该排名延迟发起故障转移的时机.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 2) 每个独立的从节点计算最近一次与主节点交互的时间.</span></span><br><span class="line"><span class="meta"># 这里的交互可以是最近一次 PING、最近一次接收到来自主节点的命令、与主节点断开连接的时间(当复制链接已经 down 掉时).</span></span><br><span class="line"><span class="meta"># 如果最近一次与主节点的交互已经足够久远, 那么这个从节点将放弃进行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 在 2) 中的时间阈值可以由用户设定. 特别地, 当从节点的最近一次与主节点的交互远大于 (node-timeout * slave-validity-factor) + repl-ping-slave-period 时, 这个从节点将不会执行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如假设 node-timeout 为 30 秒, slave-validity-factor 参数为 10,repl-ping-slave-period 为 10 秒, 当从节点距离最近一次与主节点的交互时间大于 310 秒 (30*10+10) 时, 该从节点不能进行故障转移.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一个过大的从节点有效因子 (slave-validity-factor) 会允许存储过旧数据的从节点进行故障转移, 而一个过小的从节点有效因子将会妨碍集群选择从节点成为新的主节点.</span></span><br><span class="line"><span class="meta"># 所以合理的设置从节点有效因子很重要.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了获得最大的可用性, 可以将从节点有效因子 (slave-validity-factor) 赋值为 0.</span></span><br><span class="line"><span class="meta"># 也就是说, 从节点忽略距离最近一次与主节点交互的时间段, 则是直接点尝试发起故障转移.(但是这种策略下, 这些从节点仍会根据 offset 的排名来推迟发起故障转移的时间)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点有效因子 (slave-validity-factor) 值为 0 是唯一可以保证网络分区消失后, 集群仍继续工作的值.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-replica-validity-factor 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 集群支持将从节点迁移到孤立主节点(orphaned masters), 没有可以工作从节点的主节点.</span></span><br><span class="line"><span class="meta"># 该功能减少了集群孤立主节点故障但没有可工作从节点进行故障转移的情况的发生.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 从节点可以迁移到孤立主节点当且仅当原来的主节点的剩余可工作从节点个数大于等于指定的可工作从节点数.</span></span><br><span class="line"><span class="meta"># 这个数称为从节点迁移屏蔽因子(migration barrier).</span></span><br><span class="line"><span class="meta"># 当迁移屏蔽因子设置为 1 时, 当且仅当主节点拥有至少两个可工作的从节点才允许其中从节点迁移到孤立主节点(orphaned masters).</span></span><br><span class="line"><span class="meta"># 该因子通常用来表明使用者需要为集群中的主节点配置从节点个数.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认迁移屏蔽因子是 1(从节点可以执行迁移当前仅当其主节点在该节点迁移后仍保有至少一个从节点).</span></span><br><span class="line"><span class="meta"># 如果想关闭该功能, 只需将该参数设置成一个极大值即可.</span></span><br><span class="line"><span class="meta"># 允许将迁移屏蔽因子置零. 这种行为仅在调试时有用, 且在生产环境中存在极大风险.</span></span><br><span class="line"><span class="meta"># cluster-migration-barrier 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 默认情况下, Redis 集群将停止接收客户端请求 (停止服务) 当集群检测到存在哈希槽没有对应负责的节点.</span></span><br><span class="line"><span class="meta"># 也就是说, 如果集群部分 down(如有一部分哈希槽没有对应的节点), 整个集群最终将会不可用.(集群信息传播遵循最终一致性)</span></span><br><span class="line"><span class="meta"># 当所有的槽都再次有对应负责的节点后, 集群将会自动再次可用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 但是有时希望即使集群只有部分槽有对应的节点, 集群也能继续接受客户端请求并处理对应的键空间.</span></span><br><span class="line"><span class="meta"># 为了达到上述目的, 将 ecluster-require-full-coverage 设置为 “no” 即可.</span></span><br><span class="line"><span class="meta"># cluster-require-full-coverage yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 这个选项用于控制 master 发生故障时是否自动进行 failover.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 当设置为 yes 后 master 发生故障时不会自动进行 failover, 这时你可以进行手动的 failover 操作.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-replica-no-failover no</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="meta"># available at http://redis.io web site.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">########################## CLUSTER DOCKER/NAT support  ########################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在某些部署环境下, Redis 集群的节点地址不能被自动发现, 这是因为这些节点是部署在 NAT 网络或者端口是转发的 (典型的情况就是使用了 Docker 或者其他容器).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 为了能让 Redis 集群工作在这种环境下, 我们需要进行相关配置让各个节点知道相互之间的外部地址,</span></span><br><span class="line"><span class="meta"># 这可以通过设置以下选项做到:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># * cluster-announce-ip: 表示节点的外部地址</span></span><br><span class="line"><span class="meta"># * cluster-announce-port: 表示节点的客户端口</span></span><br><span class="line"><span class="meta"># * cluster-announce-bus-port: 表示集群消息总线端口</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Each instruct the node about its address, client port, and cluster message</span></span><br><span class="line"><span class="meta"># bus port. The information is then published in the header of the bus packets</span></span><br><span class="line"><span class="meta"># so that other nodes will be able to correctly map the address of the node</span></span><br><span class="line"><span class="meta"># publishing the information.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 若以上选项未配置, 则将会启用正常的 Redis 集群自动检测机制. </span></span><br><span class="line"><span class="meta"># 若 bus port 未设置, 则会将其设置为 port + 10000.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># Example:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># cluster-announce-ip 10.1.1.5</span></span><br><span class="line"><span class="meta"># cluster-announce-port 6379</span></span><br><span class="line"><span class="meta"># cluster-announce-bus-port 6380</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 慢日志系统用来记录执行时间较长的查询.</span></span><br><span class="line"><span class="meta"># 这里的执行时间 (“execution time”) 不包括 IO 操作时间, 如接收客户端的请求, 返回请求结果等,</span></span><br><span class="line"><span class="meta"># 而是实际执行命令的时间(此时线程处于阻塞状态, 仅能执行该命令, 不能同时处理其他请求).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 可以使用两个参数配置慢日志: 一个参数告知 Redis 执行时间超时阈值(单位是微秒, microseconds), 这样一旦某个执行时间超过指定上限, 将会被记录到慢日志中；</span></span><br><span class="line"><span class="meta"># 另一个参数是慢日志的长度. 慢日志使用环式结构存储超时命令.(当慢日志满后, 新命令添加进去后, 最老的命令将被踢出)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 单位是微秒(microsecon). 注意, 负数时间会禁用慢查询日志, 而 0 则会强制记录所有命令.</span></span><br><span class="line"><span class="meta"># 默认慢日志功能是开启的.</span></span><br><span class="line">slowlog-log-slower-than <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 慢查询日志长度. 当一个新的命令被写进日志的时候, 最老的那个记录会被删掉.</span></span><br><span class="line"><span class="meta"># 这个长度没有限制. 只要有足够的内存就行. 你可以通过 SLOWLOG RESET 来释放内存.</span></span><br><span class="line">slowlog-max-len <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="meta">################################ LATENCY MONITOR ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 延迟监测自系统通过对执行期间的操作的检测来收集与延迟相关的数据.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 通过使用 LATENCY 命令, Redis 用户可以获得延迟相关的图形、报告等信息.</span></span><br><span class="line"><span class="meta"># 延迟系统只会记录大于等于设置的 latency-monitor-threshold 值的操作. 当该值为零时,</span></span><br><span class="line"><span class="meta"># 则表明关闭 latency monitor.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 默认情况下, latency monitor 功能是关闭的, 因为大多数场景下并不需要该功能.</span></span><br><span class="line"><span class="meta"># latency monitor 可以在 Redis 运行时通过 "CONFIG SET latency-monitor-threshold &lt;milliseconds&gt;" 启动.</span></span><br><span class="line">latency-monitor-threshold <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################# EVENT NOTIFICATION ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 可以通知那些已 Pub/Sub 客户端键空间发生的事件.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如, 如果开启键空间通知功能且一个客户端对 0 号数据库上的 “foo”key 执行 DEL 操作, 那么 Redis 将使用 Pub/Sub 发送两条消息:</span></span><br><span class="line"><span class="meta"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="meta"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Redis 对通知的事件进行了分类, 每一类都使用唯一的字符标记:</span></span><br><span class="line"><span class="meta">#  K  键空间 (Key) 通知, 前缀为:__keyspace@&lt;db&gt;__ </span></span><br><span class="line"><span class="meta">#  E     键事件 (Event) 通知, 前缀为:__keyevent@&lt;db&gt;__ 对于所有命令类型和非键事件, 均使用小写字母表示, 且没有前缀.</span></span><br><span class="line"><span class="meta">#  g     一般命令(Generic commands), 如 DEL, EXPIRE, RENAME 等</span></span><br><span class="line"><span class="meta">#  $     字符串 (String) 命令</span></span><br><span class="line"><span class="meta">#  l     列表 (list) 命令</span></span><br><span class="line"><span class="meta">#  s     集合 (set) 命令</span></span><br><span class="line"><span class="meta">#  h     哈希 (hash) 命令</span></span><br><span class="line"><span class="meta">#  z     有序集合 (sorted set) 命令</span></span><br><span class="line"><span class="meta">#  x     过期事件(过期键产生的事件)</span></span><br><span class="line"><span class="meta">#  e     驱逐事件(因 maxmemory 而驱逐的事件)</span></span><br><span class="line"><span class="meta">#  A     g$lshzxe 等类型的别称(Alias), 如此一来就可以使用 "AKE" 代表所有的事件类型</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># notify-keyspace-events 可以指定多个字符组成的字符串或空串. 其中空串代表关闭通知功能.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例 1: 为了开启 List 事件和 Genetic 事件(从事件名称分类来说), 可以使用如下设置:</span></span><br><span class="line"><span class="meta"># notify-keyspace-events Elg</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例 2: 为了获取过期键的信息并发送到订阅的频道, 即__keyevent@0__:expired use 信息, 可设置如下:</span></span><br><span class="line"><span class="meta"># notify-keyspace-events Ex</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 事件通知功能是关闭的, 因为大多数用户并不需要这个功能且这个功能会带来额外的性能开销.</span></span><br><span class="line"><span class="meta"># 注意, 如果没有指定键空间 (K) 通知还是键事件 (E) 通知, 那么任何事件通知都不会被传送.</span></span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Hash 数据类型的底层实现有压缩链表 (ziplist) 和哈希表(hash).</span></span><br><span class="line"><span class="meta"># 当且仅当存储的数据量小于 hash-max-ziplist-entries 且节点占用的容量小于 hash-max-ziplist-value 时才使用小数据量存储高效的 ziplist 结构存储.</span></span><br><span class="line"><span class="meta"># 否则, 使用哈希结构存储.</span></span><br><span class="line">hash-max-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># List 类型也可以通过特殊的方式来节省空间.</span></span><br><span class="line"><span class="meta"># 每个内部 list 节点允许存储的 entries 数量可以指定为已修订最大数量或最大元素数.</span></span><br><span class="line"><span class="meta"># 如指定 - 5 到 - 1, 其含义是:</span></span><br><span class="line"><span class="meta"># -5: max size: 64 Kb  &lt;-- 对于普通的工作负载, 不建议使用</span></span><br><span class="line"><span class="meta"># -4: max size: 32 Kb  &lt;-- 不建议使用</span></span><br><span class="line"><span class="meta"># -3: max size: 16 Kb  &lt;-- 有时不建议使用</span></span><br><span class="line"><span class="meta"># -2: max size: 8 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta"># -1: max size: 4 Kb   &lt;-- good</span></span><br><span class="line"><span class="meta"># 整数代表每个 list 节点准确存储指定数量的 elements</span></span><br><span class="line"><span class="meta"># 最高效的参数设置是 - 2 (8 Kb size) 或 -1 (4 Kb size)</span></span><br><span class="line"><span class="meta"># 但是, 如果需求很特殊, 则应根据需要调整参数:</span></span><br><span class="line">list-max-ziplist-size <span class="number">-2</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># List 可以实现压缩.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 压缩深度是划定 quicklist、ziplist 等 list 在压缩时的节点范围.</span></span><br><span class="line"><span class="meta"># 为了进行快速的 push/pop 操作, 不会对 list 的 head 和 tail 进行压缩, 只会对中间节点进行压缩.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 参数设置如下:</span></span><br><span class="line"><span class="meta"># 0: 关闭 list 压缩功能</span></span><br><span class="line"><span class="meta"># 1: 深度为 1 表示只有当 list 添加一个节点 (无论从 head 还是 tail 添加该节点) 后才开始进行压缩.</span></span><br><span class="line"><span class="meta">#  所以对于 [head]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[tail]</span></span><br><span class="line"><span class="meta">#  只有黑体部分加入才会执行压缩操作.</span></span><br><span class="line"><span class="meta"># 2: 深度为 2</span></span><br><span class="line"><span class="meta">#  对于链表:[head]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[tail]</span></span><br><span class="line"><span class="meta">#  不会压缩 head 或 head-&gt;next 或 tail-&gt;prev 或 tail, 而仅压缩剩余部分.</span></span><br><span class="line"><span class="meta"># 3: 深度为 3</span></span><br><span class="line"><span class="meta">#   [head]-&gt;[next]-&gt;[next]-&gt;node-&gt;node-&gt;...-&gt;node-&gt;[prev]-&gt;[prev]-&gt;[tail]</span></span><br><span class="line">list-compress-depth <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Set 数据类型的底层实现默认是 intSet, 也可以是 hash.</span></span><br><span class="line"><span class="meta"># Set 使用 hash 编码格式当且仅当字符串组成的 set 变成底数为 10 的整数, 且其值范围在 64 位整数中.</span></span><br><span class="line"><span class="meta"># 下面的配置设置用来指定 set 可以使用特殊编码格式的阈值:</span></span><br><span class="line"><span class="keyword">set</span>-max-intset-entries <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Sorted Set 默认使用 ziplist 实现, 也可通过 skiplist 编码实现来节省空间.</span></span><br><span class="line"><span class="meta"># 当且仅当 Sorted Set 中元素值大于 zset-max-ziplist-value、元素数量大于 zset-max-ziplist-entries 时, 才使用 skiplist 实现 Sorted Set.</span></span><br><span class="line">zset-max-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-max-ziplist-value <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># value 大小小于等于 hll-sparse-max-bytes 使用稀疏数据结构 (sparse),</span></span><br><span class="line"><span class="meta"># 大于 hll-sparse-max-bytes 使用稠密的数据结构 (dense).</span></span><br><span class="line"><span class="meta"># 一个比 16000 大的 value 是几乎没用的, 建议的 value 大概为 3000.</span></span><br><span class="line"><span class="meta"># 如果对 CPU 要求不高, 对空间要求较高的, 建议设置到 10000 左右.</span></span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># HyperLogLog 稀疏表示阈值.</span></span><br><span class="line"><span class="meta"># 16 位的 header 部分也在 limit 中. 当使用稀疏表示的 HyperLogLog 存储的字节超过了指定的阈值, 它将转变成稠密表示.</span></span><br><span class="line"><span class="meta"># 不建议使用大于 16000 的值. 当小于 16000 时能够获得较高存储效率.</span></span><br><span class="line"><span class="meta"># 建议的值是 3000, 该值可以在较少 PFADD(在执行稀疏编码时时间复杂度是 O(N))操作执行的同时获得极高空间使用收益. 当 CPU 问题无需考虑时, 可将该值提升到 10000, 但其值不应超过 15000.</span></span><br><span class="line">hll-sparse-max-bytes <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Streams macro node max size / items. The stream data structure is a radix</span></span><br><span class="line"><span class="meta"># tree of big nodes that encode multiple items inside. Using this configuration</span></span><br><span class="line"><span class="meta"># it is possible to configure how big a single node can be in bytes, and the</span></span><br><span class="line"><span class="meta"># maximum number of items it may contain before switching to a new node when</span></span><br><span class="line"><span class="meta"># appending new stream entries. If any of the following settings are set to</span></span><br><span class="line"><span class="meta"># zero, the limit is ignored, so for instance it is possible to set just a</span></span><br><span class="line"><span class="meta"># max entires limit by setting max-bytes to 0 and max-entries to the desired</span></span><br><span class="line"><span class="meta"># value.</span></span><br><span class="line"><span class="meta"># 用于设定 Streams 单个节点的最大大小和最多能保存多个个元素.</span></span><br><span class="line">stream-node-max-bytes <span class="number">4096</span></span><br><span class="line">stream-node-max-entries <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 激活的 rehash 会占用每 100 毫秒的 1 millisecond 的 CPU 时间来对 Redis hash table(存储数据库的键值对的 hash table)执行 rehash.</span></span><br><span class="line"><span class="meta"># 在 Redis 中 hash table 使用惰性 rehash: 在 rehashing 时, hash table 中执行的操作越多, rehash 执行的步骤也越多.</span></span><br><span class="line"><span class="meta"># 所以当 server 很空闲时, rehash 将很简单, hash table 也会有更多的内存可以使用.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 为了在条件许可的情况下对 hash table 进行 rehash, 从而节省内存空间, 默认情况下, rehash 功能会每 100 毫秒中 1 毫秒被调用一次.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 如果不确定:</span></span><br><span class="line"><span class="meta"># 使用 "activerehashing no" 如果当前应用环境很注重延迟、Redis 仅允许 2 毫秒的延迟应答.</span></span><br><span class="line"><span class="meta"># 使用 "activerehashing yes" 如果当前应用环境不是太注重延迟且想要尽可能块的释放内存空间.</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 客户端输出缓冲区可以用来强制断开那些不能够快速读取服务器数据的客户端连接.(如在 Pub/Sub 模式中, 客户端不能够快速的处理 publisher 发送过来的消息)</span></span><br><span class="line"><span class="meta"># 客户端类型可以细分为三类:</span></span><br><span class="line"><span class="meta"># normal -&gt; 普通客户端(包括 MONITOR 客户端)</span></span><br><span class="line"><span class="meta"># slave  -&gt; 从节点客户端</span></span><br><span class="line"><span class="meta"># pubsub -&gt; 订阅至少一个 pubsub 通道或模式的客户端</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># client-output-buffer-limit 设置的通用格式如下:</span></span><br><span class="line"><span class="meta"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 一旦 hard limit 达到, 客户端将直接断开连接. 如果 soft limit 达到, 客户端连接将会持续 soft seconds 后才断开连接.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 例如, 当 hard limit 是 32 MB(megabytes)、soft limit 在 10 秒内持续超过 16MB,</span></span><br><span class="line"><span class="meta"># 如果客户端输出缓冲区 (clients output buffer) 超过 32 MB 或客户客户端输出缓冲区 (clients output buffer) 超过 16MB, 并在接下来的 10 秒都高于 16MB, 客户端连接将马上断开.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认情况下, 不需对 normal 级别的 clients 进行约束因为这些客户端如果没有发起询问就不会接受数据.</span></span><br><span class="line"><span class="meta"># 所以, 只需对异步客户端进行约束因为异步客户端会出现请求速度大于 read 速度的情况.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 因为订阅者和从节点使用推的方式接受数据, 所以需要对 pubsub 客户端和 slave 客户端设置默认的客户端输出缓冲区约束.</span></span><br><span class="line"><span class="meta"># 将 hard limit 或 soft limit 置零表示关闭对应的功能.</span></span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 客户端查询缓冲区会累加新的命令. </span></span><br><span class="line"><span class="meta"># 默认情况下, 他们会限制在一个固定的数量避免协议同步失效 (比如客户端的 bug) 导致查询缓冲区出现未绑定的内存.</span></span><br><span class="line"><span class="meta"># 但是, 如果有类似于巨大的 multi/exec 请求的时候可以修改这个值以满足你的特殊需求.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># client-query-buffer-limit 1gb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在 Redis 协议中, 批量请求通常限制在 512 mb 内, 可以通过修改 proto-max-bulk-len 选项改变这个限制.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># proto-max-bulk-len 512mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis 调用一个内部函数来执行后台任务, 如在 timeout 时关闭客户端连接, 清除从未被请求的过期键, 等等.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 虽然并不是所有的 tasks 都使用同样的频率执行, 但是 Redis 会根据指定的频率值来检测 tasks 的执行.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 默认设置的值为 10, 即每秒执行 10 次.</span></span><br><span class="line"><span class="meta"># 在 Redis 处于空闲提升该值时, 将会消耗更多的 CPU.</span></span><br><span class="line"><span class="meta"># 但是, 提升该值也会使 Redis 更精确的处理超时问题, 并检测到更多的过期键.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># 该值设置范围是 1 到 500. 但是不建议将其设置大于 100.</span></span><br><span class="line"><span class="meta"># 大多数的用户建议使用默认的值(10), 并根据应用环境的低延迟需求适当提升该值(峰值建议不要大于 100).</span></span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 通常来说根据连接上来的客户端数量对 HZ 的值按比例进行调整是有用的.</span></span><br><span class="line"><span class="meta"># 这很有用, 例如, 为了避免每次后台任务处理太多的客户端, 从而避免高延迟峰值.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 默认情况下 HZ 的值为 10, 启用 dynamic-hz 后, 当有大量客户端连接进来时 HZ 的值会临时性地调高.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 启用 dynamic-hz 后, HZ 的配置值将作为基线, 当有大量的客户端连接进来时, Redis 会将 HZ 的实际值设置为 HZ 的配置值的整数倍.</span></span><br><span class="line"><span class="meta"># 通过这种方式, 空闲的 Redis 实例只会占用非常小的 CPU 时间, 当实例变得繁忙时 Redis 能更快地进行响应(相对未启用 dynamic-hz 的情况).</span></span><br><span class="line">dynamic-hz yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当子进程进行 AOF 的重写时, 如果启用了 aof-rewrite-incremental-fsync, 子进程会每生成 32 MB 数据就进行一次 fsync 操作.</span></span><br><span class="line"><span class="meta"># 通过这种方式将数据分批提交到硬盘可以避免高延迟峰值.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 当 Redis 保存 RDB 文件时, 如果启用了 rdb-save-incremental-fsync 功能, Redis 会每生成 32 MB 数据就执行一次 fsync 操作. </span></span><br><span class="line"><span class="meta"># 通过这种方式将数据分批提交到硬盘可以避免高延迟峰值.</span></span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"><span class="meta"># Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good</span></span><br><span class="line"><span class="meta"># idea to start with the default settings and only change them after investigating</span></span><br><span class="line"><span class="meta"># how to improve the performances and how the keys LFU change over time, which</span></span><br><span class="line"><span class="meta"># is possible to inspect via the OBJECT FREQ command.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># There are two tunable parameters in the Redis LFU implementation: the</span></span><br><span class="line"><span class="meta"># counter logarithm factor and the counter decay time. It is important to</span></span><br><span class="line"><span class="meta"># understand what the two parameters mean before changing them.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis</span></span><br><span class="line"><span class="meta"># uses a probabilistic increment with logarithmic behavior. Given the value</span></span><br><span class="line"><span class="meta"># of the old counter, when a key is accessed, the counter is incremented in</span></span><br><span class="line"><span class="meta"># this way:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 1. A random number R between 0 and 1 is extracted.</span></span><br><span class="line"><span class="meta"># 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).</span></span><br><span class="line"><span class="meta"># 3. The counter is incremented only if R &lt; P.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The default lfu-log-factor is 10. This is a table of how the frequency</span></span><br><span class="line"><span class="meta"># counter changes with a different number of accesses with different</span></span><br><span class="line"><span class="meta"># logarithmic factors:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 0      | 104        | 255        | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 1      | 18         | 49         | 255        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 10     | 10         | 18         | 142        | 255        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta"># | 100    | 8          | 11         | 49         | 143        | 255        |</span></span><br><span class="line"><span class="meta"># +--------+------------+------------+------------+------------+------------+</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># NOTE: The above table was obtained by running the following commands:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#   redis-benchmark -n 1000000 incr foo</span></span><br><span class="line"><span class="meta">#   redis-cli object freq foo</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># NOTE 2: The counter initial value is 5 in order to give new objects a chance</span></span><br><span class="line"><span class="meta"># to accumulate hits.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The counter decay time is the time, in minutes, that must elapse in order</span></span><br><span class="line"><span class="meta"># for the key counter to be divided by two (or decremented if it has a value</span></span><br><span class="line"><span class="meta"># less &lt;= 10).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># The default value for the lfu-decay-time is 1. A Special value of 0 means to</span></span><br><span class="line"><span class="meta"># decay the counter every time it happens to be scanned.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># lfu-log-factor 10</span></span><br><span class="line"><span class="meta"># lfu-decay-time 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">########################### ACTIVE DEFRAGMENTATION #######################</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 警告: 这个功能是实验性的. 当然此功能已经在包括生产环境在内的环境中通过压力测试. </span></span><br><span class="line"><span class="meta"># 并且被多名工程师手工测过一段时间.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># What is active defragmentation?</span></span><br><span class="line"><span class="meta"># -------------------------------</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 活动碎片整理允许 Redis 服务器压缩内存中由于申请和释放数据块导致的碎片, 从而回收内存. </span></span><br><span class="line"><span class="meta"># 碎片是每次申请内存 (幸运的是 Jemalloc 出现碎片的几率小很多) 的时候会自然发生的. </span></span><br><span class="line"><span class="meta"># 通常来说, 为了降低碎片化程度需要重启服务, 或者至少需要清除所有的数据然后重新创建. </span></span><br><span class="line"><span class="meta"># 得益于 Oran Agra 在 Redis 4.0 实现的这个特性, 进程可以在服务运行时以 “热” 方式完成这些目的.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 通常来说当碎片化达到一定程度(查看下面的配置)Redis 会使用 Jemalloc 的特性创建连续的内存空间, </span></span><br><span class="line"><span class="meta"># 并在此内存空间对现有的值进行拷贝, 拷贝完成后会释放掉旧的数据. </span></span><br><span class="line"><span class="meta"># 这个过程会对所有的导致碎片化的 key 以增量的形式进行.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 需要重点理解的是: </span></span><br><span class="line"><span class="meta"># 1. 这个特性默认是关闭的, 并且只有在编译 Redis 时使用我们代码中的 Jemalloc 版本才生效.(这是 Linux 下的默认行为)</span></span><br><span class="line"><span class="meta"># 2. 如果没有碎片问题, 你永远不需要启用这项特性 </span></span><br><span class="line"><span class="meta"># 3. 如果你需要试验这项特性, 可以通过命令 CONFIG SET activefrag yes 来启用</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># 相关的配置参数可以很好的调整碎片整理过程. 如果你不知道这些选项的作用最好使用默认值.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 启用碎片整理.</span></span><br><span class="line"><span class="meta"># activedefrag yes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有至少多少碎片时才开始碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-ignore-bytes 100mb</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有至少多少比例的碎片时才开始碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-threshold-lower 10</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 有多少比例的碎片时才开始以最大努力进行碎片整理.</span></span><br><span class="line"><span class="meta"># active-defrag-threshold-upper 100</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 进行碎片整理时至少使用多少比例的 CPU 时间.</span></span><br><span class="line"><span class="meta"># active-defrag-cycle-min 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 最大努力进行碎片整理时使用多少 CPU 时间.</span></span><br><span class="line"><span class="meta"># active-defrag-cycle-max 75</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 进行主字典扫描时处理的 set/hash/zset/list 字段的最大数量</span></span><br><span class="line"><span class="meta"># (就是说在进行主字典扫描时 set/hash/zset/list 的长度小于这个值才会处理, 大于这个值的会放在一个列表中延迟处理).</span></span><br><span class="line"><span class="meta"># active-defrag-max-scan-fields 1000</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">Redis 配置文件 redis.conf </a><br>[2]. <a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener">Redis 命令</a><br>[3]. <a href="http://blog.didispace.com/%E9%98%BF%E9%87%8C%E4%BA%91Redis%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" target="_blank" rel="noopener">阿里云 Redis 开发规范</a></p><hr><h2 id="Redis-深度探险系列"><a href="#Redis-深度探险系列" class="headerlink" title="Redis 深度探险系列"></a>Redis 深度探险系列</h2><ul><li><a href="8fb486e9.html">Redis 深度探险（一）：那些绕不过去的 Redis 知识点</a></li><li><a href="e993c76c.html">Redis 深度探险（二）：Redis 深入之道</a></li><li><a href="14348371.html">Redis 深度探险（三）：Redis 单机环境搭建以及配置说明</a></li><li><a href="d63e1e23.html">Redis 深度探险（四）：Redis 高可用性解决方案之哨兵与集群</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经过 Redis 深度探险系列的学习相信大家对 Redis 的数据结构、对象、持久化机制、过期键删除策略等知识有了大致的了解，本篇博文主要讲述 Redis 的安装步骤，然后介绍一下 Redis 配置说明，最后对 Redis 集群搭建进行详细的讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="https://blog.maoning.vip/categories/Redis/"/>
    
    
      <category term="安装教程" scheme="https://blog.maoning.vip/tags/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    
      <category term="Redis" scheme="https://blog.maoning.vip/tags/Redis/"/>
    
      <category term="配置说明" scheme="https://blog.maoning.vip/tags/%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</title>
    <link href="https://blog.maoning.vip/archives/c0dca125.html"/>
    <id>https://blog.maoning.vip/archives/c0dca125.html</id>
    <published>2019-06-29T06:31:41.000Z</published>
    <updated>2019-12-09T02:28:30.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。</p><p>Git flow 工作流是经典模型，体现了工作流的经验和精髓。随着项目过程复杂化，会感受到这个工作流中深思熟虑和威力！Git flow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。在这章节中我们将一起学习一个当前非常流行的工作流 Git flow。</p><a id="more"></a><h2 id="Git-flow-工作介绍"><a href="#Git-flow-工作介绍" class="headerlink" title="Git flow 工作介绍"></a>Git flow 工作介绍</h2><h3 id="版本管理的挑战"><a href="#版本管理的挑战" class="headerlink" title="版本管理的挑战"></a>版本管理的挑战</h3><p>虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p><ul><li>如何开始一个 Feature 的开发，而不影响别的 Feature？</li><li>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？</li><li>哪些分支已经合并回了主干？</li><li>如何进行 Release 的管理？开始一个 Release 的时候如何冻结 Feature, 如何在 Prepare Release 的时候，开发人员可以继续开发新的功能？</li><li>线上代码出 Bug 了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个 Release?</li></ul><p>大部分开发人员现在使用 Git 就只是用三个甚至两个分支，一个是 Master, 一个是 Develop, 还有一个是基于 Develop 打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个 Release, 但是人员一多，而且项目周期一长就会出现各种问题。</p><h3 id="Git-flow-流程"><a href="#Git-flow-流程" class="headerlink" title="Git flow 流程"></a>Git flow 流程</h3><p>荷兰程序员 Vincent Driessen 曾发表了一篇博客 <a href="https://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener">A Successful Git Branching Model</a>，让一个分支策略广为人知。</p><p>下面是 Git flow 的流程图：</p><p><img src="/media/15619490256878/git-model@2x.png" alt="Git flow 的流程图"></p><p>这一流程最大的亮点是考虑了紧急 Bug 的应对措施，整个流程显得过于复杂，所以在实施该方案前，需要对整个开发流程进行系统的学习。也需要借助 Git flow 等工具的辅助。</p><h2 id="Git-flow-安装以及初始化"><a href="#Git-flow-安装以及初始化" class="headerlink" title="Git flow 安装以及初始化"></a>Git flow 安装以及初始化</h2><p>工具 Git-flow 是按照 Vincent Driessen 的 branch 模型，实现的一个高层次（级别）的 git 仓库操作扩展集合。 </p><h3 id="Linux-安装-Git-flow"><a href="#Linux-安装-Git-flow" class="headerlink" title="Linux 安装 Git flow"></a>Linux 安装 Git flow</h3><p>Ubuntu 中使用 apt-get 安装 Git flow 的方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install git-flow</span><br></pre></td></tr></table></figure><p>CentOS7 中使用 wget 安装 Git flow 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget --no-check-certificate -q  <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/petervanderdoes</span><span class="regexp">/gitflow-avh/develop</span><span class="regexp">/contrib/gitflow</span>-installer.sh &amp;&amp; sudo bash gitflow-installer.sh install develop; rm gitflow-installer.sh</span><br></pre></td></tr></table></figure><h3 id="Mac-安装-Git-flow"><a href="#Mac-安装-Git-flow" class="headerlink" title="Mac 安装 Git flow"></a>Mac 安装 Git flow</h3><p>Mac 中使用 brew 安装 Git flow 的方法</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>git-flow-avh</span><br></pre></td></tr></table></figure><h3 id="Windows-安装-Git-flow"><a href="#Windows-安装-Git-flow" class="headerlink" title="Windows 安装 Git flow"></a>Windows 安装 Git flow</h3><p>Windows 中使用 wget 安装 Git flow 的方法</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget -q -O - --no-check-certificate <span class="symbol">https:</span>/<span class="regexp">/raw.github.com/petervanderdoes</span><span class="regexp">/gitflow-avh/develop</span><span class="regexp">/contrib/gitflow</span>-installer.sh install stable | bash</span><br></pre></td></tr></table></figure><h3 id="Git-flow-初始化"><a href="#Git-flow-初始化" class="headerlink" title="Git flow 初始化"></a>Git flow 初始化</h3><p>回答几个关于分支的命名约定的问题，建议使用默认值。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git flow init</span><br><span class="line"></span><br><span class="line"><span class="symbol">No</span> <span class="keyword">branches </span>exist yet. <span class="keyword">Base </span><span class="keyword">branches </span>must <span class="keyword">be </span>created now.</span><br><span class="line"><span class="keyword">Branch </span>name for production releases: [master] </span><br><span class="line"><span class="keyword">Branch </span>name for <span class="string">"next release"</span> development: [develop] </span><br><span class="line"></span><br><span class="line"><span class="symbol">How</span> to name your supporting <span class="keyword">branch </span>prefixes?</span><br><span class="line"><span class="symbol">Feature</span> <span class="keyword">branches? </span>[feature/] </span><br><span class="line"><span class="keyword">Bugfix </span><span class="keyword">branches? </span>[<span class="keyword">bugfix/] </span></span><br><span class="line"><span class="symbol">Release</span> <span class="keyword">branches? </span>[release/] </span><br><span class="line"><span class="symbol">Hotfix</span> <span class="keyword">branches? </span>[hotfix/] </span><br><span class="line"><span class="symbol">Support</span> <span class="keyword">branches? </span>[support/] </span><br><span class="line"><span class="symbol">Version</span> tag prefix? [v] </span><br><span class="line"><span class="symbol">Hooks</span> <span class="keyword">and </span>filters directory? [/home/ubuntu/study/.git/hooks]</span><br></pre></td></tr></table></figure><h2 id="Git-flow-分支模型的介绍"><a href="#Git-flow-分支模型的介绍" class="headerlink" title="Git flow 分支模型的介绍"></a>Git flow 分支模型的介绍</h2><p>Git flow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到要中央仓库中。</p><ul><li>Master 分支 - 生产分支<br>最为稳定功能比较完整的随时可发布的代码，即代码开发完成，经过测试，没有明显的 bug，才能合并到 master 中。请注意永远不要在 master 分支上直接开发和提交代码，以确保 master 上的代码一直可用。</li><li>Develop 分支 - 开发分支<br>用作平时开发的主分支，并一直存在，永远是功能最新最全的分支，包含所有要发布到下一个 release 的代码，主要用于合并其他分支，比如 feature 分支；如果修改代码，新建 feature 分支修改完再合并到 develop 分支。所有的 feature、release 分支都是从 develop 分支上拉的。</li><li>Feature 分支 - 功能分支<br>这个分支主要是用来开发新的功能，一旦开发完成，通过测试没问题（这个测试，测试新功能没问题），我们合并回 develop 分支进入下一个 release。</li><li>Release 分支 - 发布分支<br>用于发布准备的专门分支。当开发进行到一定程度，或者说快到了既定的发布日，可以发布时，建立一个 release 分支并指定版本号（可以在 finish 的时候添加）。开发人员可以对 release 分支上的代码进行集中测试和修改 bug。（这个测试，测试新功能与已有的功能是否有冲突，兼容性）全部完成经过测试没有问题后，将 release 分支上的代码合并到 master 分支和 develop 分支。</li><li>Hotfix 分支 - 热修复分支<br>用于修复线上代码的 bug。从 master 分支上拉，完成 hotfix 后，打上 tag 我们合并回 master 和 develop 分支。</li></ul><h3 id="功能分支-Feature-分支"><a href="#功能分支-Feature-分支" class="headerlink" title="功能分支 - Feature 分支"></a>功能分支 - Feature 分支</h3><p><img src="/media/15619490256878/20151223121021496.jpg" alt="功能分支 - Feature 分支"></p><p>功能分支：通常为即将发布或者未来发布版开发新的功能，这通常只存在开发者的库中。当新功能开始研发，包含该功能的发布版本在这个还是无法确定发布时间的。功能版本的实质是只要这个功能处于开发状态它就会存在，但是最终会或合并到 develop 分支（确定将新功能添加到不久的发布版中）或取消（譬如一次令人失望的测试）。</p><p>分支命名规则：分支名称以 feature/* 开头</p><ol><li>使用 Git 命令开发功能分支 - Feature 分支流程：</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 开始一项功能的开发工作时, 基于'develop'创建分支</span><br><span class="line">$ git checkout -b <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 推送到远程 -&gt; 可选</span><br><span class="line">$ git <span class="built_in">push</span> -u <span class="built_in">origin</span> <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 在'<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>'功能分支上开发完成后, 提交至仓库</span><br><span class="line">$ git commit -a -m <span class="string">"some feature"</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>. 切换到'develop'分支</span><br><span class="line">$ git checkout develop</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>. 从远程仓库拉去最新'develop'</span><br><span class="line">$ git pull <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>. 'develop'分支合并'<span class="built_in">feature</span>'功能分支   </span><br><span class="line">$ git merge --no-ff <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">7</span>. 推送'develop'分支至远程仓库   </span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br><span class="line"></span><br><span class="line"># <span class="number">8</span>. 删除'<span class="built_in">feature</span>'功能分支</span><br><span class="line">$ git branch -d <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">9</span>. 删除远程'<span class="built_in">feature</span>'功能分支</span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> <span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><p>–no-ff 标志导致合并操作创建一个新 commit 对象，即使该合并操作可以 fast-forward。这避免了丢失这个功能分支存在的历史信息，将该功能的所有提交组合在一起。</p><p><img src="/media/15619490256878/20151223121138110.jpg" alt="Feature 分支 –no-ff 标志"></p><ol start="2"><li>使用 Git-flow 命令开发功能分支 - Feature 分支流程：</li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 增加新特性 P.S.[创建了一个基于'develop'的功能分支'<span class="built_in">some</span>-<span class="built_in">feature</span>', 并切换到这个分支之下]</span><br><span class="line">$ git flow <span class="built_in">feature</span> start <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 完成新特性 P.S.[<span class="number">1</span>. 合并'<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>'分支到'develop';<span class="number">2</span>. 删除这个新特性分支; <span class="number">3</span>. 切换回'develop'分支]</span><br><span class="line">    Summary of actions:</span><br><span class="line">    - The <span class="built_in">feature</span> branch '<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>' was merged into 'develop'</span><br><span class="line">    - Feature branch '<span class="built_in">feature</span>/<span class="built_in">some</span>-<span class="built_in">feature</span>' has been locally deleted</span><br><span class="line">    - You are now on branch 'develop'</span><br><span class="line">$ git flow <span class="built_in">feature</span> finsh --no-ff <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 推送'develop'分支至远程仓库   </span><br><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> develop</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 发布新特性 P.S.[发布新特性分支到远程服务器, 所以, 其它用户也可以使用这分支]</span><br><span class="line">$ git flow <span class="built_in">feature</span> publish <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 取得一个发布的新特性分支 P.S.[取得其它用户发布的新特性分支, 并签出远程的变更]</span><br><span class="line">$ git flow <span class="built_in">feature</span> pull <span class="built_in">some</span>-<span class="built_in">feature</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 跟踪在 <span class="built_in">origin</span> 上的特性分支]</span><br><span class="line">$ git flow <span class="built_in">feature</span> <span class="built_in">track</span> <span class="built_in">some</span>-<span class="built_in">feature</span></span><br></pre></td></tr></table></figure><h3 id="热修复分支-Hotfix-分支"><a href="#热修复分支-Hotfix-分支" class="headerlink" title="热修复分支 - Hotfix 分支"></a>热修复分支 - Hotfix 分支</h3><p><img src="/media/15619490256878/20151223121423096.jpg" alt="热修复分支 - Hotfix 分支"></p><p>热修复分支：热修复分支与发布分支很相似，他们都为新的生成环境发布做准备，尽管这是未经计划的。他们来自生产环境的处于异常状态压力。当生成环境验证缺陷必须马上修复是，热修复分支可以基于 master 分支上对应与线上版本的 tag 创建。</p><p>分支命名规则：分支名称以 hotfix/* 开头</p><ol><li>使用 Git 命令开发热修复分支 - Hotfix 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 基于<span class="string">'master'</span>创建热修复分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b hotfix/some-hotfix-0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 在<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支上完成紧急修复, 提交至仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">"some hotfix"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. <span class="string">'master'</span>分支合并<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 推送<span class="string">'master'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. <span class="string">'develop'</span>分支合并<span class="string">'hotfix/some-hotfix-0.1.1'</span>功能分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 推送<span class="string">'develop'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 删除<span class="string">'hotfix/some-hotfix-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d hotfix/some-hotfix-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 重新打标签 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10. 提交所有 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Git-flow 命令开发热修复分支 - Hotfix 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 开始 git flow 紧急修复 P.S.[创建了一个基于<span class="string">'master'</span>的热修复分支, 并切换到这个分支之下]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git flow hotfix start 0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 完成新特性 P.S.[1. 合并<span class="string">'hotfix/0.1.1'</span>分支到<span class="string">'master'</span>;2. 给<span class="string">'master 打标签'</span>v0.1.1<span class="string">';3. 合并'</span>v0.1.1<span class="string">'分支到'</span>develop<span class="string">';4. 删除本地'</span>hotfix/v0.1.1<span class="string">'分支; 5. 切换回'</span>develop<span class="string">'分支]</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git flow hotfix finish --no-ff 0.1.1</span></span><br><span class="line">    Summary of actions:</span><br><span class="line">    - Hotfix branch 'hotfix/0.1.1' has been merged into 'master'</span><br><span class="line">    - The hotfix was tagged 'v0.1.1'</span><br><span class="line">    - Hotfix tag 'v0.1.1' has been back-merged into 'develop'</span><br><span class="line">    - Hotfix branch 'hotfix/0.1.1' has been locally deleted</span><br><span class="line">    - You are now on branch 'develop'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 推送<span class="string">'master'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 切换到<span class="string">'develop'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. 推送<span class="string">'develop'</span>分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br></pre></td></tr></table></figure><h3 id="发布分支-Release-分支"><a href="#发布分支-Release-分支" class="headerlink" title="发布分支 - Release 分支"></a>发布分支 - Release 分支</h3><p>发布分支：Release 分支是为新产品的发布做准备的，它允许我们在最后时刻做一些细小的修改，它们允许小 bugs 的修改和准备发布元数据（版本号，开发时间等等）。Release 分支基于 develop 分支创建； 一旦创建了 release 分支，不能在从 develop 分支合并新的改动到 release 分支，可以基于 release 分支进行测试和 bug 修改，测试不用再另外创建用于测试的分支。</p><p>分支命名规则：分支名称以 release/* 开头</p><ol><li>使用 Git 命令开发发布分支 - Release 分支流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 基于<span class="string">'develop'</span>创建发布分支, 在此分支上小 bugs 的修改和准备发布元数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b release/some-release-0.1.1 develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. <span class="string">'master'</span>分支合并<span class="string">'release/some-release-0.1.1'</span>热修复分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 推送<span class="string">'master'</span>发布分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 切换到<span class="string">'master'</span>分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6. <span class="string">'develop'</span>开发分支合并<span class="string">'release/some-release-0.1.1'</span>功能分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7. 推送<span class="string">'develop'</span>开发分支至远程仓库   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin develop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8. 删除<span class="string">'release/some-release-0.1.1'</span>发布分支   </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d release/some-release-0.1.1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9. 重新打标签 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v0.1.1 master</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10. 提交所有 tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --tags</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Git-flow 命令开发发布分支 - Release 分支流程：</li></ol><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1</span>. 开始准备 <span class="keyword">release</span> 版本 P.S.[创建了一个基于<span class="symbol">'develop</span>'的热修复分支, 并切换到这个分支之下]</span><br><span class="line">$ git flow <span class="keyword">release</span> start <span class="number">0.1</span>.<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>. 完成 <span class="keyword">release</span> 版本 P.S.[<span class="number">1</span>. 合并<span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>'分支到<span class="symbol">'master</span>';<span class="number">2</span>. 给<span class="symbol">'master</span> 打标签<span class="symbol">'v0</span>.<span class="number">1.1</span>';<span class="number">3</span>. 合并<span class="symbol">'v0</span>.<span class="number">1.1</span>'分支到<span class="symbol">'develop</span>';<span class="number">4</span>. 删除本地<span class="symbol">'release</span>/v0.<span class="number">1.1</span>'分支; <span class="number">5</span>. 切换回<span class="symbol">'develop</span>'分支]</span><br><span class="line">$ git flow <span class="keyword">release</span> finish <span class="number">0.1</span>.<span class="number">1</span></span><br><span class="line">    Summary <span class="keyword">of</span> actions:</span><br><span class="line">    - <span class="keyword">Release</span> branch <span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>' has been merged into <span class="symbol">'master</span>'</span><br><span class="line">    - The <span class="keyword">release</span> was tagged <span class="symbol">'v0</span>.<span class="number">1.1</span>'</span><br><span class="line">    - <span class="keyword">Release</span> tag <span class="symbol">'v0</span>.<span class="number">1.1</span>' has been back-merged into <span class="symbol">'develop</span>'</span><br><span class="line">    - <span class="keyword">Release</span> branch <span class="symbol">'release</span>/<span class="number">0.1</span>.<span class="number">1</span>' has been locally deleted</span><br><span class="line">    - You are now <span class="keyword">on</span> branch <span class="symbol">'develop</span>'</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>. 切换到<span class="symbol">'master</span>'分支</span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>. 推送<span class="symbol">'master</span>'分支至远程仓库   </span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>. 切换到<span class="symbol">'develop</span>'分支</span><br><span class="line">$ git checkout develop</span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>. 推送<span class="symbol">'develop</span>'分支至远程仓库   </span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><h2 id="Git-的分支工作流与-Pull-Request"><a href="#Git-的分支工作流与-Pull-Request" class="headerlink" title="Git 的分支工作流与 Pull Request"></a>Git 的分支工作流与 Pull Request</h2><p>Pull request 是 github/bitbucket 给开发人员实现便利合作提供的一个 feature。他们提供一个用户友好的 web 界面在进代码之前来讨论这些变更。</p><p>简单说，Pull request 是一种为了开发人员通知 team member 他们已经完成了一个 feature 的机制。一旦他们的 feature branch ready 了，开发人员就通过他们的 github 帐号执行一个 pull request。这将使得每个相干人知晓这个事件，他们需要 review 这个 feature branch 的代码，并且需要决定是否 merge 到 master 分支上去。</p><p>但是 pull request 并不仅仅是一种 notification, 他也是一个专门用于讨论这些即将落地代码的细节的论坛。如果有任何问题或意见，同事们可以在 pull request 中提 comments，甚至直接在这个 Pull request 中修改要落地的代码。所有这些活动都由 pull request 来跟踪。</p><p>下面通过例子介绍：热修复分支 - Hotfix 分支 Git flow 工作流和 Pull Request</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> <span class="string">'master'</span>创建<span class="string">'hotfix'</span>分支并发布<span class="string">'hotfix'</span>分支到远程服务器</span><br><span class="line"><span class="symbol">$</span> git flow hotfix start [hotfix version <span class="keyword">No</span>.] [release version <span class="keyword">No</span>.]</span><br><span class="line"><span class="symbol">$</span> git flow hotfix publish [hotfix version <span class="keyword">No</span>.] </span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> <span class="string">'developer'</span>更新代码, 切换到<span class="string">'hotfix'</span>分支</span><br><span class="line"><span class="symbol">$</span> git pull</span><br><span class="line"><span class="symbol">$</span> git checkout hotfix/[hotfix version <span class="keyword">No</span>.]</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> <span class="string">'developer'</span>修复代码, 然后提交到远程仓库, 申请 pull request 从 hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name] 到 hotfix/[hotfix version <span class="keyword">No</span>.]</span><br><span class="line"><span class="symbol">$</span> git checkout –b hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name]</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// todo fix bug</span></span><br><span class="line"><span class="symbol">$</span> git push –u origin hotfixbug-[hotfix version <span class="keyword">No</span>.]/[bug name]</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// create pull request to hotfix/[hotfix version No.]</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> <span class="string">'master'</span>处理 merge 后, 测试人员跟进测试; 无误后, 申请 pull request 从 hotfix/[hotfix version <span class="keyword">No</span>.] 到 master</span><br><span class="line"><span class="symbol">$</span> <span class="comment">// create pull request to master</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> <span class="string">'master'</span>merge to master. 针对项目维护者: git pull 和 git merge 是最常用的 merge Pull Requests 的方式, 在命令行下 merge 之后, PullRequest 也会相应地自动关闭; 或者在网站上点击同意合并</span><br><span class="line"><span class="symbol">$</span> git flow hotfix finish --<span class="keyword">no</span>-ff [hotfix version <span class="keyword">No</span>.]</span><br></pre></td></tr></table></figure><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://weyunx.com/2019/02/28/gitflow-branching-model/" target="_blank" rel="noopener">「译」浅谈 Gitflow</a><br>[2]. <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">git-flow 备忘清单</a><br>[3]. <a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 Git</a></p><hr><h2 id="Git-在团队中的最佳实践系列"><a href="#Git-在团队中的最佳实践系列" class="headerlink" title="Git 在团队中的最佳实践系列"></a>Git 在团队中的最佳实践系列</h2><ul><li><a href="1cad84b0.html">Git 在团队中的最佳实践（一）：Git 备忘清单</a></li><li><a href="c0dca125.html">Git 在团队中的最佳实践（二）：如何正确使用 Git flow 工作流</a></li><li><a href="97ab96a0.html">Git 在团队中的最佳实践（三）：如何优雅的使用 Git？</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当在团队开发中使用版本控制系统时，商定一个统一的工作流程是至关重要的。Git 的确可以在各个方面做很多事情，然而，如果在你的团队中还没有能形成一个特定有效的工作流程，那么混乱就将是不可避免的。基本上你可以定义一个完全适合你自己项目的工作流程，或者使用一个别人定义好的。就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。&lt;/p&gt;
&lt;p&gt;Git flow 工作流是经典模型，体现了工作流的经验和精髓。随着项目过程复杂化，会感受到这个工作流中深思熟虑和威力！Git flow 工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。在这章节中我们将一起学习一个当前非常流行的工作流 Git flow。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://blog.maoning.vip/categories/Git/"/>
    
    
      <category term="Git flow" scheme="https://blog.maoning.vip/tags/Git-flow/"/>
    
      <category term="工作流" scheme="https://blog.maoning.vip/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</title>
    <link href="https://blog.maoning.vip/archives/f30530aa.html"/>
    <id>https://blog.maoning.vip/archives/f30530aa.html</id>
    <published>2019-06-03T11:45:12.000Z</published>
    <updated>2020-10-12T07:44:27.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客《Java 并发编程之美（四）：深入剖析 ThreadLocal》提到 ThreadLocal 变量的基本使用方式，ThreadLocal 是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。但是在实际的开发中，有这样的一种需求：父线程生成的变量需要传递到子线程中进行使用，那么在使用 ThreadLocal 似乎就解决不了这个问题。由于 ThreadLocal 设计之初就是为了绑定当前线程，如果希望当前线程的 ThreadLocal 能够被子线程使用，实现方式就会相当困难。在此背景下，InheritableThreadLocal 应运而生，使用 InheritableThreadLocal 这个变量就可以轻松的在子线程中依旧使用父线程中的本地变量。</p><a id="more"></a><h2 id="ThreadLocal-与-InheritableThreadLocal-区别"><a href="#ThreadLocal-与-InheritableThreadLocal-区别" class="headerlink" title="ThreadLocal 与 InheritableThreadLocal 区别"></a>ThreadLocal 与 InheritableThreadLocal 区别</h2><p>ThreadLocal 声明的变量是线程私有的成员变量，每个线程都有该变量的副本，线程对变量的修改对其他线程不可见。</p><p>InheritableThreadLocal 声明的变量同样是线程私有的，但是子线程可以使用同样的 InheritableThreadLocal 类型变量从父线程继承 InheritableThreadLocal 声明的变量，父线程无法拿到其子线程的。即使可以继承，但是子线程对变量的修改对父线程也是不可见的。</p><h2 id="对-InheritableThreadLocal-的理解"><a href="#对-InheritableThreadLocal-的理解" class="headerlink" title="对 InheritableThreadLocal 的理解"></a>对 InheritableThreadLocal 的理解</h2><p>InheritableThreadLocal 类是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值。</p><p>ThreadLocal 是不支持继承性的，所谓继承性也是针对父线程和子线程来说，代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scratch</span> &#123;<span class="keyword">public</span> <span class="keyword">static</span> final ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in main"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable in main</span></span><br><span class="line"><span class="comment">// Thread-0:null</span></span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 用于子线程能够拿到父线程往 ThreadLocal 里设置的值，代码示例：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scratch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        localVariable.<span class="keyword">set</span>(<span class="string">"I'm variable in main"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.<span class="keyword">out</span>.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>())).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable in main</span></span><br><span class="line"><span class="comment">// Thread-0:I'm variable in main</span></span><br></pre></td></tr></table></figure><h2 id="深入解析-InheritableThreadLocal-类"><a href="#深入解析-InheritableThreadLocal-类" class="headerlink" title="深入解析 InheritableThreadLocal 类"></a>深入解析 InheritableThreadLocal 类</h2><p>InheritableThreadLocal 类重写了 ThreadLocal 的 3 个函数：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">ThreadLocal&lt;T&gt;</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该函数在父线程创建子线程，向子线程赋值 InheritableThreadLocal 变量时使用</span></span><br><span class="line"><span class="comment">     * 可重写 childValue() 方法实现子线程与父线程之间互不影响</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">T</span> childValue(<span class="type">T</span> parentValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于重写了 getMap，操作 InheritableThreadLocal 时，</span></span><br><span class="line"><span class="comment">     * 将只影响 Thread 类中的 inheritableThreadLocals 变量，</span></span><br><span class="line"><span class="comment">     * 与 threadLocals 变量不再有关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> getMap(<span class="type">Thread</span> t) &#123;</span><br><span class="line">        <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似于 getMap，操作 InheritableThreadLocal 时，</span></span><br><span class="line"><span class="comment">     * 将只影响 Thread 类中的 inheritableThreadLocals 变量，</span></span><br><span class="line"><span class="comment">     * 与 threadLocals 变量不再有关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    void createMap(<span class="type">Thread</span> t, <span class="type">T</span> firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> <span class="type">ThreadLocalMap</span>(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InheritableThreadLocal-赋值"><a href="#InheritableThreadLocal-赋值" class="headerlink" title="InheritableThreadLocal 赋值"></a>InheritableThreadLocal 赋值</h3><p>从源码上看，跟 ThreadLocal 不一样的无非是 ThreadLocalMap 的引用不一样了，从逻辑上来讲，这并不能做到子线程得到父线程里的值。那么秘密在那里呢？通过跟踪 Thread 的构造方法，你能够发现是在构造 Thread 对象的时候对父线程的 InheritableThreadLocal 进行了赋值。下面是 Thread 的部分源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认人构造方法, 会调用 init 方法进行初使化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Thread() &#123;</span><br><span class="line">        <span class="keyword">init</span>(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最终初始化线程的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void <span class="keyword">init</span>(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                      long stackSize, AccessControlContext acc,</span><br><span class="line">                      boolean inheritThreadLocals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> new NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parent 为当前线程, 也就是调用了 new Thread(); 方法的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">           explicitly passed in. */</span></span><br><span class="line">        g.checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g.addUnstarted();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里会继承父线程是否为后台线程的属性还有父线程的优先级</span></span><br><span class="line">        <span class="keyword">this</span>.group = g;</span><br><span class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">        <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">                acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        setPriority(priority);</span><br><span class="line">        <span class="comment">// 这里是重点, 当父线程的 inheritableThreadLocals 不为空的时候, 会调用 ThreadLocal.createInheritedMap 方法, 传入的是父线程的 inheritableThreadLocals。原来复制变量的秘密在这里</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过跟踪 Thread 的构造方法，我们发现只要父线程在构造子线程（调用 new Thread()）的时候 inheritableThreadLocals 变量不为空。新生成的子线程会通过 ThreadLocal.createInheritedMap 方法将父线程 inheritableThreadLocals 变量有的对象复制到子线程的 inheritableThreadLocals 变量上。这样就完成了线程间变量的继承与传递。</p><h3 id="ThreadLocal-createInheritedMap"><a href="#ThreadLocal-createInheritedMap" class="headerlink" title="ThreadLocal.createInheritedMap"></a>ThreadLocal.createInheritedMap</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 map, 构造一个新的 ThreadLocalMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> class ThreadLocalMap &#123;</span><br><span class="line">        <span class="comment">// 这个 private 的构造方法就是专门给 ThreadLocal 使用的</span></span><br><span class="line">        <span class="keyword">private</span> ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">            <span class="comment">// ThreadLocalMap 还是用 Entry 数组来存储对象的</span></span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="built_in">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            <span class="comment">// 创建跟父线程相同大小的 table</span></span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line">            <span class="comment">// 这里是复制 parentMap 数据的逻辑</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得到父线程中变量对应的 key, 即 ThreadLocal 对象</span></span><br><span class="line">                    ThreadLocal <span class="built_in">key</span> = e.<span class="built_in">get</span>();</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">key</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 此处会调用 InheritableThreadLocal 重写的方法, 默认直接返回入参值</span></span><br><span class="line">                        <span class="keyword">Object</span> value = <span class="built_in">key</span>.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(<span class="built_in">key</span>, value);</span><br><span class="line">                        <span class="comment">// 通过位与运算找到索引位置</span></span><br><span class="line">                        <span class="built_in">int</span> h = <span class="built_in">key</span>.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="comment">// 如果该索引位置已经被占, 则寻找下一个索引位置</span></span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        <span class="comment">// 将 Entry 放在对应的位置</span></span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        <span class="built_in">size</span>++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="InheritableThreadLocal-和线程池搭配使用存在的问题"><a href="#InheritableThreadLocal-和线程池搭配使用存在的问题" class="headerlink" title="InheritableThreadLocal 和线程池搭配使用存在的问题"></a>InheritableThreadLocal 和线程池搭配使用存在的问题</h2><h3 id="问题展示"><a href="#问题展示" class="headerlink" title="问题展示"></a>问题展示</h3><p>代码示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; localVariable = <span class="keyword">new</span> <span class="type">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">2</span>);</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.main 线程第一次赋值 "I'm variable_1 in main"localVariable.set("I'm variable_1 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.wait for all to finish[等待线程 pool-1-thread-1/pool-1-thread-2 执行完后, 在对主线程的 InheritableThreadLocal 进行赋值, 查看赋值后, 线程池中线程的 InheritableThreadLocal 是否发生变法]</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.main 线程第二次赋值 "I'm variable_2 in main"localVariable.set("I'm variable_2 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch doneSignal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// main:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br></pre></td></tr></table></figure><p>前后两次调用获取的值是一开始赋值的值，因为线程池中是缓存使用过的线程，当线程被重复调用的时候并没有再重新初始化 init() 线程，而是直接使用已经创建过的线程，所以这里的值并不会被再次操作。因为实际的项目中线程池的使用频率非常高，每一次从线程池中取出线程不能够直接使用之前缓存的变量，所以要解决这一个问题，网上大部分是推荐使用 alibaba 的开源项目 <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a>。</p><h3 id="transmittable-thread-local"><a href="#transmittable-thread-local" class="headerlink" title="transmittable-thread-local"></a>transmittable-thread-local</h3><p>JDK 的 InheritableThreadLocal 类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的 ThreadLocal 值传递已经没有意义，应用需要的实际上是把任务提交给线程池时的 ThreadLocal 值传递到任务执行时。</p><p>在 ThreadLocal 的需求场景即是 TTL（装饰器模式）的潜在需求场景，如果你的业务需要『在使用线程池等会池化复用线程的组件情况下传递 ThreadLocal』则是 TTL 目标场景。下面是几个典型场景例子：1、分布式跟踪系统；2、日志收集记录系统上下文；3 应用容器或上层框架跨应用代码给下层 SDK 传递信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final ThreadLocal&lt;<span class="keyword">String</span>&gt; localVariable = <span class="keyword">new</span> <span class="type">TransmittableThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService = Executors.<span class="keyword">new</span><span class="type">FixedThreadPool</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 额外的处理，生成修饰了的对象 executorService</span></span><br><span class="line">        executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line"></span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.main 线程第一次赋值 "I'm variable_1 in main"localVariable.set("I'm variable_1 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.wait for all to finish[等待线程 pool-1-thread-1/pool-1-thread-2 执行完后, 在对主线程的 InheritableThreadLocal 进行赋值, 查看赋值后, 线程池中线程的 InheritableThreadLocal 是否发生变法]</span></span><br><span class="line">        doneSignal.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.main 线程第二次赋值 "I'm variable_2 in main"localVariable.set("I'm variable_2 in main");</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 线程池执行方法, 查看线程中线程 InheritableThreadLocal 赋值情况</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="type">Worker</span>(doneSignal));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Runnable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">        Worker(CountDownLatch doneSignal) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doneSignal = doneSignal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            doneSignal.countDown();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + localVariable.<span class="keyword">get</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// main:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_1 in main</span></span><br><span class="line"><span class="comment">// main:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-1:I'm variable_2 in main</span></span><br><span class="line"><span class="comment">// pool-1-thread-2:I'm variable_2 in main</span></span><br></pre></td></tr></table></figure><p>整个过程的完整时序图：</p><p><img src="/media/15633498026981/r45yw78ty.png" alt="r45yw78ty"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ThreadLocal 和 InheritableThreadLocal 本质上只是为了方便编码给的工具类，具体存数据是 ThreadLocalMap 对象。</li><li>ThreadLocalMap 存的 key 对象是 ThreadLocal，value 就是真正需要存的业务对象。</li><li>Thread 里通过两个变量持用 ThreadLocalMap 对象，分别为：threadLocals 和 inheritableThreadLocals。</li><li>InheritableThreadLocal 之所以能够完成线程间变量的传递，是在 newThread() 的时候对 inheritableThreadLocals 对象里的值进行了复制。</li><li>子线程通过继承得到的 InheritableThreadLocal 里的值与父线程里的 InheritableThreadLocal 的值具有相同的引用，如果父子线程想实现不影响各自的对象，可以重写 InheritableThreadLocal 的 childValue 方法。</li></ul><hr><h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><p>[1]. <a href="https://www.jianshu.com/p/1af4f7582b80" target="_blank" rel="noopener">ThreadLocal 和 InheritableThreadLocal 深入分析</a><br>[2]. <a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a><br>[3]. <a href="https://www.jianshu.com/p/94ba4a918ff5" target="_blank" rel="noopener">InheritableThreadLocal 详解</a></p><hr><h2 id="Java-并发编程之美系列"><a href="#Java-并发编程之美系列" class="headerlink" title="Java 并发编程之美系列"></a>Java 并发编程之美系列</h2><ul><li><a href="a290319j.html">Java 并发编程之美（一）：并发队列 Queue 原理剖析</a></li><li><a href="e230219b.html">Java 并发编程之美（二）：线程池 ThreadPoolExecutor 原理探究</a></li><li><a href="q1e3r5t42.html">Java 并发编程之美（三）：异步执行框架 Eexecutor</a></li><li><a href="b9c60c0e.html">Java 并发编程之美（四）：深入剖析 ThreadLocal</a></li><li><a href="f30530aa.html">Java 并发编程之美（五）：揭开 InheritableThreadLocal 的面纱</a></li><li><a href="f4f43ede.html">Java 并发编程之美（六）：J.U.C 之线程同步辅助工具类</a></li><li><a href="bdbfedfb.html">Java 并发编程之美（七）：透彻理解 Java 并发编程</a></li><li><a href="c0108a7c.html">Java 并发编程之美（八）：循序渐进学习 Java 锁机制</a></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;博客《Java 并发编程之美（四）：深入剖析 ThreadLocal》提到 ThreadLocal 变量的基本使用方式，ThreadLocal 是一个本地线程副本变量工具类，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。但是在实际的开发中，有这样的一种需求：父线程生成的变量需要传递到子线程中进行使用，那么在使用 ThreadLocal 似乎就解决不了这个问题。由于 ThreadLocal 设计之初就是为了绑定当前线程，如果希望当前线程的 ThreadLocal 能够被子线程使用，实现方式就会相当困难。在此背景下，InheritableThreadLocal 应运而生，使用 InheritableThreadLocal 这个变量就可以轻松的在子线程中依旧使用父线程中的本地变量。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.maoning.vip/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="InheritableThreadLocal" scheme="https://blog.maoning.vip/tags/InheritableThreadLocal/"/>
    
      <category term="ThreadLocal" scheme="https://blog.maoning.vip/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
